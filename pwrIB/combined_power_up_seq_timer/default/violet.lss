
violet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000206  00800100  00002c04  00002c98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000caf  00800306  00800306  00002e9e  2**0
                  ALLOC
  3 .stab         00003ff0  00000000  00000000  00002ea0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000010d7  00000000  00000000  00006e90  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007f67  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000278  00000000  00000000  00007f96  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005138  00000000  00000000  0000820e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010af  00000000  00000000  0000d346  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000013d6  00000000  00000000  0000e3f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a88  00000000  00000000  0000f7cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b2e  00000000  00000000  00010254  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002fde  00000000  00000000  00010d82  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  00013d60  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
{
       0:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__ctors_end>
       4:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
       8:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
       c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      10:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
 * insert_str
 *
 * this copies a string into another, starting
 * at a specific index
 */
uint32 insert_str(uint8 *output, uint32 output_size, uint32 start_index, uint8 *input, uint32 input_size)
      14:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      18:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
{
	uint32 i = start_index;
	for (i = start_index; i < start_index + input_size && i < output_size-1; i++)
      1c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      20:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      24:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      28:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
		output[i] = input[i - start_index];

	return i;
}
      2c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      30:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      34:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      38:	0c 94 7e 0d 	jmp	0x1afc	; 0x1afc <__vector_14>
      3c:	0c 94 52 0d 	jmp	0x1aa4	; 0x1aa4 <__vector_15>
      40:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      44:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      48:	0c 94 91 0e 	jmp	0x1d22	; 0x1d22 <__vector_18>
      4c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      50:	0c 94 68 0e 	jmp	0x1cd0	; 0x1cd0 <__vector_20>
      54:	0c 94 53 0e 	jmp	0x1ca6	; 0x1ca6 <__vector_21>
      58:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      5c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      60:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      64:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      68:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      6c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      70:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      74:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      78:	0c 94 1e 0e 	jmp	0x1c3c	; 0x1c3c <__vector_30>
      7c:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      80:	0c 94 f5 0d 	jmp	0x1bea	; 0x1bea <__vector_32>
      84:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>
      88:	0c 94 13 01 	jmp	0x226	; 0x226 <__bad_interrupt>

0000008c <charge20Pc>:
      8c:	08 00 09 00 09 00 0a 00 0b 00 0c 00 0d 00 0d 00     ................
      9c:	0e 00 0f 00 10 00 11 00 12 00 13 00 14 00 15 00     ................
      ac:	16 00 17 00 19 00 1a 00 1b 00 1d 00 1e 00 1f 00     ................
      bc:	21 00 22 00 24 00 25 00 27 00 28 00 2b 00 2c 00     !.".$.%.'.(.+.,.
      cc:	2e 00 30 00 32 00 34 00 36 00 38 00 3b 00 3e 00     ..0.2.4.6.8.;.>.
      dc:	3f 00 42 00 45 00 48 00 4c 00 50 00 59 00 6b 00     ?.B.E.H.L.P.Y.k.
      ec:	7f 00 8a 00 9c 00 a8 00 b3 00 c1 00 ce 00 dd 00     ................
      fc:	ea 00 f9 00 0d 01 1f 01 2b 01 3f 01 7e 01 a9 01     ........+.?.~...
     10c:	b7 01 e1 01 ff 01 18 02 28 02 3d 02 4d 02 62 02     ........(.=.M.b.
     11c:	7d 02 90 02 b8 02 c5 02 d6 02 e9 02 fa 02 08 03     }...............
     12c:	16 03 25 03 32 03 40 03 4d 03 60 03 6f 03 77 03     ..%.2.@.M.`.o.w.
     13c:	83 03 95 03 9f 03 aa 03 b4 03 c0 03 c9 03 d5 03     ................
     14c:	df 03 eb 03 f5 03 00 04 05 04 12 04 19 04 22 04     ..............".
     15c:	2c 04 34 04 37 04 40 04 74 04 7e 04                 ,.4.7.@.t.~.

00000168 <discharge20Pc>:
     168:	00 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     178:	03 00 03 00 03 00 03 00 03 00 03 00 03 00 03 00     ................
     188:	03 00 04 00 04 00 04 00 04 00 18 00 18 00 18 00     ................
     198:	18 00 40 00 40 00 40 00 40 00 68 00 68 00 68 00     ..@.@.@.@.h.h.h.
     1a8:	68 00 99 00 99 00 99 00 99 00 cd 00 cd 00 cd 00     h...............
     1b8:	cd 00 ff 00 ff 00 ff 00 ff 00 39 01 39 01 39 01     ..........9.9.9.
     1c8:	39 01 97 01 97 01 97 01 97 01 26 02 a9 02 40 03     9.........&...@.
     1d8:	91 03 ef 03 18 04 2a 04 34 04 3e 04 45 04 4d 04     ......*.4.>.E.M.

000001e8 <__ctors_end>:
     1e8:	11 24       	eor	r1, r1
     1ea:	1f be       	out	0x3f, r1	; 63
     1ec:	cf ef       	ldi	r28, 0xFF	; 255
     1ee:	d0 e1       	ldi	r29, 0x10	; 16
     1f0:	de bf       	out	0x3e, r29	; 62
     1f2:	cd bf       	out	0x3d, r28	; 61

000001f4 <__do_copy_data>:
     1f4:	13 e0       	ldi	r17, 0x03	; 3
     1f6:	a0 e0       	ldi	r26, 0x00	; 0
     1f8:	b1 e0       	ldi	r27, 0x01	; 1
     1fa:	e4 e0       	ldi	r30, 0x04	; 4
     1fc:	fc e2       	ldi	r31, 0x2C	; 44
     1fe:	00 e0       	ldi	r16, 0x00	; 0
     200:	0b bf       	out	0x3b, r16	; 59
     202:	02 c0       	rjmp	.+4      	; 0x208 <__do_copy_data+0x14>
     204:	07 90       	elpm	r0, Z+
     206:	0d 92       	st	X+, r0
     208:	a6 30       	cpi	r26, 0x06	; 6
     20a:	b1 07       	cpc	r27, r17
     20c:	d9 f7       	brne	.-10     	; 0x204 <__do_copy_data+0x10>

0000020e <__do_clear_bss>:
     20e:	2f e0       	ldi	r18, 0x0F	; 15
     210:	a6 e0       	ldi	r26, 0x06	; 6
     212:	b3 e0       	ldi	r27, 0x03	; 3
     214:	01 c0       	rjmp	.+2      	; 0x218 <.do_clear_bss_start>

00000216 <.do_clear_bss_loop>:
     216:	1d 92       	st	X+, r1

00000218 <.do_clear_bss_start>:
     218:	a5 3b       	cpi	r26, 0xB5	; 181
     21a:	b2 07       	cpc	r27, r18
     21c:	e1 f7       	brne	.-8      	; 0x216 <.do_clear_bss_loop>
     21e:	0e 94 9b 08 	call	0x1136	; 0x1136 <main>
     222:	0c 94 00 16 	jmp	0x2c00	; 0x2c00 <_exit>

00000226 <__bad_interrupt>:
     226:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022a <set_component>:
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     22a:	8f 92       	push	r8
     22c:	af 92       	push	r10
     22e:	cf 92       	push	r12
     230:	ef 92       	push	r14
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     232:	0f 93       	push	r16
     234:	cf 93       	push	r28
     236:	df 93       	push	r29
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62
     23c:	9c e1       	ldi	r25, 0x1C	; 28
     23e:	89 9f       	mul	r24, r25
     240:	f0 01       	movw	r30, r0
     242:	11 24       	eor	r1, r1
     244:	ea 5c       	subi	r30, 0xCA	; 202
     246:	fc 4f       	sbci	r31, 0xFC	; 252
     248:	60 83       	st	Z, r22
     24a:	41 83       	std	Z+1, r20	; 0x01
     24c:	22 83       	std	Z+2, r18	; 0x02
     24e:	13 82       	std	Z+3, r1	; 0x03
     250:	04 83       	std	Z+4, r16	; 0x04
     252:	e5 82       	std	Z+5, r14	; 0x05
     254:	c6 82       	std	Z+6, r12	; 0x06
     256:	a7 82       	std	Z+7, r10	; 0x07
     258:	13 86       	std	Z+11, r1	; 0x0b
     25a:	14 86       	std	Z+12, r1	; 0x0c
     25c:	85 86       	std	Z+13, r8	; 0x0d
     25e:	8a 85       	ldd	r24, Y+10	; 0x0a
     260:	86 87       	std	Z+14, r24	; 0x0e
     262:	8b 85       	ldd	r24, Y+11	; 0x0b
     264:	87 87       	std	Z+15, r24	; 0x0f
     266:	8c 85       	ldd	r24, Y+12	; 0x0c
     268:	80 8b       	std	Z+16, r24	; 0x10
     26a:	14 8a       	std	Z+20, r1	; 0x14
     26c:	15 8a       	std	Z+21, r1	; 0x15
     26e:	8d 85       	ldd	r24, Y+13	; 0x0d
     270:	86 8b       	std	Z+22, r24	; 0x16
     272:	8e 85       	ldd	r24, Y+14	; 0x0e
     274:	87 8b       	std	Z+23, r24	; 0x17
     276:	13 8e       	std	Z+27, r1	; 0x1b
     278:	df 91       	pop	r29
     27a:	cf 91       	pop	r28
     27c:	0f 91       	pop	r16
     27e:	ef 90       	pop	r14
     280:	cf 90       	pop	r12
     282:	af 90       	pop	r10
     284:	8f 90       	pop	r8
     286:	08 95       	ret

00000288 <initialize_svit>:
     288:	5f 92       	push	r5
     28a:	6f 92       	push	r6
     28c:	7f 92       	push	r7
     28e:	8f 92       	push	r8
     290:	9f 92       	push	r9
     292:	af 92       	push	r10
     294:	bf 92       	push	r11
     296:	cf 92       	push	r12
     298:	df 92       	push	r13
     29a:	ef 92       	push	r14
     29c:	ff 92       	push	r15
     29e:	0f 93       	push	r16
     2a0:	1f 93       	push	r17
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	80 e6       	ldi	r24, 0x60	; 96
     2a8:	87 b9       	out	0x07, r24	; 7
     2aa:	8f e8       	ldi	r24, 0x8F	; 143
     2ac:	86 b9       	out	0x06, r24	; 6
     2ae:	1f 92       	push	r1
     2b0:	d3 e0       	ldi	r29, 0x03	; 3
     2b2:	df 93       	push	r29
     2b4:	1f 92       	push	r1
     2b6:	cf ef       	ldi	r28, 0xFF	; 255
     2b8:	cf 93       	push	r28
     2ba:	86 e0       	ldi	r24, 0x06	; 6
     2bc:	f8 2e       	mov	r15, r24
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2be:	ff 92       	push	r15
     2c0:	81 2c       	mov	r8, r1
     2c2:	a1 2c       	mov	r10, r1
     2c4:	cc 24       	eor	r12, r12
     2c6:	ca 94       	dec	r12
     2c8:	9b e0       	ldi	r25, 0x0B	; 11
     2ca:	e9 2e       	mov	r14, r25
     2cc:	00 e0       	ldi	r16, 0x00	; 0
     2ce:	20 e0       	ldi	r18, 0x00	; 0
     2d0:	47 e0       	ldi	r20, 0x07	; 7
     2d2:	60 e0       	ldi	r22, 0x00	; 0
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2da:	87 e0       	ldi	r24, 0x07	; 7
     2dc:	8f 93       	push	r24
     2de:	dd 24       	eor	r13, r13
     2e0:	d3 94       	inc	r13
  if (charging == 0xdd) // change back to dd for tomorrow 
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
     2e2:	df 92       	push	r13
     2e4:	1f 92       	push	r1
     2e6:	cf 93       	push	r28
     2e8:	8f 93       	push	r24
     2ea:	27 e1       	ldi	r18, 0x17	; 23
     2ec:	e2 2e       	mov	r14, r18
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	48 e0       	ldi	r20, 0x08	; 8
     2f2:	61 e0       	ldi	r22, 0x01	; 1
     2f4:	81 e0       	ldi	r24, 0x01	; 1
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     2f6:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     2fa:	1f 92       	push	r1
     2fc:	df 93       	push	r29
     2fe:	1f 92       	push	r1
     300:	cf 93       	push	r28
     302:	1f 92       	push	r1
     304:	88 24       	eor	r8, r8
     306:	83 94       	inc	r8
     308:	33 e1       	ldi	r19, 0x13	; 19
     30a:	e3 2e       	mov	r14, r19
     30c:	01 e0       	ldi	r16, 0x01	; 1
     30e:	20 e0       	ldi	r18, 0x00	; 0
     310:	41 e0       	ldi	r20, 0x01	; 1
     312:	62 e0       	ldi	r22, 0x02	; 2
     314:	82 e0       	ldi	r24, 0x02	; 2
     316:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     31a:	1f 92       	push	r1
     31c:	df 93       	push	r29
     31e:	1f 92       	push	r1
     320:	cf 93       	push	r28
     322:	8e e0       	ldi	r24, 0x0E	; 14
     324:	8f 93       	push	r24
     326:	42 e0       	ldi	r20, 0x02	; 2
     328:	84 2e       	mov	r8, r20
     32a:	5d e0       	ldi	r21, 0x0D	; 13
     32c:	e5 2e       	mov	r14, r21
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     32e:	02 e0       	ldi	r16, 0x02	; 2
     330:	20 e0       	ldi	r18, 0x00	; 0
     332:	41 e0       	ldi	r20, 0x01	; 1
     334:	63 e0       	ldi	r22, 0x03	; 3
     336:	83 e0       	ldi	r24, 0x03	; 3
     338:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     33c:	1f 92       	push	r1
     33e:	df 93       	push	r29
     340:	1f 92       	push	r1
     342:	cf 93       	push	r28
     344:	df 92       	push	r13
     346:	88 24       	eor	r8, r8
     348:	83 94       	inc	r8
     34a:	65 e1       	ldi	r22, 0x15	; 21
     34c:	e6 2e       	mov	r14, r22
     34e:	01 e0       	ldi	r16, 0x01	; 1
     350:	20 e0       	ldi	r18, 0x00	; 0
  {
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
     352:	42 e0       	ldi	r20, 0x02	; 2
     354:	64 e0       	ldi	r22, 0x04	; 4
     356:	84 e0       	ldi	r24, 0x04	; 4
     358:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     35c:	1f 92       	push	r1
     35e:	df 93       	push	r29
     360:	1f 92       	push	r1
     362:	cf 93       	push	r28
     364:	12 e0       	ldi	r17, 0x02	; 2
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     366:	1f 93       	push	r17
     368:	7a e1       	ldi	r23, 0x1A	; 26
     36a:	e7 2e       	mov	r14, r23
     36c:	20 e0       	ldi	r18, 0x00	; 0
     36e:	43 e0       	ldi	r20, 0x03	; 3
     370:	65 e0       	ldi	r22, 0x05	; 5
     372:	85 e0       	ldi	r24, 0x05	; 5
     374:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     378:	1f 92       	push	r1
     37a:	df 93       	push	r29
     37c:	1f 92       	push	r1
     37e:	cf 93       	push	r28
     380:	df 93       	push	r29
     382:	ed e1       	ldi	r30, 0x1D	; 29
     384:	ee 2e       	mov	r14, r30
     386:	20 e0       	ldi	r18, 0x00	; 0
     388:	44 e0       	ldi	r20, 0x04	; 4
     38a:	66 e0       	ldi	r22, 0x06	; 6
     38c:	86 e0       	ldi	r24, 0x06	; 6
     38e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     392:	8d b7       	in	r24, 0x3d	; 61
     394:	9e b7       	in	r25, 0x3e	; 62
     396:	83 96       	adiw	r24, 0x23	; 35
     398:	0f b6       	in	r0, 0x3f	; 63
     39a:	f8 94       	cli
     39c:	9e bf       	out	0x3e, r25	; 62
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     39e:	0f be       	out	0x3f, r0	; 63
     3a0:	8d bf       	out	0x3d, r24	; 61
     3a2:	1f 92       	push	r1
     3a4:	df 93       	push	r29
     3a6:	1f 92       	push	r1
     3a8:	cf 93       	push	r28
     3aa:	ff e1       	ldi	r31, 0x1F	; 31
     3ac:	bf 2e       	mov	r11, r31
     3ae:	bf 92       	push	r11
     3b0:	ae e0       	ldi	r26, 0x0E	; 14
     3b2:	ea 2e       	mov	r14, r26
     3b4:	20 e0       	ldi	r18, 0x00	; 0
     3b6:	45 e0       	ldi	r20, 0x05	; 5
     3b8:	67 e0       	ldi	r22, 0x07	; 7
     3ba:	87 e0       	ldi	r24, 0x07	; 7
     3bc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3c0:	1f 92       	push	r1
  	if (real > 12.43) 
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
     3c2:	df 93       	push	r29
     3c4:	1f 92       	push	r1
     3c6:	cf 93       	push	r28
     3c8:	b4 e0       	ldi	r27, 0x04	; 4
     3ca:	6b 2e       	mov	r6, r27
     3cc:	6f 92       	push	r6
     3ce:	8b e1       	ldi	r24, 0x1B	; 27
     3d0:	e8 2e       	mov	r14, r24
     3d2:	20 e0       	ldi	r18, 0x00	; 0
     3d4:	46 e0       	ldi	r20, 0x06	; 6
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     3d6:	68 e0       	ldi	r22, 0x08	; 8
     3d8:	88 e0       	ldi	r24, 0x08	; 8
     3da:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3de:	1f 92       	push	r1
     3e0:	df 93       	push	r29
     3e2:	1f 92       	push	r1
     3e4:	cf 93       	push	r28
     3e6:	98 e0       	ldi	r25, 0x08	; 8
     3e8:	79 2e       	mov	r7, r25
     3ea:	7f 92       	push	r7
     3ec:	2f e0       	ldi	r18, 0x0F	; 15
     3ee:	e2 2e       	mov	r14, r18
     3f0:	20 e0       	ldi	r18, 0x00	; 0
     3f2:	49 e0       	ldi	r20, 0x09	; 9
     3f4:	69 e0       	ldi	r22, 0x09	; 9
     3f6:	89 e0       	ldi	r24, 0x09	; 9
     3f8:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     3fc:	1f 92       	push	r1
     3fe:	df 93       	push	r29
     400:	1f 92       	push	r1
     402:	cf 93       	push	r28
     404:	39 e0       	ldi	r19, 0x09	; 9
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     406:	93 2e       	mov	r9, r19
     408:	9f 92       	push	r9
     40a:	49 e1       	ldi	r20, 0x19	; 25
     40c:	e4 2e       	mov	r14, r20
     40e:	20 e0       	ldi	r18, 0x00	; 0
     410:	4a e0       	ldi	r20, 0x0A	; 10
     412:	6a e0       	ldi	r22, 0x0A	; 10
     414:	8a e0       	ldi	r24, 0x0A	; 10
     416:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     41a:	1f 92       	push	r1
     41c:	df 93       	push	r29
     41e:	1f 92       	push	r1
     420:	cf 93       	push	r28
     422:	8a e0       	ldi	r24, 0x0A	; 10
     424:	8f 93       	push	r24
	{
      debug = 0x0A;
      batt_time = f0 + f1*cos(real*w) + b1*sin(real*w) +
                  f2*cos(2*real*w) + b2*sin(2*real*w) + 
				  f3*cos(3*real*w) + b3*sin(3*real*w) +
				  f4*cos(4*real*w) + b4*sin(4*real*w) +
     426:	58 e1       	ldi	r21, 0x18	; 24
     428:	e5 2e       	mov	r14, r21
     42a:	20 e0       	ldi	r18, 0x00	; 0
     42c:	4b e0       	ldi	r20, 0x0B	; 11
     42e:	6b e0       	ldi	r22, 0x0B	; 11
     430:	8b e0       	ldi	r24, 0x0B	; 11
				  f5*cos(5*real*w) + b5*sin(5*real*w);
     432:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     436:	1f 92       	push	r1
     438:	df 93       	push	r29
     43a:	1f 92       	push	r1
     43c:	cf 93       	push	r28
     43e:	60 e1       	ldi	r22, 0x10	; 16
     440:	56 2e       	mov	r5, r22
     442:	5f 92       	push	r5
	}
    else 
	{
	  debug = 0x0B;
     444:	71 e1       	ldi	r23, 0x11	; 17
     446:	e7 2e       	mov	r14, r23
     448:	20 e0       	ldi	r18, 0x00	; 0
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     44a:	4c e0       	ldi	r20, 0x0C	; 12
     44c:	6c e0       	ldi	r22, 0x0C	; 12
     44e:	8c e0       	ldi	r24, 0x0C	; 12
     450:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     454:	7f 92       	push	r7
     456:	1f 93       	push	r17
     458:	1f 92       	push	r1
     45a:	cf 93       	push	r28
     45c:	8c e0       	ldi	r24, 0x0C	; 12
     45e:	8f 93       	push	r24
     460:	e6 e1       	ldi	r30, 0x16	; 22
     462:	ee 2e       	mov	r14, r30
     464:	20 e0       	ldi	r18, 0x00	; 0
     466:	4d e0       	ldi	r20, 0x0D	; 13
     468:	6d e0       	ldi	r22, 0x0D	; 13
     46a:	8d e0       	ldi	r24, 0x0D	; 13
     46c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     470:	8d b7       	in	r24, 0x3d	; 61
     472:	9e b7       	in	r25, 0x3e	; 62
     474:	83 96       	adiw	r24, 0x23	; 35
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	9e bf       	out	0x3e, r25	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	8d bf       	out	0x3d, r24	; 61
     480:	1f 92       	push	r1
     482:	df 93       	push	r29
     484:	1f 92       	push	r1
     486:	cf 93       	push	r28
     488:	ff 92       	push	r15
     48a:	81 2c       	mov	r8, r1
     48c:	f4 e0       	ldi	r31, 0x04	; 4
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     48e:	ef 2e       	mov	r14, r31
     490:	00 e0       	ldi	r16, 0x00	; 0
     492:	20 e0       	ldi	r18, 0x00	; 0
     494:	4e e0       	ldi	r20, 0x0E	; 14
     496:	6e e0       	ldi	r22, 0x0E	; 14
     498:	8e e0       	ldi	r24, 0x0E	; 14
     49a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     49e:	1f 92       	push	r1
     4a0:	df 93       	push	r29
     4a2:	1f 92       	push	r1
     4a4:	cf 93       	push	r28
     4a6:	1f 92       	push	r1
     4a8:	a3 e0       	ldi	r26, 0x03	; 3
     4aa:	8a 2e       	mov	r8, r26
     4ac:	b5 e1       	ldi	r27, 0x15	; 21
     4ae:	eb 2e       	mov	r14, r27
     4b0:	02 e0       	ldi	r16, 0x02	; 2
     4b2:	20 e0       	ldi	r18, 0x00	; 0
     4b4:	40 e1       	ldi	r20, 0x10	; 16
     4b6:	6f e0       	ldi	r22, 0x0F	; 15
     4b8:	8f e0       	ldi	r24, 0x0F	; 15
     4ba:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4be:	1f 92       	push	r1
     4c0:	df 93       	push	r29
     4c2:	1f 92       	push	r1
     4c4:	cf 93       	push	r28
     4c6:	8d e0       	ldi	r24, 0x0D	; 13
     4c8:	8f 93       	push	r24
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     4ca:	88 24       	eor	r8, r8
     4cc:	83 94       	inc	r8
     4ce:	02 e1       	ldi	r16, 0x12	; 18
     4d0:	e0 2e       	mov	r14, r16
     4d2:	01 e0       	ldi	r16, 0x01	; 1
     4d4:	20 e0       	ldi	r18, 0x00	; 0
     4d6:	4f e0       	ldi	r20, 0x0F	; 15
     4d8:	60 e1       	ldi	r22, 0x10	; 16
     4da:	80 e1       	ldi	r24, 0x10	; 16
     4dc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4e0:	1f 92       	push	r1
     4e2:	df 93       	push	r29
     4e4:	1f 92       	push	r1
     4e6:	cf 93       	push	r28
     4e8:	85 e0       	ldi	r24, 0x05	; 5
     4ea:	78 2e       	mov	r7, r24
     4ec:	7f 92       	push	r7
     4ee:	9c e1       	ldi	r25, 0x1C	; 28
     4f0:	e9 2e       	mov	r14, r25
     4f2:	20 e0       	ldi	r18, 0x00	; 0
     4f4:	4f ef       	ldi	r20, 0xFF	; 255
     4f6:	61 e1       	ldi	r22, 0x11	; 17
     4f8:	81 e1       	ldi	r24, 0x11	; 17
     4fa:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     4fe:	1f 92       	push	r1
     500:	df 93       	push	r29
     502:	1f 92       	push	r1
     504:	cf 93       	push	r28
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     506:	5f 92       	push	r5
     508:	22 e0       	ldi	r18, 0x02	; 2
     50a:	82 2e       	mov	r8, r18
     50c:	3f e0       	ldi	r19, 0x0F	; 15
     50e:	e3 2e       	mov	r14, r19
     510:	02 e0       	ldi	r16, 0x02	; 2
     512:	20 e0       	ldi	r18, 0x00	; 0
     514:	4f ef       	ldi	r20, 0xFF	; 255
     516:	62 e1       	ldi	r22, 0x12	; 18
     518:	82 e1       	ldi	r24, 0x12	; 18
     51a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     51e:	1f 92       	push	r1
     520:	df 93       	push	r29
     522:	1f 92       	push	r1
     524:	cf 93       	push	r28
     526:	82 e1       	ldi	r24, 0x12	; 18
     528:	8f 93       	push	r24
     52a:	41 e1       	ldi	r20, 0x11	; 17
     52c:	e4 2e       	mov	r14, r20
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	4f ef       	ldi	r20, 0xFF	; 255
     532:	63 e1       	ldi	r22, 0x13	; 19
     534:	83 e1       	ldi	r24, 0x13	; 19
     536:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     53a:	9f 92       	push	r9
     53c:	1f 93       	push	r17
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     53e:	1f 92       	push	r1
     540:	cf 93       	push	r28
     542:	1f 93       	push	r17
     544:	81 2c       	mov	r8, r1
     546:	ee 24       	eor	r14, r14
     548:	e3 94       	inc	r14
     54a:	00 e0       	ldi	r16, 0x00	; 0
     54c:	21 e0       	ldi	r18, 0x01	; 1
     54e:	4f ef       	ldi	r20, 0xFF	; 255
     550:	64 e1       	ldi	r22, 0x14	; 20
     552:	84 e1       	ldi	r24, 0x14	; 20
     554:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     558:	8d b7       	in	r24, 0x3d	; 61
     55a:	9e b7       	in	r25, 0x3e	; 62
     55c:	83 96       	adiw	r24, 0x23	; 35
     55e:	0f b6       	in	r0, 0x3f	; 63
     560:	f8 94       	cli
     562:	9e bf       	out	0x3e, r25	; 62
     564:	0f be       	out	0x3f, r0	; 63
     566:	8d bf       	out	0x3d, r24	; 61
     568:	8b e0       	ldi	r24, 0x0B	; 11
     56a:	8f 93       	push	r24
     56c:	1f 93       	push	r17
     56e:	1f 92       	push	r1
     570:	cf 93       	push	r28
     572:	5e e1       	ldi	r21, 0x1E	; 30
     574:	95 2e       	mov	r9, r21
     576:	9f 92       	push	r9
     578:	62 e0       	ldi	r22, 0x02	; 2
     57a:	86 2e       	mov	r8, r22
     57c:	74 e1       	ldi	r23, 0x14	; 20
     57e:	e7 2e       	mov	r14, r23
     580:	02 e0       	ldi	r16, 0x02	; 2
     582:	21 e0       	ldi	r18, 0x01	; 1
     584:	4f ef       	ldi	r20, 0xFF	; 255
     586:	65 e1       	ldi	r22, 0x15	; 21
     588:	85 e1       	ldi	r24, 0x15	; 21
     58a:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     58e:	1f 92       	push	r1
     590:	df 93       	push	r29
     592:	1f 92       	push	r1
     594:	cf 93       	push	r28
     596:	df 93       	push	r29
     598:	81 2c       	mov	r8, r1
     59a:	e7 e0       	ldi	r30, 0x07	; 7
     59c:	ee 2e       	mov	r14, r30
     59e:	00 e0       	ldi	r16, 0x00	; 0
     5a0:	21 e0       	ldi	r18, 0x01	; 1
     5a2:	4f ef       	ldi	r20, 0xFF	; 255
     5a4:	66 e1       	ldi	r22, 0x16	; 22
     5a6:	86 e1       	ldi	r24, 0x16	; 22
     5a8:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5ac:	1f 92       	push	r1
     5ae:	1f 93       	push	r17
     5b0:	1f 92       	push	r1
     5b2:	cf 93       	push	r28
     5b4:	84 e1       	ldi	r24, 0x14	; 20
     5b6:	8f 93       	push	r24
     5b8:	f2 e1       	ldi	r31, 0x12	; 18
     5ba:	ef 2e       	mov	r14, r31
     5bc:	21 e0       	ldi	r18, 0x01	; 1
     5be:	4f ef       	ldi	r20, 0xFF	; 255
     5c0:	67 e1       	ldi	r22, 0x17	; 23
     5c2:	87 e1       	ldi	r24, 0x17	; 23
     5c4:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5c8:	df 92       	push	r13
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     5ca:	1f 93       	push	r17
     5cc:	1f 92       	push	r1
     5ce:	cf 93       	push	r28
     5d0:	85 e1       	ldi	r24, 0x15	; 21
     5d2:	8f 93       	push	r24
     5d4:	a3 e1       	ldi	r26, 0x13	; 19
     5d6:	ea 2e       	mov	r14, r26
     5d8:	21 e0       	ldi	r18, 0x01	; 1
     5da:	4f ef       	ldi	r20, 0xFF	; 255
     5dc:	68 e1       	ldi	r22, 0x18	; 24
     5de:	88 e1       	ldi	r24, 0x18	; 24
     5e0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     5e4:	1f 93       	push	r17
     5e6:	1f 93       	push	r17
     5e8:	1f 92       	push	r1
     5ea:	cf 93       	push	r28
     5ec:	86 e1       	ldi	r24, 0x16	; 22
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     5ee:	8f 93       	push	r24
     5f0:	ba e0       	ldi	r27, 0x0A	; 10
     5f2:	eb 2e       	mov	r14, r27
     5f4:	21 e0       	ldi	r18, 0x01	; 1
     5f6:	4f ef       	ldi	r20, 0xFF	; 255
     5f8:	69 e1       	ldi	r22, 0x19	; 25
     5fa:	89 e1       	ldi	r24, 0x19	; 25
     5fc:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     600:	df 93       	push	r29
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     602:	1f 93       	push	r17
     604:	1f 92       	push	r1
     606:	cf 93       	push	r28
     608:	87 e1       	ldi	r24, 0x17	; 23
     60a:	8f 93       	push	r24
     60c:	8f e0       	ldi	r24, 0x0F	; 15
     60e:	e8 2e       	mov	r14, r24
     610:	21 e0       	ldi	r18, 0x01	; 1
     612:	4f ef       	ldi	r20, 0xFF	; 255
     614:	6a e1       	ldi	r22, 0x1A	; 26
     616:	8a e1       	ldi	r24, 0x1A	; 26
     618:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     61c:	6f 92       	push	r6
     61e:	1f 93       	push	r17
     620:	1f 92       	push	r1
     622:	cf 93       	push	r28
     624:	88 e1       	ldi	r24, 0x18	; 24
     626:	8f 93       	push	r24
     628:	99 e0       	ldi	r25, 0x09	; 9
     62a:	e9 2e       	mov	r14, r25
     62c:	21 e0       	ldi	r18, 0x01	; 1
     62e:	4f ef       	ldi	r20, 0xFF	; 255
     630:	6b e1       	ldi	r22, 0x1B	; 27
     632:	8b e1       	ldi	r24, 0x1B	; 27
     634:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     638:	8d b7       	in	r24, 0x3d	; 61
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     63a:	9e b7       	in	r25, 0x3e	; 62
     63c:	83 96       	adiw	r24, 0x23	; 35
     63e:	0f b6       	in	r0, 0x3f	; 63
     640:	f8 94       	cli
     642:	9e bf       	out	0x3e, r25	; 62
     644:	0f be       	out	0x3f, r0	; 63
     646:	8d bf       	out	0x3d, r24	; 61
     648:	1f 92       	push	r1
     64a:	df 93       	push	r29
     64c:	1f 92       	push	r1
     64e:	cf 93       	push	r28
     650:	89 e1       	ldi	r24, 0x19	; 25
     652:	8f 93       	push	r24
     654:	2e e0       	ldi	r18, 0x0E	; 14
     656:	e2 2e       	mov	r14, r18
     658:	21 e0       	ldi	r18, 0x01	; 1
     65a:	4f ef       	ldi	r20, 0xFF	; 255
     65c:	6c e1       	ldi	r22, 0x1C	; 28
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
     65e:	8c e1       	ldi	r24, 0x1C	; 28
     660:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     664:	1f 92       	push	r1
     666:	df 93       	push	r29
     668:	1f 92       	push	r1
     66a:	cf 93       	push	r28
     66c:	8a e1       	ldi	r24, 0x1A	; 26
     66e:	8f 93       	push	r24
     670:	30 e1       	ldi	r19, 0x10	; 16
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     672:	e3 2e       	mov	r14, r19
     674:	21 e0       	ldi	r18, 0x01	; 1
     676:	4f ef       	ldi	r20, 0xFF	; 255
     678:	6d e1       	ldi	r22, 0x1D	; 29
     67a:	8d e1       	ldi	r24, 0x1D	; 29
     67c:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     680:	1f 92       	push	r1
     682:	df 93       	push	r29
     684:	1f 92       	push	r1
     686:	cf 93       	push	r28
     688:	8b e1       	ldi	r24, 0x1B	; 27
     68a:	8f 93       	push	r24
     68c:	48 e0       	ldi	r20, 0x08	; 8
     68e:	e4 2e       	mov	r14, r20
     690:	21 e0       	ldi	r18, 0x01	; 1
     692:	4f ef       	ldi	r20, 0xFF	; 255
     694:	6e e1       	ldi	r22, 0x1E	; 30
     696:	8e e1       	ldi	r24, 0x1E	; 30
     698:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     69c:	7f 92       	push	r7
     69e:	1f 93       	push	r17
     6a0:	1f 92       	push	r1
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6a2:	cf 93       	push	r28
     6a4:	8c e1       	ldi	r24, 0x1C	; 28
     6a6:	8f 93       	push	r24
     6a8:	5d e0       	ldi	r21, 0x0D	; 13
     6aa:	e5 2e       	mov	r14, r21
     6ac:	21 e0       	ldi	r18, 0x01	; 1
     6ae:	4f ef       	ldi	r20, 0xFF	; 255
     6b0:	6f e1       	ldi	r22, 0x1F	; 31
     6b2:	8f e1       	ldi	r24, 0x1F	; 31
     6b4:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6b8:	1f 92       	push	r1
     6ba:	df 93       	push	r29
     6bc:	1f 92       	push	r1
     6be:	cf 93       	push	r28
     6c0:	8d e1       	ldi	r24, 0x1D	; 29
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
     6c2:	8f 93       	push	r24
     6c4:	6c e0       	ldi	r22, 0x0C	; 12
     6c6:	e6 2e       	mov	r14, r22
     6c8:	21 e0       	ldi	r18, 0x01	; 1
     6ca:	4f ef       	ldi	r20, 0xFF	; 255
     6cc:	60 e2       	ldi	r22, 0x20	; 32
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
     6ce:	80 e2       	ldi	r24, 0x20	; 32
     6d0:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6d4:	1f 92       	push	r1
     6d6:	df 93       	push	r29
     6d8:	1f 92       	push	r1
     6da:	cf 93       	push	r28
     6dc:	9f 92       	push	r9
     6de:	7b e0       	ldi	r23, 0x0B	; 11
     6e0:	e7 2e       	mov	r14, r23
     6e2:	21 e0       	ldi	r18, 0x01	; 1
     6e4:	4f ef       	ldi	r20, 0xFF	; 255
     6e6:	61 e2       	ldi	r22, 0x21	; 33
     6e8:	81 e2       	ldi	r24, 0x21	; 33
     6ea:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     6ee:	1f 92       	push	r1
     6f0:	df 93       	push	r29
     6f2:	1f 92       	push	r1
     6f4:	cf 93       	push	r28
				  f5*cos(5*real*w) + b5*sin(5*real*w);
	}
    else 
	{
	  debug = 0x0B;
	  batt_time = h0 + h1*cos(real*w2) + g1*sin(real*w2) +
     6f6:	bf 92       	push	r11
     6f8:	e1 e1       	ldi	r30, 0x11	; 17
     6fa:	ee 2e       	mov	r14, r30
     6fc:	21 e0       	ldi	r18, 0x01	; 1
     6fe:	4f ef       	ldi	r20, 0xFF	; 255
     700:	62 e2       	ldi	r22, 0x22	; 34
     702:	82 e2       	ldi	r24, 0x22	; 34
     704:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
                  h2*cos(2*real*w2) + g2*sin(2*real*w2) +
                  h3*cos(3*real*w2) + g3*sin(3*real*w2) +
                  h4*cos(4*real*w2) + g4*sin(4*real*w2);
	}
  	percent = 100*(1 - batt_time/discharge_max_time);
     708:	8d b7       	in	r24, 0x3d	; 61
     70a:	9e b7       	in	r25, 0x3e	; 62
     70c:	83 96       	adiw	r24, 0x23	; 35
     70e:	0f b6       	in	r0, 0x3f	; 63
     710:	f8 94       	cli
     712:	9e bf       	out	0x3e, r25	; 62
     714:	0f be       	out	0x3f, r0	; 63
     716:	8d bf       	out	0x3d, r24	; 61
     718:	ff 92       	push	r15
     71a:	1f 93       	push	r17
     71c:	1f 92       	push	r1
     71e:	cf 93       	push	r28
     720:	1f 92       	push	r1
     722:	f5 e0       	ldi	r31, 0x05	; 5
     724:	ef 2e       	mov	r14, r31
     726:	21 e0       	ldi	r18, 0x01	; 1
     728:	4f ef       	ldi	r20, 0xFF	; 255
     72a:	63 e2       	ldi	r22, 0x23	; 35
     72c:	83 e2       	ldi	r24, 0x23	; 35
     72e:	0e 94 15 01 	call	0x22a	; 0x22a <set_component>
     732:	0f 90       	pop	r0
     734:	0f 90       	pop	r0
     736:	0f 90       	pop	r0
     738:	0f 90       	pop	r0
     73a:	0f 90       	pop	r0
  }
  else 
  {
    float temp_real = 0;
    if (real < 13.35)
     73c:	df 91       	pop	r29
     73e:	cf 91       	pop	r28
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	ff 90       	pop	r15
     746:	ef 90       	pop	r14
     748:	df 90       	pop	r13
     74a:	cf 90       	pop	r12
     74c:	bf 90       	pop	r11
     74e:	af 90       	pop	r10
	{
	  debug = 0x0C;
     750:	9f 90       	pop	r9
     752:	8f 90       	pop	r8
     754:	7f 90       	pop	r7
	  // voltage is normalized by mean 13.13 and std 0.1754 (real - 13.13)/0.1754
	  temp_real = (real - 13.13)*5.701254;
     756:	6f 90       	pop	r6
     758:	5f 90       	pop	r5
     75a:	08 95       	ret

0000075c <receive_message>:
     75c:	ff 92       	push	r15
     75e:	0f 93       	push	r16
     760:	1f 93       	push	r17
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	f8 2e       	mov	r15, r24
     768:	fb 01       	movw	r30, r22
     76a:	c1 81       	ldd	r28, Z+1	; 0x01
     76c:	90 81       	ld	r25, Z
     76e:	93 30       	cpi	r25, 0x03	; 3
     770:	09 f4       	brne	.+2      	; 0x774 <receive_message+0x18>
     772:	5d c0       	rjmp	.+186    	; 0x82e <receive_message+0xd2>
     774:	30 f4       	brcc	.+12     	; 0x782 <receive_message+0x26>
	  batt_time = p1*pow(temp_real,3) + p2*pow(temp_real,2) + p3*temp_real + p4;
     776:	0c 2f       	mov	r16, r28
     778:	10 e0       	ldi	r17, 0x00	; 0
     77a:	91 30       	cpi	r25, 0x01	; 1
     77c:	29 f1       	breq	.+74     	; 0x7c8 <receive_message+0x6c>
     77e:	a8 f5       	brcc	.+106    	; 0x7ea <receive_message+0x8e>
     780:	0c c0       	rjmp	.+24     	; 0x79a <receive_message+0x3e>
     782:	95 30       	cpi	r25, 0x05	; 5
     784:	09 f4       	brne	.+2      	; 0x788 <receive_message+0x2c>
     786:	58 c0       	rjmp	.+176    	; 0x838 <receive_message+0xdc>
     788:	08 f4       	brcc	.+2      	; 0x78c <receive_message+0x30>
     78a:	53 c0       	rjmp	.+166    	; 0x832 <receive_message+0xd6>
     78c:	96 30       	cpi	r25, 0x06	; 6
     78e:	09 f4       	brne	.+2      	; 0x792 <receive_message+0x36>
     790:	63 c0       	rjmp	.+198    	; 0x858 <receive_message+0xfc>
     792:	97 30       	cpi	r25, 0x07	; 7
     794:	09 f0       	breq	.+2      	; 0x798 <receive_message+0x3c>
     796:	7e c0       	rjmp	.+252    	; 0x894 <receive_message+0x138>
     798:	6e c0       	rjmp	.+220    	; 0x876 <receive_message+0x11a>
     79a:	2c e2       	ldi	r18, 0x2C	; 44
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	30 93 9f 0d 	sts	0x0D9F, r19
     7a2:	20 93 9e 0d 	sts	0x0D9E, r18
     7a6:	8c e1       	ldi	r24, 0x1C	; 28
     7a8:	80 9f       	mul	r24, r16
     7aa:	e0 01       	movw	r28, r0
     7ac:	81 9f       	mul	r24, r17
     7ae:	d0 0d       	add	r29, r0
     7b0:	11 24       	eor	r1, r1
     7b2:	ca 5c       	subi	r28, 0xCA	; 202
     7b4:	dc 4f       	sbci	r29, 0xFC	; 252
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	8f 3f       	cpi	r24, 0xFF	; 255
     7ba:	21 f0       	breq	.+8      	; 0x7c4 <receive_message+0x68>
     7bc:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	8a 83       	std	Y+2, r24	; 0x02
     7c4:	40 e0       	ldi	r20, 0x00	; 0
     7c6:	0f c0       	rjmp	.+30     	; 0x7e6 <receive_message+0x8a>
     7c8:	8c e1       	ldi	r24, 0x1C	; 28
     7ca:	80 9f       	mul	r24, r16
     7cc:	e0 01       	movw	r28, r0
     7ce:	81 9f       	mul	r24, r17
     7d0:	d0 0d       	add	r29, r0
     7d2:	11 24       	eor	r1, r1
     7d4:	ca 5c       	subi	r28, 0xCA	; 202
     7d6:	dc 4f       	sbci	r29, 0xFC	; 252
     7d8:	89 81       	ldd	r24, Y+1	; 0x01
     7da:	8f 3f       	cpi	r24, 0xFF	; 255
     7dc:	19 f0       	breq	.+6      	; 0x7e4 <receive_message+0x88>
     7de:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
     7e2:	1a 82       	std	Y+2, r1	; 0x02
     7e4:	41 e0       	ldi	r20, 0x01	; 1
     7e6:	62 e0       	ldi	r22, 0x02	; 2
     7e8:	57 c0       	rjmp	.+174    	; 0x898 <receive_message+0x13c>
     7ea:	8c e1       	ldi	r24, 0x1C	; 28
     7ec:	80 9f       	mul	r24, r16
     7ee:	e0 01       	movw	r28, r0
     7f0:	81 9f       	mul	r24, r17
     7f2:	d0 0d       	add	r29, r0
     7f4:	11 24       	eor	r1, r1
     7f6:	ca 5c       	subi	r28, 0xCA	; 202
     7f8:	dc 4f       	sbci	r29, 0xFC	; 252
     7fa:	89 81       	ldd	r24, Y+1	; 0x01
     7fc:	8f 3f       	cpi	r24, 0xFF	; 255
     7fe:	19 f0       	breq	.+6      	; 0x806 <receive_message+0xaa>
     800:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
     804:	1a 82       	std	Y+2, r1	; 0x02
     806:	85 e0       	ldi	r24, 0x05	; 5
     808:	8a 95       	dec	r24
     80a:	f1 f7       	brne	.-4      	; 0x808 <receive_message+0xac>
     80c:	8c e1       	ldi	r24, 0x1C	; 28
     80e:	80 9f       	mul	r24, r16
	}
	else 
	{
	  debug = 0x0D;
     810:	e0 01       	movw	r28, r0
     812:	81 9f       	mul	r24, r17
     814:	d0 0d       	add	r29, r0
	  // voltage is normalized by mean 13.7 and std 0.1558 (real - 13.7)/0.1558;
	  temp_real = (real - 13.7)*6.418485;
     816:	11 24       	eor	r1, r1
     818:	ca 5c       	subi	r28, 0xCA	; 202
     81a:	dc 4f       	sbci	r29, 0xFC	; 252
     81c:	89 81       	ldd	r24, Y+1	; 0x01
     81e:	8f 3f       	cpi	r24, 0xFF	; 255
     820:	21 f0       	breq	.+8      	; 0x82a <receive_message+0xce>
     822:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	8a 83       	std	Y+2, r24	; 0x02
     82a:	42 e0       	ldi	r20, 0x02	; 2
     82c:	dc cf       	rjmp	.-72     	; 0x7e6 <receive_message+0x8a>
     82e:	43 e0       	ldi	r20, 0x03	; 3
     830:	da cf       	rjmp	.-76     	; 0x7e6 <receive_message+0x8a>
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	60 e0       	ldi	r22, 0x00	; 0
      batt_time = q1*pow(temp_real,3) + q2*pow(temp_real,2) + q3*temp_real + q4;
     836:	30 c0       	rjmp	.+96     	; 0x898 <receive_message+0x13c>
     838:	8c e1       	ldi	r24, 0x1C	; 28
     83a:	c8 9f       	mul	r28, r24
     83c:	e0 01       	movw	r28, r0
     83e:	11 24       	eor	r1, r1
     840:	ca 5c       	subi	r28, 0xCA	; 202
     842:	dc 4f       	sbci	r29, 0xFC	; 252
     844:	89 81       	ldd	r24, Y+1	; 0x01
     846:	8f 3f       	cpi	r24, 0xFF	; 255
     848:	29 f0       	breq	.+10     	; 0x854 <receive_message+0xf8>
     84a:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
     84e:	81 e0       	ldi	r24, 0x01	; 1
     850:	8a 83       	std	Y+2, r24	; 0x02
     852:	8b 83       	std	Y+3, r24	; 0x03
     854:	45 e0       	ldi	r20, 0x05	; 5
     856:	c7 cf       	rjmp	.-114    	; 0x7e6 <receive_message+0x8a>
     858:	8c e1       	ldi	r24, 0x1C	; 28
     85a:	c8 9f       	mul	r28, r24
     85c:	e0 01       	movw	r28, r0
     85e:	11 24       	eor	r1, r1
     860:	ca 5c       	subi	r28, 0xCA	; 202
     862:	dc 4f       	sbci	r29, 0xFC	; 252
     864:	89 81       	ldd	r24, Y+1	; 0x01
     866:	8f 3f       	cpi	r24, 0xFF	; 255
     868:	f9 f0       	breq	.+62     	; 0x8a8 <receive_message+0x14c>
     86a:	82 81       	ldd	r24, Z+2	; 0x02
     86c:	8e 83       	std	Y+6, r24	; 0x06
     86e:	82 81       	ldd	r24, Z+2	; 0x02
     870:	80 93 7f 0b 	sts	0x0B7F, r24
     874:	19 c0       	rjmp	.+50     	; 0x8a8 <receive_message+0x14c>
     876:	8c e1       	ldi	r24, 0x1C	; 28
     878:	c8 9f       	mul	r28, r24
     87a:	e0 01       	movw	r28, r0
     87c:	11 24       	eor	r1, r1
     87e:	ca 5c       	subi	r28, 0xCA	; 202
     880:	dc 4f       	sbci	r29, 0xFC	; 252
     882:	89 81       	ldd	r24, Y+1	; 0x01
     884:	8f 3f       	cpi	r24, 0xFF	; 255
     886:	81 f0       	breq	.+32     	; 0x8a8 <receive_message+0x14c>
     888:	82 81       	ldd	r24, Z+2	; 0x02
     88a:	8f 87       	std	Y+15, r24	; 0x0f
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	80 93 7a 0b 	sts	0x0B7A, r24
     892:	0a c0       	rjmp	.+20     	; 0x8a8 <receive_message+0x14c>
     894:	40 e0       	ldi	r20, 0x00	; 0
     896:	61 e0       	ldi	r22, 0x01	; 1
     898:	8f 2d       	mov	r24, r15
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	1f 91       	pop	r17
     8a0:	0f 91       	pop	r16
     8a2:	ff 90       	pop	r15
     8a4:	0c 94 61 12 	jmp	0x24c2	; 0x24c2 <transmit_packet>
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	08 95       	ret

000008b4 <StateofCharge>:
     8b4:	cf 93       	push	r28
     8b6:	90 91 6d 09 	lds	r25, 0x096D
     8ba:	9f 3f       	cpi	r25, 0xFF	; 255
     8bc:	09 f4       	brne	.+2      	; 0x8c0 <StateofCharge+0xc>
     8be:	c2 c0       	rjmp	.+388    	; 0xa44 <StateofCharge+0x190>
     8c0:	80 91 57 09 	lds	r24, 0x0957
     8c4:	88 23       	and	r24, r24
     8c6:	09 f4       	brne	.+2      	; 0x8ca <StateofCharge+0x16>
     8c8:	bd c0       	rjmp	.+378    	; 0xa44 <StateofCharge+0x190>
     8ca:	80 91 6e 09 	lds	r24, 0x096E
     8ce:	88 23       	and	r24, r24
     8d0:	21 f0       	breq	.+8      	; 0x8da <StateofCharge+0x26>
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	80 93 ab 0d 	sts	0x0DAB, r24
     8d8:	02 c0       	rjmp	.+4      	; 0x8de <StateofCharge+0x2a>
     8da:	10 92 ab 0d 	sts	0x0DAB, r1
     8de:	80 91 ab 0d 	lds	r24, 0x0DAB
	}
  	percent = 100*(batt_time/charge_max_time);
     8e2:	88 23       	and	r24, r24
     8e4:	19 f0       	breq	.+6      	; 0x8ec <StateofCharge+0x38>
     8e6:	9f 37       	cpi	r25, 0x7F	; 127
     8e8:	20 f0       	brcs	.+8      	; 0x8f2 <StateofCharge+0x3e>
     8ea:	a0 c0       	rjmp	.+320    	; 0xa2c <StateofCharge+0x178>
     8ec:	98 37       	cpi	r25, 0x78	; 120
     8ee:	08 f0       	brcs	.+2      	; 0x8f2 <StateofCharge+0x3e>
     8f0:	9d c0       	rjmp	.+314    	; 0xa2c <StateofCharge+0x178>
     8f2:	95 36       	cpi	r25, 0x65	; 101
     8f4:	08 f4       	brcc	.+2      	; 0x8f8 <StateofCharge+0x44>
     8f6:	95 c0       	rjmp	.+298    	; 0xa22 <StateofCharge+0x16e>
     8f8:	c0 91 06 03 	lds	r28, 0x0306
     8fc:	2c 2f       	mov	r18, r28
     8fe:	2f 5f       	subi	r18, 0xFF	; 255
     900:	20 93 06 03 	sts	0x0306, r18
     904:	88 23       	and	r24, r24
     906:	f1 f1       	breq	.+124    	; 0x984 <StateofCharge+0xd0>
     908:	80 91 83 0d 	lds	r24, 0x0D83
     90c:	9a 36       	cpi	r25, 0x6A	; 106
     90e:	20 f4       	brcc	.+8      	; 0x918 <StateofCharge+0x64>
     910:	82 95       	swap	r24
     912:	86 95       	lsr	r24
     914:	86 95       	lsr	r24
     916:	0b c0       	rjmp	.+22     	; 0x92e <StateofCharge+0x7a>
     918:	29 2f       	mov	r18, r25
     91a:	2a 56       	subi	r18, 0x6A	; 106
     91c:	82 95       	swap	r24
     91e:	86 95       	lsr	r24
     920:	86 95       	lsr	r24
  }
  
  // Percent limiting for periodic function
  if (percent < 1) 
     922:	83 70       	andi	r24, 0x03	; 3
     924:	2a 30       	cpi	r18, 0x0A	; 10
     926:	10 f4       	brcc	.+4      	; 0x92c <StateofCharge+0x78>
     928:	8f 5f       	subi	r24, 0xFF	; 255
     92a:	01 c0       	rjmp	.+2      	; 0x92e <StateofCharge+0x7a>
     92c:	8e 5f       	subi	r24, 0xFE	; 254
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	80 93 9b 0d 	sts	0x0D9B, r24
     934:	e9 2f       	mov	r30, r25
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	e5 56       	subi	r30, 0x65	; 101
     93a:	f1 09       	sbc	r31, r1
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	ee 0f       	add	r30, r30
     942:	ff 1f       	adc	r31, r31
     944:	e8 0f       	add	r30, r24
  { 
  	debug2 = 0xA0;
     946:	f1 1d       	adc	r31, r1
     948:	ee 0f       	add	r30, r30
     94a:	ff 1f       	adc	r31, r31
  	soc = 0; 
     94c:	e4 57       	subi	r30, 0x74	; 116
     94e:	ff 4f       	sbci	r31, 0xFF	; 255
     950:	65 91       	lpm	r22, Z+
  }
  else if (percent > 99) 
     952:	74 91       	lpm	r23, Z
     954:	6b 50       	subi	r22, 0x0B	; 11
     956:	71 09       	sbc	r23, r1
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	0e 94 df 13 	call	0x27be	; 0x27be <__floatunsisf>
     960:	28 eb       	ldi	r18, 0xB8	; 184
     962:	3e e1       	ldi	r19, 0x1E	; 30
     964:	49 e2       	ldi	r20, 0x29	; 41
  { 
  	debug2 = 0xB0;
     966:	51 e4       	ldi	r21, 0x41	; 65
     968:	0e 94 77 13 	call	0x26ee	; 0x26ee <__divsf3>
  	soc = 255;
     96c:	60 93 2d 07 	sts	0x072D, r22
     970:	70 93 2e 07 	sts	0x072E, r23
  }
  else { 
  	debug2 = 0xC0;
     974:	80 93 2f 07 	sts	0x072F, r24
     978:	90 93 30 07 	sts	0x0730, r25
  	soc = (char)floor((int)(percent)); 
     97c:	c9 5f       	subi	r28, 0xF9	; 249
     97e:	c0 93 06 03 	sts	0x0306, r28
     982:	60 c0       	rjmp	.+192    	; 0xa44 <StateofCharge+0x190>
     984:	9a 36       	cpi	r25, 0x6A	; 106
     986:	30 f4       	brcc	.+12     	; 0x994 <StateofCharge+0xe0>
     988:	80 91 83 0d 	lds	r24, 0x0D83
     98c:	82 95       	swap	r24
     98e:	86 95       	lsr	r24
     990:	86 95       	lsr	r24
     992:	17 c0       	rjmp	.+46     	; 0x9c2 <StateofCharge+0x10e>
     994:	89 2f       	mov	r24, r25
     996:	8a 56       	subi	r24, 0x6A	; 106
     998:	8a 30       	cpi	r24, 0x0A	; 10
  }
}
     99a:	40 f4       	brcc	.+16     	; 0x9ac <StateofCharge+0xf8>
     99c:	80 91 83 0d 	lds	r24, 0x0D83
     9a0:	82 95       	swap	r24
     9a2:	86 95       	lsr	r24
     9a4:	86 95       	lsr	r24
     9a6:	83 70       	andi	r24, 0x03	; 3
     9a8:	8f 5f       	subi	r24, 0xFF	; 255
     9aa:	0b c0       	rjmp	.+22     	; 0x9c2 <StateofCharge+0x10e>
     9ac:	89 2f       	mov	r24, r25
     9ae:	84 57       	subi	r24, 0x74	; 116
     9b0:	83 30       	cpi	r24, 0x03	; 3
     9b2:	48 f4       	brcc	.+18     	; 0x9c6 <StateofCharge+0x112>
     9b4:	80 91 83 0d 	lds	r24, 0x0D83
     9b8:	82 95       	swap	r24
     9ba:	86 95       	lsr	r24
     9bc:	86 95       	lsr	r24
     9be:	83 70       	andi	r24, 0x03	; 3
     9c0:	8e 5f       	subi	r24, 0xFE	; 254
     9c2:	83 70       	andi	r24, 0x03	; 3
				percent = (charge20Pc[(batt1_voltage - 0x65)*4 + ltOffset] - 11) / (10.57);
				antioptimizer+=6;
				
			}else{
				
				ltOffset =  (batt1_voltage <= 0x69) ? (batt1_voltageLow >> 6) :
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <StateofCharge+0x114>
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	80 93 9b 0d 	sts	0x0D9B, r24
							((batt1_voltage >= 0x6A) && (batt1_voltage <= 0x73)) ? (((batt1_voltageLow >> 6) + 1) % 0x04) :
							((batt1_voltage >= 0x74) && (batt1_voltage <= 0x76)) ? (((batt1_voltageLow >> 6) + 2) % 0x04) :
							0x00;
				
				percent = 100 - ((discharge20Pc[(0x77 - batt1_voltage)*4 - ltOffset]) ) / (10.07);
     9cc:	e7 e7       	ldi	r30, 0x77	; 119
     9ce:	f0 e0       	ldi	r31, 0x00	; 0
     9d0:	e9 1b       	sub	r30, r25
     9d2:	f1 09       	sbc	r31, r1
     9d4:	ee 0f       	add	r30, r30
     9d6:	ff 1f       	adc	r31, r31
     9d8:	ee 0f       	add	r30, r30
     9da:	ff 1f       	adc	r31, r31
     9dc:	e8 1b       	sub	r30, r24
     9de:	f1 09       	sbc	r31, r1
     9e0:	ee 0f       	add	r30, r30
     9e2:	ff 1f       	adc	r31, r31
     9e4:	e8 59       	subi	r30, 0x98	; 152
     9e6:	fe 4f       	sbci	r31, 0xFE	; 254
     9e8:	65 91       	lpm	r22, Z+
     9ea:	74 91       	lpm	r23, Z
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	90 e0       	ldi	r25, 0x00	; 0
     9f0:	0e 94 df 13 	call	0x27be	; 0x27be <__floatunsisf>
     9f4:	28 eb       	ldi	r18, 0xB8	; 184
     9f6:	3e e1       	ldi	r19, 0x1E	; 30
     9f8:	41 e2       	ldi	r20, 0x21	; 33
     9fa:	51 e4       	ldi	r21, 0x41	; 65
     9fc:	0e 94 77 13 	call	0x26ee	; 0x26ee <__divsf3>
     a00:	9b 01       	movw	r18, r22
     a02:	ac 01       	movw	r20, r24
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	88 ec       	ldi	r24, 0xC8	; 200
     a0a:	92 e4       	ldi	r25, 0x42	; 66
     a0c:	0e 94 0e 13 	call	0x261c	; 0x261c <__subsf3>
     a10:	60 93 2d 07 	sts	0x072D, r22
     a14:	70 93 2e 07 	sts	0x072E, r23
     a18:	80 93 2f 07 	sts	0x072F, r24
     a1c:	90 93 30 07 	sts	0x0730, r25
     a20:	11 c0       	rjmp	.+34     	; 0xa44 <StateofCharge+0x190>
			}
		}else if(batt1_voltage <= 0x64){
			percent = -1;
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	90 e0       	ldi	r25, 0x00	; 0
     a26:	a0 e8       	ldi	r26, 0x80	; 128
     a28:	bf eb       	ldi	r27, 0xBF	; 191
     a2a:	04 c0       	rjmp	.+8      	; 0xa34 <StateofCharge+0x180>
		}else if(  ((batt1_voltage > 0x7E)&&isCharging) || ((!isCharging)&&(batt1_voltage > 0x77)) ){
			percent = 108;
     a2c:	80 e0       	ldi	r24, 0x00	; 0
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	a8 ed       	ldi	r26, 0xD8	; 216
     a32:	b2 e4       	ldi	r27, 0x42	; 66
     a34:	80 93 2d 07 	sts	0x072D, r24
     a38:	90 93 2e 07 	sts	0x072E, r25
     a3c:	a0 93 2f 07 	sts	0x072F, r26
     a40:	b0 93 30 07 	sts	0x0730, r27
		}
	}
	
	if(solar1_current < 0xFF && solar1_current > 0x00){
     a44:	80 91 6e 09 	lds	r24, 0x096E
     a48:	81 50       	subi	r24, 0x01	; 1
     a4a:	8e 3f       	cpi	r24, 0xFE	; 254
     a4c:	28 f4       	brcc	.+10     	; 0xa58 <StateofCharge+0x1a4>
		antioptimizer++;
     a4e:	80 91 06 03 	lds	r24, 0x0306
     a52:	8f 5f       	subi	r24, 0xFF	; 255
     a54:	80 93 06 03 	sts	0x0306, r24
	}
	
	
}
     a58:	cf 91       	pop	r28
     a5a:	08 95       	ret

00000a5c <assign_charge_fit>:



/* Assigns values to the Fourier coefficients of the charge approximation */
void assign_charge_fit( void ) {
  charge_max_time = 10188;
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	90 e3       	ldi	r25, 0x30	; 48
     a60:	af e1       	ldi	r26, 0x1F	; 31
     a62:	b6 e4       	ldi	r27, 0x46	; 70
     a64:	80 93 74 09 	sts	0x0974, r24
     a68:	90 93 75 09 	sts	0x0975, r25
     a6c:	a0 93 76 09 	sts	0x0976, r26
     a70:	b0 93 77 09 	sts	0x0977, r27
  // x is normalized by mean 13.13 and std 0.1754
  p1 = 18.57;
     a74:	8c e5       	ldi	r24, 0x5C	; 92
     a76:	9f e8       	ldi	r25, 0x8F	; 143
     a78:	a4 e9       	ldi	r26, 0x94	; 148
     a7a:	b1 e4       	ldi	r27, 0x41	; 65
     a7c:	80 93 46 09 	sts	0x0946, r24
     a80:	90 93 47 09 	sts	0x0947, r25
     a84:	a0 93 48 09 	sts	0x0948, r26
     a88:	b0 93 49 09 	sts	0x0949, r27
  p2 = 184.8;
     a8c:	8d ec       	ldi	r24, 0xCD	; 205
     a8e:	9c ec       	ldi	r25, 0xCC	; 204
     a90:	a8 e3       	ldi	r26, 0x38	; 56
     a92:	b3 e4       	ldi	r27, 0x43	; 67
     a94:	80 93 23 03 	sts	0x0323, r24
     a98:	90 93 24 03 	sts	0x0324, r25
     a9c:	a0 93 25 03 	sts	0x0325, r26
     aa0:	b0 93 26 03 	sts	0x0326, r27
  p3 = 663.6;
     aa4:	86 e6       	ldi	r24, 0x66	; 102
     aa6:	96 ee       	ldi	r25, 0xE6	; 230
     aa8:	a5 e2       	ldi	r26, 0x25	; 37
     aaa:	b4 e4       	ldi	r27, 0x44	; 68
     aac:	80 93 8f 0d 	sts	0x0D8F, r24
     ab0:	90 93 90 0d 	sts	0x0D90, r25
     ab4:	a0 93 91 0d 	sts	0x0D91, r26
     ab8:	b0 93 92 0d 	sts	0x0D92, r27
  p4 = 838.6;
     abc:	86 e6       	ldi	r24, 0x66	; 102
     abe:	96 ea       	ldi	r25, 0xA6	; 166
     ac0:	a1 e5       	ldi	r26, 0x51	; 81
     ac2:	b4 e4       	ldi	r27, 0x44	; 68
     ac4:	80 93 ae 0d 	sts	0x0DAE, r24
     ac8:	90 93 af 0d 	sts	0x0DAF, r25
     acc:	a0 93 b0 0d 	sts	0x0DB0, r26
     ad0:	b0 93 b1 0d 	sts	0x0DB1, r27
  //where x is normalized by mean 13.7 and std 0.1558
  q1 = 78.49;
     ad4:	81 ee       	ldi	r24, 0xE1	; 225
     ad6:	9a ef       	ldi	r25, 0xFA	; 250
     ad8:	ac e9       	ldi	r26, 0x9C	; 156
     ada:	b2 e4       	ldi	r27, 0x42	; 66
     adc:	80 93 68 09 	sts	0x0968, r24
     ae0:	90 93 69 09 	sts	0x0969, r25
     ae4:	a0 93 6a 09 	sts	0x096A, r26
     ae8:	b0 93 6b 09 	sts	0x096B, r27
  q2 = 543.1;
     aec:	86 e6       	ldi	r24, 0x66	; 102
     aee:	96 ec       	ldi	r25, 0xC6	; 198
     af0:	a7 e0       	ldi	r26, 0x07	; 7
     af2:	b4 e4       	ldi	r27, 0x44	; 68
     af4:	80 93 26 07 	sts	0x0726, r24
     af8:	90 93 27 07 	sts	0x0727, r25
     afc:	a0 93 28 07 	sts	0x0728, r26
     b00:	b0 93 29 07 	sts	0x0729, r27
  q3 = 2427;
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	90 eb       	ldi	r25, 0xB0	; 176
     b08:	a7 e1       	ldi	r26, 0x17	; 23
     b0a:	b5 e4       	ldi	r27, 0x45	; 69
     b0c:	80 93 64 09 	sts	0x0964, r24
     b10:	90 93 65 09 	sts	0x0965, r25
     b14:	a0 93 66 09 	sts	0x0966, r26
     b18:	b0 93 67 09 	sts	0x0967, r27
  q4 = 5587;
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	98 e9       	ldi	r25, 0x98	; 152
     b20:	ae ea       	ldi	r26, 0xAE	; 174
     b22:	b5 e4       	ldi	r27, 0x45	; 69
     b24:	80 93 a3 0d 	sts	0x0DA3, r24
     b28:	90 93 a4 0d 	sts	0x0DA4, r25
     b2c:	a0 93 a5 0d 	sts	0x0DA5, r26
     b30:	b0 93 a6 0d 	sts	0x0DA6, r27
     b34:	08 95       	ret

00000b36 <assign_discharge_fit>:
}

/* Assigns values to the Fourier coefficients of the discharge approximation */

void assign_discharge_fit( void ) {
  discharge_max_time = 17547;
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	96 e1       	ldi	r25, 0x16	; 22
     b3a:	a9 e8       	ldi	r26, 0x89	; 137
     b3c:	b6 e4       	ldi	r27, 0x46	; 70
     b3e:	80 93 3b 07 	sts	0x073B, r24
     b42:	90 93 3c 07 	sts	0x073C, r25
     b46:	a0 93 3d 07 	sts	0x073D, r26
     b4a:	b0 93 3e 07 	sts	0x073E, r27
  f0 = -1.543291233254410E4;
     b4e:	88 eb       	ldi	r24, 0xB8	; 184
     b50:	93 ec       	ldi	r25, 0xC3	; 195
     b52:	90 93 8c 0d 	sts	0x0D8C, r25
     b56:	80 93 8b 0d 	sts	0x0D8B, r24
  f1 = -1.819810644993805E4;
     b5a:	8a ee       	ldi	r24, 0xEA	; 234
     b5c:	98 eb       	ldi	r25, 0xB8	; 184
     b5e:	90 93 96 0d 	sts	0x0D96, r25
     b62:	80 93 95 0d 	sts	0x0D95, r24
  b1 = -2.548949173344369E4;
     b66:	8f e6       	ldi	r24, 0x6F	; 111
     b68:	9c e9       	ldi	r25, 0x9C	; 156
     b6a:	90 93 2b 07 	sts	0x072B, r25
     b6e:	80 93 2a 07 	sts	0x072A, r24
  f2 = 1.141365113433748E4;
     b72:	85 e9       	ldi	r24, 0x95	; 149
     b74:	9c e2       	ldi	r25, 0x2C	; 44
     b76:	90 93 5d 09 	sts	0x095D, r25
     b7a:	80 93 5c 09 	sts	0x095C, r24
  b2 = -2.190399298389397E4;
     b7e:	81 e7       	ldi	r24, 0x71	; 113
     b80:	9a ea       	ldi	r25, 0xAA	; 170
     b82:	90 93 21 03 	sts	0x0321, r25
     b86:	80 93 20 03 	sts	0x0320, r24
  f3 = 1.453849538420288E4;
     b8a:	8a ec       	ldi	r24, 0xCA	; 202
     b8c:	98 e3       	ldi	r25, 0x38	; 56
     b8e:	90 93 51 09 	sts	0x0951, r25
     b92:	80 93 50 09 	sts	0x0950, r24
  b3 = 7.700208204268025E2;
     b96:	82 e0       	ldi	r24, 0x02	; 2
     b98:	93 e0       	ldi	r25, 0x03	; 3
     b9a:	90 93 8e 0d 	sts	0x0D8E, r25
     b9e:	80 93 8d 0d 	sts	0x0D8D, r24
  f4 = 1.965482651710955E3;
     ba2:	8d ea       	ldi	r24, 0xAD	; 173
     ba4:	97 e0       	ldi	r25, 0x07	; 7
     ba6:	90 93 94 0d 	sts	0x0D94, r25
     baa:	80 93 93 0d 	sts	0x0D93, r24
  b4 = 5.504490550919407E3;
     bae:	80 e8       	ldi	r24, 0x80	; 128
     bb0:	95 e1       	ldi	r25, 0x15	; 21
     bb2:	90 93 45 07 	sts	0x0745, r25
     bb6:	80 93 44 07 	sts	0x0744, r24
  f5 = -9.466488439471518E2;
     bba:	8e e4       	ldi	r24, 0x4E	; 78
     bbc:	9c ef       	ldi	r25, 0xFC	; 252
     bbe:	90 93 43 07 	sts	0x0743, r25
     bc2:	80 93 42 07 	sts	0x0742, r24
  b5 = 8.270458368650347E2;
     bc6:	8b e3       	ldi	r24, 0x3B	; 59
     bc8:	93 e0       	ldi	r25, 0x03	; 3
     bca:	90 93 8a 0d 	sts	0x0D8A, r25
     bce:	80 93 89 0d 	sts	0x0D89, r24
  w = 2.725333178515558;
     bd2:	8c ed       	ldi	r24, 0xDC	; 220
     bd4:	9b e6       	ldi	r25, 0x6B	; 107
     bd6:	ae e2       	ldi	r26, 0x2E	; 46
     bd8:	b0 e4       	ldi	r27, 0x40	; 64
     bda:	80 93 31 07 	sts	0x0731, r24
     bde:	90 93 32 07 	sts	0x0732, r25
     be2:	a0 93 33 07 	sts	0x0733, r26
     be6:	b0 93 34 07 	sts	0x0734, r27
  
  h0 = 2.979485572689352E8;
     bea:	80 e8       	ldi	r24, 0x80	; 128
     bec:	95 e5       	ldi	r25, 0x55	; 85
     bee:	a2 ec       	ldi	r26, 0xC2	; 194
     bf0:	b1 e1       	ldi	r27, 0x11	; 17
     bf2:	80 93 58 09 	sts	0x0958, r24
     bf6:	90 93 59 09 	sts	0x0959, r25
     bfa:	a0 93 5a 09 	sts	0x095A, r26
     bfe:	b0 93 5b 09 	sts	0x095B, r27
  h1 = 2.088787459098652E8;
     c02:	80 ea       	ldi	r24, 0xA0	; 160
     c04:	9c e3       	ldi	r25, 0x3C	; 60
     c06:	a3 e7       	ldi	r26, 0x73	; 115
     c08:	bc e0       	ldi	r27, 0x0C	; 12
     c0a:	80 93 2b 03 	sts	0x032B, r24
     c0e:	90 93 2c 03 	sts	0x032C, r25
     c12:	a0 93 2d 03 	sts	0x032D, r26
     c16:	b0 93 2e 03 	sts	0x032E, r27
  g1 = 4.359717315569648E8;
     c1a:	80 ea       	ldi	r24, 0xA0	; 160
     c1c:	96 e6       	ldi	r25, 0x66	; 102
     c1e:	ac ef       	ldi	r26, 0xFC	; 252
     c20:	b9 e1       	ldi	r27, 0x19	; 25
     c22:	80 93 30 03 	sts	0x0330, r24
     c26:	90 93 31 03 	sts	0x0331, r25
     c2a:	a0 93 32 03 	sts	0x0332, r26
     c2e:	b0 93 33 03 	sts	0x0333, r27
  h2 =  -1.569778955752849E8;
     c32:	80 e2       	ldi	r24, 0x20	; 32
     c34:	95 eb       	ldi	r25, 0xB5	; 181
     c36:	a4 ea       	ldi	r26, 0xA4	; 164
     c38:	b6 ef       	ldi	r27, 0xF6	; 246
     c3a:	80 93 53 09 	sts	0x0953, r24
     c3e:	90 93 54 09 	sts	0x0954, r25
     c42:	a0 93 55 09 	sts	0x0955, r26
     c46:	b0 93 56 09 	sts	0x0956, r27
  g2 =  1.969854815603661E8;
     c4a:	80 e9       	ldi	r24, 0x90	; 144
     c4c:	92 ec       	ldi	r25, 0xC2	; 194
     c4e:	ad eb       	ldi	r26, 0xBD	; 189
     c50:	bb e0       	ldi	r27, 0x0B	; 11
     c52:	80 93 4b 09 	sts	0x094B, r24
     c56:	90 93 4c 09 	sts	0x094C, r25
     c5a:	a0 93 4d 09 	sts	0x094D, r26
     c5e:	b0 93 4e 09 	sts	0x094E, r27
  h3 =  -7.513816845838763E7;
     c62:	88 e8       	ldi	r24, 0x88	; 136
     c64:	9b e7       	ldi	r25, 0x7B	; 123
     c66:	a5 e8       	ldi	r26, 0x85	; 133
     c68:	bb ef       	ldi	r27, 0xFB	; 251
     c6a:	80 93 97 0d 	sts	0x0D97, r24
     c6e:	90 93 98 0d 	sts	0x0D98, r25
     c72:	a0 93 99 0d 	sts	0x0D99, r26
     c76:	b0 93 9a 0d 	sts	0x0D9A, r27
  g3 =  -1.633385950799686E7;
     c7a:	8c ed       	ldi	r24, 0xDC	; 220
     c7c:	93 ec       	ldi	r25, 0xC3	; 195
     c7e:	a6 e0       	ldi	r26, 0x06	; 6
     c80:	bf ef       	ldi	r27, 0xFF	; 255
     c82:	80 93 1c 03 	sts	0x031C, r24
     c86:	90 93 1d 03 	sts	0x031D, r25
     c8a:	a0 93 1e 03 	sts	0x031E, r26
     c8e:	b0 93 1f 03 	sts	0x031F, r27
  h4 =   -2.642581886559125E6;
     c92:	8a e6       	ldi	r24, 0x6A	; 106
     c94:	9d ea       	ldi	r25, 0xAD	; 173
     c96:	a7 ed       	ldi	r26, 0xD7	; 215
     c98:	bf ef       	ldi	r27, 0xFF	; 255
     c9a:	80 93 7f 0d 	sts	0x0D7F, r24
     c9e:	90 93 80 0d 	sts	0x0D80, r25
     ca2:	a0 93 81 0d 	sts	0x0D81, r26
     ca6:	b0 93 82 0d 	sts	0x0D82, r27
  g4 =   -1.016608352073227E7;
     caa:	8c eb       	ldi	r24, 0xBC	; 188
     cac:	90 ee       	ldi	r25, 0xE0	; 224
     cae:	a4 e6       	ldi	r26, 0x64	; 100
     cb0:	bf ef       	ldi	r27, 0xFF	; 255
     cb2:	80 93 07 03 	sts	0x0307, r24
     cb6:	90 93 08 03 	sts	0x0308, r25
     cba:	a0 93 09 03 	sts	0x0309, r26
     cbe:	b0 93 0a 03 	sts	0x030A, r27
  w2 =  0.364797662747743;
     cc2:	82 ec       	ldi	r24, 0xC2	; 194
     cc4:	96 ec       	ldi	r25, 0xC6	; 198
     cc6:	aa eb       	ldi	r26, 0xBA	; 186
     cc8:	be e3       	ldi	r27, 0x3E	; 62
     cca:	80 93 7b 0b 	sts	0x0B7B, r24
     cce:	90 93 7c 0b 	sts	0x0B7C, r25
     cd2:	a0 93 7d 0b 	sts	0x0B7D, r26
     cd6:	b0 93 7e 0b 	sts	0x0B7E, r27
     cda:	08 95       	ret

00000cdc <initialize>:
  set_component( svit_index++,  SOLAR_12    ,  SW_NULL,     SW_ON,          MUX0,       17,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        31,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX_NULL,       0     );  
  set_component( svit_index++,  POWER_BOARD ,  SW_NULL,     SW_ON,          MUX0,       5 ,      V_THRESHOLD_VALUE,   V_UNDER_VALUE,      MUX0,        0 ,    I_THRESHOLD_VALUE, I_UNDER_VALUE,   MUX2    ,       6     );  // Fake Data
}

void initialize( void )
{
     cdc:	ef 92       	push	r14
     cde:	ff 92       	push	r15
     ce0:	0f 93       	push	r16
     ce2:	1f 93       	push	r17
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
   // pin initialization
  DDRA  = 0b11111111;
     ce8:	1f ef       	ldi	r17, 0xFF	; 255
     cea:	1a bb       	out	0x1a, r17	; 26
  PORTA = 0b00000111;
     cec:	87 e0       	ldi	r24, 0x07	; 7
     cee:	8b bb       	out	0x1b, r24	; 27

  DDRB  = 0b11111111;
     cf0:	17 bb       	out	0x17, r17	; 23
  PORTB = 0b11100000;
     cf2:	80 ee       	ldi	r24, 0xE0	; 224
     cf4:	88 bb       	out	0x18, r24	; 24

  DDRC  = 0b11111111;
     cf6:	14 bb       	out	0x14, r17	; 20
  PORTC = 0b11111111;
     cf8:	15 bb       	out	0x15, r17	; 21

  DDRD  = 0b11111011;
     cfa:	8b ef       	ldi	r24, 0xFB	; 251
     cfc:	81 bb       	out	0x11, r24	; 17
  PORTD = 0b11110000;
     cfe:	80 ef       	ldi	r24, 0xF0	; 240
     d00:	82 bb       	out	0x12, r24	; 18

  DDRE  = 0b11111110;
     d02:	9e ef       	ldi	r25, 0xFE	; 254
     d04:	92 b9       	out	0x02, r25	; 2
  PORTE = 0b00000000;
     d06:	13 b8       	out	0x03, r1	; 3

  DDRF  = 0b11110000;
     d08:	80 93 61 00 	sts	0x0061, r24
  //0b11111111;	//testing
  PORTF = 0b00000000;
     d0c:	10 92 62 00 	sts	0x0062, r1

  DDRG  = 0b00011111;
     d10:	8f e1       	ldi	r24, 0x1F	; 31
     d12:	80 93 64 00 	sts	0x0064, r24
  PORTG = 0b00000100;
     d16:	04 e0       	ldi	r16, 0x04	; 4
     d18:	00 93 65 00 	sts	0x0065, r16
  // compare value = 124
  // compare match interrupt freq = (14.7456 MHz / 1024 / 100) = 144 Hz
  // use timer0_counter to get 144 / 144 = 1 Hz

  // enable clear on match interrupt
  TIMSK |= ( 1 << OCIE0 );
     d1c:	87 b7       	in	r24, 0x37	; 55
     d1e:	82 60       	ori	r24, 0x02	; 2
     d20:	87 bf       	out	0x37, r24	; 55
  OCR0 = 71;
     d22:	87 e4       	ldi	r24, 0x47	; 71
     d24:	81 bf       	out	0x31, r24	; 49

  // enable clear on match mode, set prescalar to 1024
  TCCR0 |= ( 1 << WGM01 ) | ( 1 << CS02 ) | ( 1 << CS01 ) | ( 1 << CS00 );
     d26:	83 b7       	in	r24, 0x33	; 51
     d28:	8f 60       	ori	r24, 0x0F	; 15
     d2a:	83 bf       	out	0x33, r24	; 51

  timer0_counter[0] = 99;
     d2c:	83 e6       	ldi	r24, 0x63	; 99
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	90 93 77 0b 	sts	0x0B77, r25
     d34:	80 93 76 0b 	sts	0x0B76, r24
  timer0_counter[1] = 199;
     d38:	87 ec       	ldi	r24, 0xC7	; 199
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	90 93 79 0b 	sts	0x0B79, r25
     d40:	80 93 78 0b 	sts	0x0B78, r24
  
  beyondDelay = 0;
     d44:	10 92 a1 0d 	sts	0x0DA1, r1
  
  //---------------------------------------------------------------------  
  // timer 1
  //---------------------------------------------------------------------
    // enable clear on match interrupt
	TCCR1B |= ( 1 << CS11 );
     d48:	8e b5       	in	r24, 0x2e	; 46
     d4a:	82 60       	ori	r24, 0x02	; 2
     d4c:	8e bd       	out	0x2e, r24	; 46
	TCNT1 = 0;
     d4e:	1d bc       	out	0x2d, r1	; 45
     d50:	1c bc       	out	0x2c, r1	; 44
    TIMSK |= ( 1 << TOIE1 );
     d52:	87 b7       	in	r24, 0x37	; 55
     d54:	84 60       	ori	r24, 0x04	; 4
     d56:	87 bf       	out	0x37, r24	; 55
  //TCCR1B |= ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 1 << CS11 ) | ( 1 << CS10 );
  
  // Explicit Default Defs
  // TCCR1A |= 0;

  timer1_counter[0] = 54000;	//CYCLE_COUNTER   = 900 for 2 seconds interrupt handler = 1800 secs (30 minutes)
     d58:	80 ef       	ldi	r24, 0xF0	; 240
     d5a:	92 ed       	ldi	r25, 0xD2	; 210
     d5c:	90 93 9d 0d 	sts	0x0D9D, r25
     d60:	80 93 9c 0d 	sts	0x0D9C, r24
  timer1_counter[1] = CYCLE_COUNTER_2;	//CYCLE_COUNTER_2 = 300 for 2 seconds interrupt handler = 600 secs  (10 minutes)
     d64:	8c e2       	ldi	r24, 0x2C	; 44
     d66:	91 e0       	ldi	r25, 0x01	; 1
     d68:	90 93 9f 0d 	sts	0x0D9F, r25
     d6c:	80 93 9e 0d 	sts	0x0D9E, r24
  //---------------------------------------------------------------------  
  // End of timer 1 Setup
  //--------------------------------------------------------------------- 
  
  // communication
  uart_init();
     d70:	0e 94 be 0b 	call	0x177c	; 0x177c <uart_init>

  // for use in debugging
  // stdout = stdin = stderr = &uart_str;

  tel_packet_size[0] = 0;
     d74:	10 92 28 03 	sts	0x0328, r1
     d78:	10 92 27 03 	sts	0x0327, r1
  tel_packet_size[1] = 0;
     d7c:	10 92 2a 03 	sts	0x032A, r1
     d80:	10 92 29 03 	sts	0x0329, r1
  tel_packet_index[0] = 0;
     d84:	10 92 3f 07 	sts	0x073F, r1
  tel_packet_index[1] = 0;
     d88:	10 92 40 07 	sts	0x0740, r1
  uart_vcp_buff[0] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d8c:	8a e0       	ldi	r24, 0x0A	; 10
     d8e:	90 e0       	ldi	r25, 0x00	; 0
     d90:	0e 94 bd 14 	call	0x297a	; 0x297a <malloc>
     d94:	7c 01       	movw	r14, r24
     d96:	e7 ea       	ldi	r30, 0xA7	; 167
     d98:	fd e0       	ldi	r31, 0x0D	; 13
     d9a:	80 83       	st	Z, r24
     d9c:	f1 82       	std	Z+1, r15	; 0x01
  uart_vcp_buff[1] = (vcp_ptrbuffer*)malloc( sizeof( vcp_ptrbuffer ) );
     d9e:	8a e0       	ldi	r24, 0x0A	; 10
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0e 94 bd 14 	call	0x297a	; 0x297a <malloc>
     da6:	c9 ea       	ldi	r28, 0xA9	; 169
     da8:	dd e0       	ldi	r29, 0x0D	; 13
     daa:	88 83       	st	Y, r24
     dac:	99 83       	std	Y+1, r25	; 0x01
  vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
     dae:	4f ef       	ldi	r20, 0xFF	; 255
     db0:	50 e0       	ldi	r21, 0x00	; 0
     db2:	61 e8       	ldi	r22, 0x81	; 129
     db4:	7b e0       	ldi	r23, 0x0B	; 11
     db6:	c7 01       	movw	r24, r14
     db8:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <vcpptr_init>
  vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
     dbc:	4f ef       	ldi	r20, 0xFF	; 255
     dbe:	50 e0       	ldi	r21, 0x00	; 0
     dc0:	60 e8       	ldi	r22, 0x80	; 128
     dc2:	7c e0       	ldi	r23, 0x0C	; 12
     dc4:	88 81       	ld	r24, Y
     dc6:	99 81       	ldd	r25, Y+1	; 0x01
     dc8:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <vcpptr_init>

  rx_flag[0] = 0;
     dcc:	10 92 ac 0d 	sts	0x0DAC, r1
  rx_flag[1] = 0;
     dd0:	10 92 ad 0d 	sts	0x0DAD, r1

  // svit
  initialize_svit();
     dd4:	0e 94 44 01 	call	0x288	; 0x288 <initialize_svit>

  // rev up those interrupts
  sei();
     dd8:	78 94       	sei

  //ADC conversions
  adc_flag = 1;
     dda:	c1 e0       	ldi	r28, 0x01	; 1
     ddc:	c0 93 45 09 	sts	0x0945, r28
	adc_component = 0;
     de0:	10 92 35 03 	sts	0x0335, r1
	adc_sensor_type = ADC_INIT;//get default case on first interation as to not enter switch
     de4:	00 93 52 09 	sts	0x0952, r16
  ADC_high = 0;
     de8:	10 92 63 09 	sts	0x0963, r1

  V_upper_val_change = 0;
     dec:	10 92 7f 0b 	sts	0x0B7F, r1
  I_upper_val_change = 0;
     df0:	10 92 7a 0b 	sts	0x0B7A, r1

  //---------------------------------------------------------------------  
  // SOC Initializations
  //--------------------------------------------------------------------- 
  // and shunt and safe transmit flags
  safe_mode = 0;
     df4:	10 92 4f 09 	sts	0x094F, r1
  transmit_safe = 0;
     df8:	10 92 4a 09 	sts	0x094A, r1
  transmit_shunt = 0;
     dfc:	10 92 88 0d 	sts	0x0D88, r1
  been_to_safe = 0;
     e00:	10 92 2f 03 	sts	0x032F, r1
  been_to_shunt = 0;
     e04:	10 92 6f 09 	sts	0x096F, r1
  assign_charge_fit();
     e08:	0e 94 2e 05 	call	0xa5c	; 0xa5c <assign_charge_fit>
  assign_discharge_fit();
     e0c:	0e 94 9b 05 	call	0xb36	; 0xb36 <assign_discharge_fit>
  
  // First get battery voltage so that the SoC can
  // accurately determine whether batteries are charging or discharging
  batt1_voltage = 0xff;
     e10:	10 93 6d 09 	sts	0x096D, r17
  batt2_voltage = 0xff;
     e14:	10 93 80 0b 	sts	0x0B80, r17
  charging = 0xff;
     e18:	10 93 36 07 	sts	0x0736, r17
  chargeforward = 0;
     e1c:	10 92 a2 0d 	sts	0x0DA2, r1
  chargebackward = 0;
     e20:	10 92 34 03 	sts	0x0334, r1
  debug = 0;
     e24:	10 92 35 07 	sts	0x0735, r1
  debug2 = 0;
     e28:	10 92 41 07 	sts	0x0741, r1
  percent = 0;
     e2c:	10 92 2d 07 	sts	0x072D, r1
     e30:	10 92 2e 07 	sts	0x072E, r1
     e34:	10 92 2f 07 	sts	0x072F, r1
     e38:	10 92 30 07 	sts	0x0730, r1
  soc = 0;
     e3c:	10 92 b0 0f 	sts	0x0FB0, r1
  high = 0;
     e40:	10 92 5e 09 	sts	0x095E, r1
  low = 0;
     e44:	10 92 6c 09 	sts	0x096C, r1
  limit_check_overriden = 0; // Initially limit checking is NOT OVERRIDEN
     e48:	10 92 2c 07 	sts	0x072C, r1
  isCharging = 0;
     e4c:	10 92 ab 0d 	sts	0x0DAB, r1
  hasCheckedCurr = 0;
     e50:	10 92 57 09 	sts	0x0957, r1
  //--------------------------------------------------------------------- 

  //---------------------------------------------------------------------  
  // Timer Initializations
  //---------------------------------------------------------------------
  cdh_heartbeat_flag = 0;	//Default: do not have flag to restart components on
     e54:	10 92 22 03 	sts	0x0322, r1
  rad_torq_flag = 1;		//Indicates need to delay radio/torquer on signals later
     e58:	c0 93 0b 03 	sts	0x030B, r28
  SVIT_t *component; 	// Initialize Radios to be OFF
  component = &svit[components[RADIO_1]];
     e5c:	a0 91 17 03 	lds	r26, 0x0317
     e60:	cc e1       	ldi	r28, 0x1C	; 28
     e62:	ca 9f       	mul	r28, r26
     e64:	d0 01       	movw	r26, r0
     e66:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e68:	aa 5c       	subi	r26, 0xCA	; 202
     e6a:	bc 4f       	sbci	r27, 0xFC	; 252
     e6c:	11 96       	adiw	r26, 0x01	; 1
     e6e:	8c 91       	ld	r24, X
     e70:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  component = &svit[components[RADIO_2]];
     e74:	e0 91 18 03 	lds	r30, 0x0318
     e78:	ce 9f       	mul	r28, r30
     e7a:	f0 01       	movw	r30, r0
     e7c:	11 24       	eor	r1, r1
  switch_off( component->switch_num );
     e7e:	ea 5c       	subi	r30, 0xCA	; 202
     e80:	fc 4f       	sbci	r31, 0xFC	; 252
     e82:	81 81       	ldd	r24, Z+1	; 0x01
     e84:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  component = &svit[TORQUER_1];	// Initialize Torque Coils to be OFF
  component->switch_state = SW_OFF;
     e88:	10 92 14 05 	sts	0x0514, r1
  component = &svit[TORQUER_2];
  component->switch_state = SW_OFF;
     e8c:	10 92 30 05 	sts	0x0530, r1
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
     e90:	10 92 4c 05 	sts	0x054C, r1
  torquer_off(TORQUER_1);
     e94:	81 e1       	ldi	r24, 0x11	; 17
     e96:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
  torquer_off(TORQUER_2);
     e9a:	82 e1       	ldi	r24, 0x12	; 18
     e9c:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
  torquer_off(TORQUER_3);
     ea0:	83 e1       	ldi	r24, 0x13	; 19
  //---------------------------------------------------------------------  
  // END Timer Initializations
  //--------------------------------------------------------------------- 
}
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
  component->switch_state = SW_OFF;
  component = &svit[TORQUER_3];
  component->switch_state = SW_OFF;
  torquer_off(TORQUER_1);
  torquer_off(TORQUER_2);
  torquer_off(TORQUER_3);
     eae:	0c 94 a1 09 	jmp	0x1342	; 0x1342 <torquer_off>

00000eb2 <compareVoltage>:
void compareVoltage( void ) {
  SVIT_t *component;
  //component = &svit[BATTERY_1_b];
  //chargebackward = average_samples( component->I_samples );
  component = &svit[BATTERY_1];
  chargeforward= average_samples( component->I_samples );
     eb2:	87 e7       	ldi	r24, 0x77	; 119
     eb4:	95 e0       	ldi	r25, 0x05	; 5
     eb6:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
     eba:	80 93 a2 0d 	sts	0x0DA2, r24
  if (chargeforward > 2){
     ebe:	83 30       	cpi	r24, 0x03	; 3
     ec0:	10 f0       	brcs	.+4      	; 0xec6 <compareVoltage+0x14>
    charging = 0xdd;//discharging
     ec2:	8d ed       	ldi	r24, 0xDD	; 221
     ec4:	01 c0       	rjmp	.+2      	; 0xec8 <compareVoltage+0x16>
    }
  else{
    charging = 0xcc;
     ec6:	8c ec       	ldi	r24, 0xCC	; 204
     ec8:	80 93 36 07 	sts	0x0736, r24
     ecc:	08 95       	ret

00000ece <limit_check>:
we should at least get the framework set up for limit checking on arbitrary values.
The power board should have upper and lower limits for vsense and csense data, 
and turn off components if their voltage/current is too high. ONLY CHECKS
BATTERY 1 VOLTAGE LINE RIGHT NOW.
*/
void limit_check( void ) {
     ece:	cf 92       	push	r12
     ed0:	df 92       	push	r13
     ed2:	ef 92       	push	r14
     ed4:	ff 92       	push	r15
     ed6:	0f 93       	push	r16
     ed8:	1f 93       	push	r17
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
	unsigned char sw;
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
     ede:	c0 90 2d 07 	lds	r12, 0x072D
     ee2:	d0 90 2e 07 	lds	r13, 0x072E
     ee6:	e0 90 2f 07 	lds	r14, 0x072F
     eea:	f0 90 30 07 	lds	r15, 0x0730
     eee:	20 e0       	ldi	r18, 0x00	; 0
     ef0:	30 e0       	ldi	r19, 0x00	; 0
     ef2:	a9 01       	movw	r20, r18
     ef4:	c7 01       	movw	r24, r14
     ef6:	b6 01       	movw	r22, r12
     ef8:	0e 94 73 13 	call	0x26e6	; 0x26e6 <__cmpsf2>
     efc:	87 ff       	sbrs	r24, 7
     efe:	4c c0       	rjmp	.+152    	; 0xf98 <limit_check+0xca>
     f00:	29 e2       	ldi	r18, 0x29	; 41
     f02:	3c e5       	ldi	r19, 0x5C	; 92
     f04:	4f e0       	ldi	r20, 0x0F	; 15
     f06:	5f eb       	ldi	r21, 0xBF	; 191
     f08:	c7 01       	movw	r24, r14
     f0a:	b6 01       	movw	r22, r12
     f0c:	0e 94 73 13 	call	0x26e6	; 0x26e6 <__cmpsf2>
     f10:	87 ff       	sbrs	r24, 7
     f12:	0a c0       	rjmp	.+20     	; 0xf28 <limit_check+0x5a>
     f14:	25 e8       	ldi	r18, 0x85	; 133
     f16:	3b ee       	ldi	r19, 0xEB	; 235
     f18:	41 e1       	ldi	r20, 0x11	; 17
     f1a:	5f eb       	ldi	r21, 0xBF	; 191
     f1c:	c7 01       	movw	r24, r14
     f1e:	b6 01       	movw	r22, r12
     f20:	0e 94 91 14 	call	0x2922	; 0x2922 <__gesf2>
     f24:	18 16       	cp	r1, r24
     f26:	c4 f1       	brlt	.+112    	; 0xf98 <limit_check+0xca>
		safe_mode = 1;
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	80 93 4f 09 	sts	0x094F, r24
     f2e:	0c e0       	ldi	r16, 0x0C	; 12
     f30:	13 e0       	ldi	r17, 0x03	; 3
		for (sw = 0; sw < sizeof(components); sw++) {
			component = &svit[components[sw]];
     f32:	3c e1       	ldi	r19, 0x1C	; 28
     f34:	f3 2e       	mov	r15, r19
     f36:	f8 01       	movw	r30, r16
     f38:	c1 91       	ld	r28, Z+
     f3a:	8f 01       	movw	r16, r30
     f3c:	fc 9e       	mul	r15, r28
     f3e:	e0 01       	movw	r28, r0
     f40:	11 24       	eor	r1, r1
     f42:	ca 5c       	subi	r28, 0xCA	; 202
     f44:	dc 4f       	sbci	r29, 0xFC	; 252
			switch_off( component->switch_num );
     f46:	89 81       	ldd	r24, Y+1	; 0x01
     f48:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
			component->switch_state = SW_OFF;
     f4c:	1a 82       	std	Y+2, r1	; 0x02
	SVIT_t *component;

	// turn off all switches and send ack_command w/ value of SAFE_MODE
	if (percent < SAFE_MODE  && !((percent<-.56) && (percent>-.57) )   ) {
		safe_mode = 1;
		for (sw = 0; sw < sizeof(components); sw++) {
     f4e:	f3 e0       	ldi	r31, 0x03	; 3
     f50:	0c 31       	cpi	r16, 0x1C	; 28
     f52:	1f 07       	cpc	r17, r31
     f54:	81 f7       	brne	.-32     	; 0xf36 <limit_check+0x68>
			component = &svit[components[sw]];
			switch_off( component->switch_num );
			component->switch_state = SW_OFF;
		}
		component = &svit[TORQUER_1];
		component->switch_state = SW_OFF;
     f56:	10 92 14 05 	sts	0x0514, r1
		component = &svit[TORQUER_2];
		component->switch_state = SW_OFF;
     f5a:	10 92 30 05 	sts	0x0530, r1
		component = &svit[TORQUER_3];
		component->switch_state = SW_OFF;
     f5e:	10 92 4c 05 	sts	0x054C, r1
		torquer_off(TORQUER_1);
     f62:	81 e1       	ldi	r24, 0x11	; 17
     f64:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
		torquer_off(TORQUER_2);
     f68:	82 e1       	ldi	r24, 0x12	; 18
     f6a:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
		torquer_off(TORQUER_3);
     f6e:	83 e1       	ldi	r24, 0x13	; 19
     f70:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
		// Only transmit once
		if (!transmit_safe && !been_to_safe) { 
     f74:	80 91 4a 09 	lds	r24, 0x094A
     f78:	81 11       	cpse	r24, r1
     f7a:	08 c0       	rjmp	.+16     	; 0xf8c <limit_check+0xbe>
     f7c:	80 91 2f 03 	lds	r24, 0x032F
     f80:	81 11       	cpse	r24, r1
     f82:	04 c0       	rjmp	.+8      	; 0xf8c <limit_check+0xbe>
			transmit_packet( 0, VCP_ACK, SAFE_MODE);
     f84:	40 e0       	ldi	r20, 0x00	; 0
     f86:	62 e0       	ldi	r22, 0x02	; 2
     f88:	0e 94 61 12 	call	0x24c2	; 0x24c2 <transmit_packet>
			transmit_safe = 1;
		}
		else {}
		been_to_safe = 1;
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	80 93 2f 03 	sts	0x032F, r24
		transmit_safe = 1;
     f92:	80 93 4a 09 	sts	0x094A, r24
     f96:	28 c0       	rjmp	.+80     	; 0xfe8 <limit_check+0x11a>
	}
	else if (percent > SHUNT_MODE  && isCharging) {
     f98:	20 e0       	ldi	r18, 0x00	; 0
     f9a:	30 e0       	ldi	r19, 0x00	; 0
     f9c:	48 ec       	ldi	r20, 0xC8	; 200
     f9e:	52 e4       	ldi	r21, 0x42	; 66
     fa0:	c7 01       	movw	r24, r14
     fa2:	b6 01       	movw	r22, r12
     fa4:	0e 94 91 14 	call	0x2922	; 0x2922 <__gesf2>
     fa8:	18 16       	cp	r1, r24
     faa:	f4 f4       	brge	.+60     	; 0xfe8 <limit_check+0x11a>
     fac:	80 91 ab 0d 	lds	r24, 0x0DAB
     fb0:	88 23       	and	r24, r24
     fb2:	d1 f0       	breq	.+52     	; 0xfe8 <limit_check+0x11a>
	    safe_mode = 0;
     fb4:	10 92 4f 09 	sts	0x094F, r1
		// turn on the maestro and send ack_command w/ value of SHUNT_MODE
		component = &svit[MAESTRO];
		switch_on( component->switch_num );
     fb8:	80 91 a3 04 	lds	r24, 0x04A3
     fbc:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	80 93 a4 04 	sts	0x04A4, r24
		// Only transmit once
		if (!transmit_shunt && !been_to_shunt) {
     fc6:	80 91 88 0d 	lds	r24, 0x0D88
     fca:	81 11       	cpse	r24, r1
     fcc:	08 c0       	rjmp	.+16     	; 0xfde <limit_check+0x110>
     fce:	80 91 6f 09 	lds	r24, 0x096F
     fd2:	81 11       	cpse	r24, r1
     fd4:	04 c0       	rjmp	.+8      	; 0xfde <limit_check+0x110>
			transmit_packet( 0, VCP_ACK, SHUNT_MODE);
     fd6:	44 e6       	ldi	r20, 0x64	; 100
     fd8:	62 e0       	ldi	r22, 0x02	; 2
     fda:	0e 94 61 12 	call	0x24c2	; 0x24c2 <transmit_packet>
		}
		else {}	
		been_to_shunt = 1;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	80 93 6f 09 	sts	0x096F, r24
		transmit_shunt = 1;	
     fe4:	80 93 88 0d 	sts	0x0D88, r24
	}
	else {} // To avoid annoying compile warning 
}
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	ff 90       	pop	r15
     ff2:	ef 90       	pop	r14
     ff4:	df 90       	pop	r13
     ff6:	cf 90       	pop	r12
     ff8:	08 95       	ret

00000ffa <on_sequence>:

/*
Using the SoC, the power board must autonomously turn on the CDH IB, 
Radio IBs, Flight Computer, in an arbitrary level at arbitrary charge levels. 
*/
void on_sequence( void ) {
     ffa:	cf 92       	push	r12
     ffc:	df 92       	push	r13
     ffe:	ef 92       	push	r14
    1000:	ff 92       	push	r15
    1002:	cf 93       	push	r28
// CDH IB: 75% charge
// Radio IBs: 80% charge
// Flight Computer : 85% charge
	SVIT_t *component;
	// FC_5V
	if (percent > 80) {
    1004:	c0 90 2d 07 	lds	r12, 0x072D
    1008:	d0 90 2e 07 	lds	r13, 0x072E
    100c:	e0 90 2f 07 	lds	r14, 0x072F
    1010:	f0 90 30 07 	lds	r15, 0x0730
    1014:	20 e0       	ldi	r18, 0x00	; 0
    1016:	30 e0       	ldi	r19, 0x00	; 0
    1018:	40 ea       	ldi	r20, 0xA0	; 160
    101a:	52 e4       	ldi	r21, 0x42	; 66
    101c:	c7 01       	movw	r24, r14
    101e:	b6 01       	movw	r22, r12
    1020:	0e 94 91 14 	call	0x2922	; 0x2922 <__gesf2>
    1024:	18 16       	cp	r1, r24
    1026:	74 f4       	brge	.+28     	; 0x1044 <on_sequence+0x4a>
		component = &svit[FC_5V];
		switch_on( component->switch_num );
    1028:	80 91 6f 03 	lds	r24, 0x036F
    102c:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    1030:	c1 e0       	ldi	r28, 0x01	; 1
    1032:	c0 93 70 03 	sts	0x0370, r28
		component = &svit[FC_3_3V];
		switch_on( component->switch_num );
    1036:	80 91 8b 03 	lds	r24, 0x038B
    103a:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    103e:	c0 93 8c 03 	sts	0x038C, r28
    1042:	15 c0       	rjmp	.+42     	; 0x106e <on_sequence+0x74>
		
	}else if(percent < 0){
    1044:	20 e0       	ldi	r18, 0x00	; 0
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	a9 01       	movw	r20, r18
    104a:	c7 01       	movw	r24, r14
    104c:	b6 01       	movw	r22, r12
    104e:	0e 94 73 13 	call	0x26e6	; 0x26e6 <__cmpsf2>
    1052:	87 ff       	sbrs	r24, 7
    1054:	0c c0       	rjmp	.+24     	; 0x106e <on_sequence+0x74>
		component = &svit[FC_5V];
		switch_off( component->switch_num );
    1056:	80 91 6f 03 	lds	r24, 0x036F
    105a:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
		component->switch_state = SW_OFF;
    105e:	10 92 70 03 	sts	0x0370, r1
		component = &svit[FC_3_3V];
		switch_off( component->switch_num );
    1062:	80 91 8b 03 	lds	r24, 0x038B
    1066:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
		component->switch_state = SW_OFF;
    106a:	10 92 8c 03 	sts	0x038C, r1
	}
	// RADIOs 1 and 2
	if (percent > 50) {
    106e:	c0 90 2d 07 	lds	r12, 0x072D
    1072:	d0 90 2e 07 	lds	r13, 0x072E
    1076:	e0 90 2f 07 	lds	r14, 0x072F
    107a:	f0 90 30 07 	lds	r15, 0x0730
    107e:	20 e0       	ldi	r18, 0x00	; 0
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	48 e4       	ldi	r20, 0x48	; 72
    1084:	52 e4       	ldi	r21, 0x42	; 66
    1086:	c7 01       	movw	r24, r14
    1088:	b6 01       	movw	r22, r12
    108a:	0e 94 91 14 	call	0x2922	; 0x2922 <__gesf2>
    108e:	18 16       	cp	r1, r24
    1090:	74 f4       	brge	.+28     	; 0x10ae <on_sequence+0xb4>
		component = &svit[RADIO_1];		
		switch_on( component->switch_num );
    1092:	80 91 6b 04 	lds	r24, 0x046B
    1096:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    109a:	c1 e0       	ldi	r28, 0x01	; 1
    109c:	c0 93 6c 04 	sts	0x046C, r28
		component = &svit[RADIO_2];
		switch_on( component->switch_num );
    10a0:	80 91 87 04 	lds	r24, 0x0487
    10a4:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    10a8:	c0 93 88 04 	sts	0x0488, r28
    10ac:	15 c0       	rjmp	.+42     	; 0x10d8 <on_sequence+0xde>
	}else if(percent < 0){
    10ae:	20 e0       	ldi	r18, 0x00	; 0
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	a9 01       	movw	r20, r18
    10b4:	c7 01       	movw	r24, r14
    10b6:	b6 01       	movw	r22, r12
    10b8:	0e 94 73 13 	call	0x26e6	; 0x26e6 <__cmpsf2>
    10bc:	87 ff       	sbrs	r24, 7
    10be:	0c c0       	rjmp	.+24     	; 0x10d8 <on_sequence+0xde>
		component = &svit[RADIO_1];
		switch_off( component->switch_num );
    10c0:	80 91 6b 04 	lds	r24, 0x046B
    10c4:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
		component->switch_state = SW_OFF;
    10c8:	10 92 6c 04 	sts	0x046C, r1
		component = &svit[RADIO_2];
		switch_off( component->switch_num );
    10cc:	80 91 87 04 	lds	r24, 0x0487
    10d0:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
		component->switch_state = SW_OFF;
    10d4:	10 92 88 04 	sts	0x0488, r1
	}
	// CDH IB
	if (percent > 50) {
    10d8:	c0 90 2d 07 	lds	r12, 0x072D
    10dc:	d0 90 2e 07 	lds	r13, 0x072E
    10e0:	e0 90 2f 07 	lds	r14, 0x072F
    10e4:	f0 90 30 07 	lds	r15, 0x0730
    10e8:	20 e0       	ldi	r18, 0x00	; 0
    10ea:	30 e0       	ldi	r19, 0x00	; 0
    10ec:	48 e4       	ldi	r20, 0x48	; 72
    10ee:	52 e4       	ldi	r21, 0x42	; 66
    10f0:	c7 01       	movw	r24, r14
    10f2:	b6 01       	movw	r22, r12
    10f4:	0e 94 91 14 	call	0x2922	; 0x2922 <__gesf2>
    10f8:	18 16       	cp	r1, r24
    10fa:	44 f4       	brge	.+16     	; 0x110c <__stack+0xd>
		component = &svit[CDH_IB];
		switch_on( component->switch_num );
    10fc:	80 91 df 03 	lds	r24, 0x03DF
    1100:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	80 93 e0 03 	sts	0x03E0, r24
    110a:	0f c0       	rjmp	.+30     	; 0x112a <__stack+0x2b>
	}else if(percent < 0){
    110c:	20 e0       	ldi	r18, 0x00	; 0
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	a9 01       	movw	r20, r18
    1112:	c7 01       	movw	r24, r14
    1114:	b6 01       	movw	r22, r12
    1116:	0e 94 73 13 	call	0x26e6	; 0x26e6 <__cmpsf2>
    111a:	87 ff       	sbrs	r24, 7
    111c:	06 c0       	rjmp	.+12     	; 0x112a <__stack+0x2b>
		component = &svit[CDH_IB];
		switch_off( component->switch_num );
    111e:	80 91 df 03 	lds	r24, 0x03DF
    1122:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
		component->switch_state = SW_OFF;
    1126:	10 92 e0 03 	sts	0x03E0, r1
	}
}
    112a:	cf 91       	pop	r28
    112c:	ff 90       	pop	r15
    112e:	ef 90       	pop	r14
    1130:	df 90       	pop	r13
    1132:	cf 90       	pop	r12
    1134:	08 95       	ret

00001136 <main>:


// MAIN
int main( void ) 
{  
  initialize();
    1136:	0e 94 6e 06 	call	0xcdc	; 0xcdc <initialize>
  compradio2 = &svit[RADIO_2];
  compfc5 = &svit[FC_5V];
  compfc33 = &svit[FC_3_3V];
  compshunt = &svit[MAESTRO];
  
  switch_off(compcdh->switch_num);
    113a:	80 91 df 03 	lds	r24, 0x03DF
    113e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  switch_off(compradio2->switch_num);
    1142:	80 91 87 04 	lds	r24, 0x0487
    1146:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  switch_off(compfc5->switch_num);
    114a:	80 91 6f 03 	lds	r24, 0x036F
    114e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  switch_off(compfc33->switch_num);
    1152:	80 91 8b 03 	lds	r24, 0x038B
    1156:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  switch_off(compshunt->switch_num);
    115a:	80 91 a3 04 	lds	r24, 0x04A3
    115e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
  compcdh->switch_state = SW_OFF;
    1162:	10 92 e0 03 	sts	0x03E0, r1
  compradio2->switch_state = SW_OFF;
    1166:	10 92 88 04 	sts	0x0488, r1
  compfc5->switch_state = SW_OFF;
    116a:	10 92 70 03 	sts	0x0370, r1
  compfc33->switch_state = SW_OFF;
    116e:	10 92 8c 03 	sts	0x038C, r1
  compshunt->switch_state = SW_OFF;
    1172:	10 92 a4 04 	sts	0x04A4, r1
	
  //Testing
  cntr = 0;
    1176:	10 92 44 09 	sts	0x0944, r1

  while(1)
  {
	cntr = 1 - cntr; //Testing
    117a:	ff 24       	eor	r15, r15
    117c:	f3 94       	inc	r15
	
    if ( timer0_counter[1] == 0 )
    {
        timer0_counter[1] = 199;
    117e:	c7 ec       	ldi	r28, 0xC7	; 199
    1180:	d0 e0       	ldi	r29, 0x00	; 0
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1182:	0c e2       	ldi	r16, 0x2C	; 44
    1184:	11 e0       	ldi	r17, 0x01	; 1
  //Testing
  cntr = 0;

  while(1)
  {
	cntr = 1 - cntr; //Testing
    1186:	80 91 44 09 	lds	r24, 0x0944
    118a:	9f 2d       	mov	r25, r15
    118c:	98 1b       	sub	r25, r24
    118e:	90 93 44 09 	sts	0x0944, r25
	
    if ( timer0_counter[1] == 0 )
    1192:	80 91 78 0b 	lds	r24, 0x0B78
    1196:	90 91 79 0b 	lds	r25, 0x0B79
    119a:	89 2b       	or	r24, r25
    119c:	49 f4       	brne	.+18     	; 0x11b0 <main+0x7a>
    {
        timer0_counter[1] = 199;
    119e:	d0 93 79 0b 	sts	0x0B79, r29
    11a2:	c0 93 78 0b 	sts	0x0B78, r28
        transmit_packet( 1, VCP_POWER_TELEMETRY, 0);
    11a6:	40 e0       	ldi	r20, 0x00	; 0
    11a8:	60 e0       	ldi	r22, 0x00	; 0
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	0e 94 61 12 	call	0x24c2	; 0x24c2 <transmit_packet>
    }
	  if ( timer0_counter[0] == 0 )
    11b0:	80 91 76 0b 	lds	r24, 0x0B76
    11b4:	90 91 77 0b 	lds	r25, 0x0B77
    11b8:	89 2b       	or	r24, r25
    11ba:	49 f4       	brne	.+18     	; 0x11ce <main+0x98>
    {
        timer0_counter[0] = 199;
    11bc:	d0 93 77 0b 	sts	0x0B77, r29
    11c0:	c0 93 76 0b 	sts	0x0B76, r28
        transmit_packet( 0, VCP_POWER_TELEMETRY, 0);
    11c4:	40 e0       	ldi	r20, 0x00	; 0
    11c6:	60 e0       	ldi	r22, 0x00	; 0
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	0e 94 61 12 	call	0x24c2	; 0x24c2 <transmit_packet>
    }
	  if ( rx_flag[0] > 0 )
    11ce:	80 91 ac 0d 	lds	r24, 0x0DAC
    11d2:	88 23       	and	r24, r24
    11d4:	c9 f0       	breq	.+50     	; 0x1208 <main+0xd2>
    {
        rx_flag[0]--;
    11d6:	80 91 ac 0d 	lds	r24, 0x0DAC
    11da:	81 50       	subi	r24, 0x01	; 1
    11dc:	80 93 ac 0d 	sts	0x0DAC, r24
        receive_message( 0, uart_vcp_buff[0]->message, uart_vcp_buff[0]->index );
    11e0:	e0 91 a7 0d 	lds	r30, 0x0DA7
    11e4:	f0 91 a8 0d 	lds	r31, 0x0DA8
    11e8:	61 81       	ldd	r22, Z+1	; 0x01
    11ea:	72 81       	ldd	r23, Z+2	; 0x02
    11ec:	47 81       	ldd	r20, Z+7	; 0x07
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	0e 94 ae 03 	call	0x75c	; 0x75c <receive_message>
        vcpptr_init( uart_vcp_buff[0], uart_message_buff[0], BUFFER_SIZE );
    11f4:	4f ef       	ldi	r20, 0xFF	; 255
    11f6:	50 e0       	ldi	r21, 0x00	; 0
    11f8:	61 e8       	ldi	r22, 0x81	; 129
    11fa:	7b e0       	ldi	r23, 0x0B	; 11
    11fc:	80 91 a7 0d 	lds	r24, 0x0DA7
    1200:	90 91 a8 0d 	lds	r25, 0x0DA8
    1204:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <vcpptr_init>
    }
	  if ( rx_flag[1] > 0 )
    1208:	80 91 ad 0d 	lds	r24, 0x0DAD
    120c:	88 23       	and	r24, r24
    120e:	c9 f0       	breq	.+50     	; 0x1242 <main+0x10c>
    {
        rx_flag[1]--;
    1210:	80 91 ad 0d 	lds	r24, 0x0DAD
    1214:	81 50       	subi	r24, 0x01	; 1
    1216:	80 93 ad 0d 	sts	0x0DAD, r24
        receive_message( 1, uart_vcp_buff[1]->message, uart_vcp_buff[1]->index );
    121a:	e0 91 a9 0d 	lds	r30, 0x0DA9
    121e:	f0 91 aa 0d 	lds	r31, 0x0DAA
    1222:	61 81       	ldd	r22, Z+1	; 0x01
    1224:	72 81       	ldd	r23, Z+2	; 0x02
    1226:	47 81       	ldd	r20, Z+7	; 0x07
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	0e 94 ae 03 	call	0x75c	; 0x75c <receive_message>
        vcpptr_init( uart_vcp_buff[1], uart_message_buff[1], BUFFER_SIZE );
    122e:	4f ef       	ldi	r20, 0xFF	; 255
    1230:	50 e0       	ldi	r21, 0x00	; 0
    1232:	60 e8       	ldi	r22, 0x80	; 128
    1234:	7c e0       	ldi	r23, 0x0C	; 12
    1236:	80 91 a9 0d 	lds	r24, 0x0DA9
    123a:	90 91 aa 0d 	lds	r25, 0x0DAA
    123e:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <vcpptr_init>
    }
    if (adc_flag == 1)
    1242:	80 91 45 09 	lds	r24, 0x0945
    1246:	81 30       	cpi	r24, 0x01	; 1
    1248:	a1 f4       	brne	.+40     	; 0x1272 <main+0x13c>
    {
        adc_flag = 0;
    124a:	10 92 45 09 	sts	0x0945, r1
        read_VIT();
    124e:	0e 94 95 0a 	call	0x152a	; 0x152a <read_VIT>
		//calcSOC();
		StateofCharge();
    1252:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <StateofCharge>
		//if(beyondDelay){
			on_sequence();
    1256:	0e 94 fd 07 	call	0xffa	; 0xffa <on_sequence>

		/*
		Manual Override on Limit Checking: The power board must be able to receive a 
		command to disable and/or change the limits in the limit checking code
		*/
		if (!limit_check_overriden) {
    125a:	80 91 2c 07 	lds	r24, 0x072C
    125e:	81 11       	cpse	r24, r1
    1260:	02 c0       	rjmp	.+4      	; 0x1266 <main+0x130>
			limit_check(); // First determine if voltage is within valid range, then switch
    1262:	0e 94 67 07 	call	0xece	; 0xece <limit_check>
		}

		if ( adc_component == 23 ) 
    1266:	80 91 35 03 	lds	r24, 0x0335
    126a:	87 31       	cpi	r24, 0x17	; 23
    126c:	11 f4       	brne	.+4      	; 0x1272 <main+0x13c>
      	{ //23ish anything after battery values are calculated
  			  compareVoltage();
    126e:	0e 94 59 07 	call	0xeb2	; 0xeb2 <compareVoltage>
	   	}
    }	
	
	//Restart all board components if CDH-IB heartbeat timeout
	if (cdh_heartbeat_flag == 1){
    1272:	80 91 22 03 	lds	r24, 0x0322
    1276:	81 30       	cpi	r24, 0x01	; 1
    1278:	09 f0       	breq	.+2      	; 0x127c <main+0x146>
    127a:	85 cf       	rjmp	.-246    	; 0x1186 <main+0x50>
		//Restart all components
		//PORTC ^= 0x02;
		//Set flag off
		cdh_heartbeat_flag = 0;
    127c:	10 92 22 03 	sts	0x0322, r1
		
		//reset appropriate timer counter to cycle_counter_2     //DOUBLECHECK that this adheres to the spec!!!
		timer1_counter[1] = CYCLE_COUNTER_2;
    1280:	10 93 9f 0d 	sts	0x0D9F, r17
    1284:	00 93 9e 0d 	sts	0x0D9E, r16
    1288:	7e cf       	rjmp	.-260    	; 0x1186 <main+0x50>

0000128a <torquer_off.part.0>:
void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
  {
    case TORQUER_1:
      CLR( PORTC, 0 );
    128a:	a8 98       	cbi	0x15, 0	; 21
	  CLR( PORTG, 1 );
    128c:	e5 e6       	ldi	r30, 0x65	; 101
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	8d 7f       	andi	r24, 0xFD	; 253
    1294:	80 83       	st	Z, r24
    1296:	08 95       	ret

00001298 <set_mux_sel>:
#include "mcupwr-Defs.h"


void set_mux_sel( uint8_t mux_num, uint8_t mux_sel )
{
  switch( mux_num )
    1298:	81 30       	cpi	r24, 0x01	; 1
    129a:	f9 f0       	breq	.+62     	; 0x12da <set_mux_sel+0x42>
    129c:	20 f0       	brcs	.+8      	; 0x12a6 <set_mux_sel+0xe>
    129e:	82 30       	cpi	r24, 0x02	; 2
    12a0:	09 f0       	breq	.+2      	; 0x12a4 <set_mux_sel+0xc>
    12a2:	4e c0       	rjmp	.+156    	; 0x1340 <set_mux_sel+0xa8>
    12a4:	34 c0       	rjmp	.+104    	; 0x130e <set_mux_sel+0x76>
  {
    case MUX0:
      READ( mux_sel, 4 ) ? SET( PORTA, 7 ) : CLR( PORTA, 7 );
    12a6:	64 ff       	sbrs	r22, 4
    12a8:	02 c0       	rjmp	.+4      	; 0x12ae <set_mux_sel+0x16>
    12aa:	df 9a       	sbi	0x1b, 7	; 27
    12ac:	01 c0       	rjmp	.+2      	; 0x12b0 <set_mux_sel+0x18>
    12ae:	df 98       	cbi	0x1b, 7	; 27
      READ( mux_sel, 3 ) ? SET( PORTA, 6 ) : CLR( PORTA, 6 );
    12b0:	63 ff       	sbrs	r22, 3
    12b2:	02 c0       	rjmp	.+4      	; 0x12b8 <set_mux_sel+0x20>
    12b4:	de 9a       	sbi	0x1b, 6	; 27
    12b6:	01 c0       	rjmp	.+2      	; 0x12ba <set_mux_sel+0x22>
    12b8:	de 98       	cbi	0x1b, 6	; 27
      READ( mux_sel, 2 ) ? SET( PORTA, 5 ) : CLR( PORTA, 5 );
    12ba:	62 ff       	sbrs	r22, 2
    12bc:	02 c0       	rjmp	.+4      	; 0x12c2 <set_mux_sel+0x2a>
    12be:	dd 9a       	sbi	0x1b, 5	; 27
    12c0:	01 c0       	rjmp	.+2      	; 0x12c4 <set_mux_sel+0x2c>
    12c2:	dd 98       	cbi	0x1b, 5	; 27
      READ( mux_sel, 1 ) ? SET( PORTA, 4 ) : CLR( PORTA, 4 );
    12c4:	61 ff       	sbrs	r22, 1
    12c6:	02 c0       	rjmp	.+4      	; 0x12cc <set_mux_sel+0x34>
    12c8:	dc 9a       	sbi	0x1b, 4	; 27
    12ca:	01 c0       	rjmp	.+2      	; 0x12ce <set_mux_sel+0x36>
    12cc:	dc 98       	cbi	0x1b, 4	; 27
      READ( mux_sel, 0 ) ? SET( PORTA, 3 ) : CLR( PORTA, 3 );
    12ce:	60 ff       	sbrs	r22, 0
    12d0:	02 c0       	rjmp	.+4      	; 0x12d6 <set_mux_sel+0x3e>
    12d2:	db 9a       	sbi	0x1b, 3	; 27
    12d4:	08 95       	ret
    12d6:	db 98       	cbi	0x1b, 3	; 27
    12d8:	08 95       	ret

      break;

    case MUX1:
      READ( mux_sel, 4 ) ? SET( PORTB, 0 ) : CLR( PORTB, 0 );
    12da:	64 ff       	sbrs	r22, 4
    12dc:	02 c0       	rjmp	.+4      	; 0x12e2 <set_mux_sel+0x4a>
    12de:	c0 9a       	sbi	0x18, 0	; 24
    12e0:	01 c0       	rjmp	.+2      	; 0x12e4 <set_mux_sel+0x4c>
    12e2:	c0 98       	cbi	0x18, 0	; 24
      READ( mux_sel, 3 ) ? SET( PORTB, 1 ) : CLR( PORTB, 1 );
    12e4:	63 ff       	sbrs	r22, 3
    12e6:	02 c0       	rjmp	.+4      	; 0x12ec <set_mux_sel+0x54>
    12e8:	c1 9a       	sbi	0x18, 1	; 24
    12ea:	01 c0       	rjmp	.+2      	; 0x12ee <set_mux_sel+0x56>
    12ec:	c1 98       	cbi	0x18, 1	; 24
      READ( mux_sel, 2 ) ? SET( PORTB, 2 ) : CLR( PORTB, 2 );
    12ee:	62 ff       	sbrs	r22, 2
    12f0:	02 c0       	rjmp	.+4      	; 0x12f6 <set_mux_sel+0x5e>
    12f2:	c2 9a       	sbi	0x18, 2	; 24
    12f4:	01 c0       	rjmp	.+2      	; 0x12f8 <set_mux_sel+0x60>
    12f6:	c2 98       	cbi	0x18, 2	; 24
      READ( mux_sel, 1 ) ? SET( PORTB, 3 ) : CLR( PORTB, 3 );
    12f8:	61 ff       	sbrs	r22, 1
    12fa:	02 c0       	rjmp	.+4      	; 0x1300 <set_mux_sel+0x68>
    12fc:	c3 9a       	sbi	0x18, 3	; 24
    12fe:	01 c0       	rjmp	.+2      	; 0x1302 <set_mux_sel+0x6a>
    1300:	c3 98       	cbi	0x18, 3	; 24
      READ( mux_sel, 0 ) ? SET( PORTB, 4 ) : CLR( PORTB, 4 );
    1302:	60 ff       	sbrs	r22, 0
    1304:	02 c0       	rjmp	.+4      	; 0x130a <set_mux_sel+0x72>
    1306:	c4 9a       	sbi	0x18, 4	; 24
    1308:	08 95       	ret
    130a:	c4 98       	cbi	0x18, 4	; 24
    130c:	08 95       	ret

      break;

    case MUX2:
      READ( mux_sel, 4 ) ? SET( PORTE, 3 ) : CLR( PORTE, 3 );
    130e:	64 ff       	sbrs	r22, 4
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <set_mux_sel+0x7e>
    1312:	1b 9a       	sbi	0x03, 3	; 3
    1314:	01 c0       	rjmp	.+2      	; 0x1318 <set_mux_sel+0x80>
    1316:	1b 98       	cbi	0x03, 3	; 3
      READ( mux_sel, 3 ) ? SET( PORTE, 4 ) : CLR( PORTE, 4 );
    1318:	63 ff       	sbrs	r22, 3
    131a:	02 c0       	rjmp	.+4      	; 0x1320 <set_mux_sel+0x88>
    131c:	1c 9a       	sbi	0x03, 4	; 3
    131e:	01 c0       	rjmp	.+2      	; 0x1322 <set_mux_sel+0x8a>
    1320:	1c 98       	cbi	0x03, 4	; 3
      READ( mux_sel, 2 ) ? SET( PORTE, 5 ) : CLR( PORTE, 5 );
    1322:	62 ff       	sbrs	r22, 2
    1324:	02 c0       	rjmp	.+4      	; 0x132a <set_mux_sel+0x92>
    1326:	1d 9a       	sbi	0x03, 5	; 3
    1328:	01 c0       	rjmp	.+2      	; 0x132c <set_mux_sel+0x94>
    132a:	1d 98       	cbi	0x03, 5	; 3
      READ( mux_sel, 1 ) ? SET( PORTE, 6 ) : CLR( PORTE, 6 );
    132c:	61 ff       	sbrs	r22, 1
    132e:	02 c0       	rjmp	.+4      	; 0x1334 <set_mux_sel+0x9c>
    1330:	1e 9a       	sbi	0x03, 6	; 3
    1332:	01 c0       	rjmp	.+2      	; 0x1336 <set_mux_sel+0x9e>
    1334:	1e 98       	cbi	0x03, 6	; 3
      READ( mux_sel, 0 ) ? SET( PORTE, 7 ) : CLR( PORTE, 7 );
    1336:	60 ff       	sbrs	r22, 0
    1338:	02 c0       	rjmp	.+4      	; 0x133e <set_mux_sel+0xa6>
    133a:	1f 9a       	sbi	0x03, 7	; 3
    133c:	08 95       	ret
    133e:	1f 98       	cbi	0x03, 7	; 3
    1340:	08 95       	ret

00001342 <torquer_off>:
  }
}

void torquer_off( uint8_t torquer_num )
{
  switch( torquer_num )
    1342:	82 31       	cpi	r24, 0x12	; 18
    1344:	31 f0       	breq	.+12     	; 0x1352 <torquer_off+0x10>
    1346:	83 31       	cpi	r24, 0x13	; 19
    1348:	59 f0       	breq	.+22     	; 0x1360 <torquer_off+0x1e>
    134a:	81 31       	cpi	r24, 0x11	; 17
    134c:	99 f4       	brne	.+38     	; 0x1374 <torquer_off+0x32>
    134e:	0c 94 45 09 	jmp	0x128a	; 0x128a <torquer_off.part.0>
      CLR( PORTC, 0 );
	  CLR( PORTG, 1 );
      break;

    case TORQUER_2:
      CLR( PORTG, 0 );
    1352:	80 91 65 00 	lds	r24, 0x0065
    1356:	8e 7f       	andi	r24, 0xFE	; 254
    1358:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTD, 0 );
    135c:	90 98       	cbi	0x12, 0	; 18
      break;
    135e:	08 95       	ret

    case TORQUER_3:
      CLR( PORTG, 3 );
    1360:	80 91 65 00 	lds	r24, 0x0065
    1364:	87 7f       	andi	r24, 0xF7	; 247
    1366:	80 93 65 00 	sts	0x0065, r24
	  CLR( PORTG, 4 );
    136a:	80 91 65 00 	lds	r24, 0x0065
    136e:	8f 7e       	andi	r24, 0xEF	; 239
    1370:	80 93 65 00 	sts	0x0065, r24
    1374:	08 95       	ret

00001376 <torquer_on>:
  }  
}

void torquer_on( uint8_t torquer_num )
{
  switch( torquer_num )
    1376:	82 31       	cpi	r24, 0x12	; 18
    1378:	49 f0       	breq	.+18     	; 0x138c <torquer_on+0x16>
    137a:	83 31       	cpi	r24, 0x13	; 19
    137c:	71 f0       	breq	.+28     	; 0x139a <torquer_on+0x24>
    137e:	81 31       	cpi	r24, 0x11	; 17
    1380:	b1 f4       	brne	.+44     	; 0x13ae <torquer_on+0x38>
  {
    case TORQUER_1:
      SET( PORTC, 0 );
    1382:	a8 9a       	sbi	0x15, 0	; 21
	  SET( PORTG, 1 );
    1384:	80 91 65 00 	lds	r24, 0x0065
    1388:	82 60       	ori	r24, 0x02	; 2
    138a:	0f c0       	rjmp	.+30     	; 0x13aa <torquer_on+0x34>
      break;

    case TORQUER_2:
      SET( PORTG, 0 );
    138c:	80 91 65 00 	lds	r24, 0x0065
    1390:	81 60       	ori	r24, 0x01	; 1
    1392:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTD, 0 );
    1396:	90 9a       	sbi	0x12, 0	; 18
      break;
    1398:	08 95       	ret

    case TORQUER_3:
      SET( PORTG, 3 );
    139a:	80 91 65 00 	lds	r24, 0x0065
    139e:	88 60       	ori	r24, 0x08	; 8
    13a0:	80 93 65 00 	sts	0x0065, r24
	  SET( PORTG, 4 );
    13a4:	80 91 65 00 	lds	r24, 0x0065
    13a8:	80 61       	ori	r24, 0x10	; 16
    13aa:	80 93 65 00 	sts	0x0065, r24
    13ae:	08 95       	ret

000013b0 <switch_on>:
  }
}

void switch_on( uint8_t switch_num )
{
  switch ( switch_num )
    13b0:	88 30       	cpi	r24, 0x08	; 8
    13b2:	59 f1       	breq	.+86     	; 0x140a <switch_on+0x5a>
    13b4:	68 f4       	brcc	.+26     	; 0x13d0 <switch_on+0x20>
    13b6:	84 30       	cpi	r24, 0x04	; 4
    13b8:	01 f1       	breq	.+64     	; 0x13fa <switch_on+0x4a>
    13ba:	30 f4       	brcc	.+12     	; 0x13c8 <switch_on+0x18>
    13bc:	82 30       	cpi	r24, 0x02	; 2
    13be:	c9 f0       	breq	.+50     	; 0x13f2 <switch_on+0x42>
    13c0:	d0 f4       	brcc	.+52     	; 0x13f6 <switch_on+0x46>
    13c2:	81 30       	cpi	r24, 0x01	; 1
    13c4:	b9 f5       	brne	.+110    	; 0x1434 <switch_on+0x84>
    13c6:	13 c0       	rjmp	.+38     	; 0x13ee <switch_on+0x3e>
    13c8:	86 30       	cpi	r24, 0x06	; 6
    13ca:	d9 f0       	breq	.+54     	; 0x1402 <switch_on+0x52>
    13cc:	e0 f4       	brcc	.+56     	; 0x1406 <switch_on+0x56>
    13ce:	17 c0       	rjmp	.+46     	; 0x13fe <switch_on+0x4e>
    13d0:	8c 30       	cpi	r24, 0x0C	; 12
    13d2:	39 f1       	breq	.+78     	; 0x1422 <switch_on+0x72>
    13d4:	20 f4       	brcc	.+8      	; 0x13de <switch_on+0x2e>
    13d6:	8a 30       	cpi	r24, 0x0A	; 10
    13d8:	01 f1       	breq	.+64     	; 0x141a <switch_on+0x6a>
    13da:	08 f5       	brcc	.+66     	; 0x141e <switch_on+0x6e>
    13dc:	18 c0       	rjmp	.+48     	; 0x140e <switch_on+0x5e>
    13de:	8e 30       	cpi	r24, 0x0E	; 14
    13e0:	21 f1       	breq	.+72     	; 0x142a <switch_on+0x7a>
    13e2:	08 f1       	brcs	.+66     	; 0x1426 <switch_on+0x76>
    13e4:	8f 30       	cpi	r24, 0x0F	; 15
    13e6:	19 f1       	breq	.+70     	; 0x142e <switch_on+0x7e>
    13e8:	80 31       	cpi	r24, 0x10	; 16
    13ea:	21 f5       	brne	.+72     	; 0x1434 <switch_on+0x84>
    13ec:	22 c0       	rjmp	.+68     	; 0x1432 <switch_on+0x82>
  {
    case 1:
      SET( PORTA, 0 );
    13ee:	d8 9a       	sbi	0x1b, 0	; 27
      break;
    13f0:	08 95       	ret

    case 2:
      SET( PORTA, 1 );
    13f2:	d9 9a       	sbi	0x1b, 1	; 27
      break;
    13f4:	08 95       	ret

    case 3:
      SET( PORTA, 2 );
    13f6:	da 9a       	sbi	0x1b, 2	; 27
      break;
    13f8:	08 95       	ret

    case 4:
      SET( PORTB, 5 );
    13fa:	c5 9a       	sbi	0x18, 5	; 24
      break;
    13fc:	08 95       	ret

    case 5:
      SET( PORTB, 6 );
    13fe:	c6 9a       	sbi	0x18, 6	; 24
      break;
    1400:	08 95       	ret

    case 6:
      SET( PORTB, 7 );
    1402:	c7 9a       	sbi	0x18, 7	; 24
      break;
    1404:	08 95       	ret

    case 7:
      SET( PORTD, 4 );
    1406:	94 9a       	sbi	0x12, 4	; 18
      break;
    1408:	08 95       	ret

    case 8:
      SET( PORTD, 5 );
    140a:	95 9a       	sbi	0x12, 5	; 18
      break;
    140c:	08 95       	ret

    case 9:
      SET( PORTG, 2 );
    140e:	80 91 65 00 	lds	r24, 0x0065
    1412:	84 60       	ori	r24, 0x04	; 4
    1414:	80 93 65 00 	sts	0x0065, r24
      break;
    1418:	08 95       	ret

    case 10: 
      SET( PORTC, 7 );
    141a:	af 9a       	sbi	0x15, 7	; 21
      break;
    141c:	08 95       	ret

    case 11:
      SET( PORTC, 6 );
    141e:	ae 9a       	sbi	0x15, 6	; 21
      break;
    1420:	08 95       	ret

    case 12:
      SET( PORTC, 5 );
    1422:	ad 9a       	sbi	0x15, 5	; 21
      break;
    1424:	08 95       	ret

    case 13:
      SET( PORTC, 4 );
    1426:	ac 9a       	sbi	0x15, 4	; 21
      break;
    1428:	08 95       	ret

    case 14:
      SET( PORTC, 3 );
    142a:	ab 9a       	sbi	0x15, 3	; 21
      break;
    142c:	08 95       	ret

    case 15:
      SET( PORTC, 2 );
    142e:	aa 9a       	sbi	0x15, 2	; 21
      break;
    1430:	08 95       	ret

    case 16:
      SET( PORTC, 1 );
    1432:	a9 9a       	sbi	0x15, 1	; 21
    1434:	08 95       	ret

00001436 <switch_off>:
  }
}

void switch_off( uint8_t switch_num )
{
  switch ( switch_num )
    1436:	88 30       	cpi	r24, 0x08	; 8
    1438:	59 f1       	breq	.+86     	; 0x1490 <switch_off+0x5a>
    143a:	68 f4       	brcc	.+26     	; 0x1456 <switch_off+0x20>
    143c:	84 30       	cpi	r24, 0x04	; 4
    143e:	01 f1       	breq	.+64     	; 0x1480 <switch_off+0x4a>
    1440:	30 f4       	brcc	.+12     	; 0x144e <switch_off+0x18>
    1442:	82 30       	cpi	r24, 0x02	; 2
    1444:	c9 f0       	breq	.+50     	; 0x1478 <switch_off+0x42>
    1446:	d0 f4       	brcc	.+52     	; 0x147c <switch_off+0x46>
    1448:	81 30       	cpi	r24, 0x01	; 1
    144a:	b9 f5       	brne	.+110    	; 0x14ba <switch_off+0x84>
    144c:	13 c0       	rjmp	.+38     	; 0x1474 <switch_off+0x3e>
    144e:	86 30       	cpi	r24, 0x06	; 6
    1450:	d9 f0       	breq	.+54     	; 0x1488 <switch_off+0x52>
    1452:	e0 f4       	brcc	.+56     	; 0x148c <switch_off+0x56>
    1454:	17 c0       	rjmp	.+46     	; 0x1484 <switch_off+0x4e>
    1456:	8c 30       	cpi	r24, 0x0C	; 12
    1458:	39 f1       	breq	.+78     	; 0x14a8 <switch_off+0x72>
    145a:	20 f4       	brcc	.+8      	; 0x1464 <switch_off+0x2e>
    145c:	8a 30       	cpi	r24, 0x0A	; 10
    145e:	01 f1       	breq	.+64     	; 0x14a0 <switch_off+0x6a>
    1460:	08 f5       	brcc	.+66     	; 0x14a4 <switch_off+0x6e>
    1462:	18 c0       	rjmp	.+48     	; 0x1494 <switch_off+0x5e>
    1464:	8e 30       	cpi	r24, 0x0E	; 14
    1466:	21 f1       	breq	.+72     	; 0x14b0 <switch_off+0x7a>
    1468:	08 f1       	brcs	.+66     	; 0x14ac <switch_off+0x76>
    146a:	8f 30       	cpi	r24, 0x0F	; 15
    146c:	19 f1       	breq	.+70     	; 0x14b4 <switch_off+0x7e>
    146e:	80 31       	cpi	r24, 0x10	; 16
    1470:	21 f5       	brne	.+72     	; 0x14ba <switch_off+0x84>
    1472:	22 c0       	rjmp	.+68     	; 0x14b8 <switch_off+0x82>
  {
    case 1:
      CLR( PORTA, 0 );
    1474:	d8 98       	cbi	0x1b, 0	; 27
      break;
    1476:	08 95       	ret

    case 2:
      CLR( PORTA, 1 );
    1478:	d9 98       	cbi	0x1b, 1	; 27
      break;
    147a:	08 95       	ret

    case 3:
      CLR( PORTA, 2 );
    147c:	da 98       	cbi	0x1b, 2	; 27
      break;
    147e:	08 95       	ret

    case 4:
      CLR( PORTB, 5 );
    1480:	c5 98       	cbi	0x18, 5	; 24
      break;
    1482:	08 95       	ret

    case 5:
      CLR( PORTB, 6 );
    1484:	c6 98       	cbi	0x18, 6	; 24
      break;
    1486:	08 95       	ret

    case 6:
      CLR( PORTB, 7 );
    1488:	c7 98       	cbi	0x18, 7	; 24
      break;
    148a:	08 95       	ret

    case 7:
      CLR( PORTD, 4 );
    148c:	94 98       	cbi	0x12, 4	; 18
      break;
    148e:	08 95       	ret

    case 8:
      CLR( PORTD, 5 );
    1490:	95 98       	cbi	0x12, 5	; 18
      break;
    1492:	08 95       	ret

    case 9:
      CLR( PORTG, 2 );
    1494:	80 91 65 00 	lds	r24, 0x0065
    1498:	8b 7f       	andi	r24, 0xFB	; 251
    149a:	80 93 65 00 	sts	0x0065, r24
      break;
    149e:	08 95       	ret

    case 10: 
      CLR( PORTC, 7 );
    14a0:	af 98       	cbi	0x15, 7	; 21
      break;
    14a2:	08 95       	ret

    case 11:
      CLR( PORTC, 6 );
    14a4:	ae 98       	cbi	0x15, 6	; 21
      break;
    14a6:	08 95       	ret

    case 12:
      CLR( PORTC, 5 );
    14a8:	ad 98       	cbi	0x15, 5	; 21
      break;
    14aa:	08 95       	ret

    case 13:
      CLR( PORTC, 4 );
    14ac:	ac 98       	cbi	0x15, 4	; 21
      break;
    14ae:	08 95       	ret

    case 14:
      CLR( PORTC, 3 );
    14b0:	ab 98       	cbi	0x15, 3	; 21
      break;
    14b2:	08 95       	ret

    case 15:
      CLR( PORTC, 2 );
    14b4:	aa 98       	cbi	0x15, 2	; 21
      break;
    14b6:	08 95       	ret

    case 16:
      CLR( PORTC, 1 );
    14b8:	a9 98       	cbi	0x15, 1	; 21
    14ba:	08 95       	ret

000014bc <average_samples>:
    return  average_samples( component->I_samples );
  }
}

uint8_t average_samples( uint8_t samples[NUM_SAMPLES] )
{
    14bc:	fc 01       	movw	r30, r24
  uint8_t average = 0;
  uint16_t sum = 0;

  for(uint8_t avg_index = 0; avg_index < NUM_SAMPLES; avg_index++)
    sum += samples[avg_index];
    14be:	21 81       	ldd	r18, Z+1	; 0x01
    14c0:	80 81       	ld	r24, Z
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	82 0f       	add	r24, r18
    14c6:	91 1d       	adc	r25, r1
    14c8:	22 81       	ldd	r18, Z+2	; 0x02
    14ca:	82 0f       	add	r24, r18
    14cc:	91 1d       	adc	r25, r1

  average = sum / NUM_SAMPLES;
    14ce:	63 e0       	ldi	r22, 0x03	; 3
    14d0:	70 e0       	ldi	r23, 0x00	; 0
    14d2:	0e 94 95 14 	call	0x292a	; 0x292a <__udivmodhi4>
    14d6:	86 2f       	mov	r24, r22

  return average;
}
    14d8:	08 95       	ret

000014da <SVIT_check_I_critical>:
}

uint8_t SVIT_check_I_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    14da:	9c e1       	ldi	r25, 0x1C	; 28
    14dc:	89 9f       	mul	r24, r25
    14de:	f0 01       	movw	r30, r0
    14e0:	11 24       	eor	r1, r1
    14e2:	ea 5c       	subi	r30, 0xCA	; 202
    14e4:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->I_critical_value != 0 )
    14e6:	85 89       	ldd	r24, Z+21	; 0x15
    14e8:	88 23       	and	r24, r24
    14ea:	11 f0       	breq	.+4      	; 0x14f0 <SVIT_check_I_critical+0x16>
  {
    temp= component->I_critical_value;
    component->I_critical_value = 0;
    14ec:	15 8a       	std	Z+21, r1	; 0x15
    14ee:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->I_samples );
    14f0:	cf 01       	movw	r24, r30
    14f2:	41 96       	adiw	r24, 0x11	; 17
    14f4:	0c 94 5e 0a 	jmp	0x14bc	; 0x14bc <average_samples>

000014f8 <SVIT_check_V_critical>:
}

uint8_t SVIT_check_V_critical( uint8_t name )
{
  uint8_t temp;
  SVIT_t* component= &svit[name];
    14f8:	9c e1       	ldi	r25, 0x1C	; 28
    14fa:	89 9f       	mul	r24, r25
    14fc:	f0 01       	movw	r30, r0
    14fe:	11 24       	eor	r1, r1
    1500:	ea 5c       	subi	r30, 0xCA	; 202
    1502:	fc 4f       	sbci	r31, 0xFC	; 252
  if ( component->V_critical_value != 0 )
    1504:	84 85       	ldd	r24, Z+12	; 0x0c
    1506:	88 23       	and	r24, r24
    1508:	11 f0       	breq	.+4      	; 0x150e <SVIT_check_V_critical+0x16>
  {
    temp= component->V_critical_value;
    component->V_critical_value = 0;
    150a:	14 86       	std	Z+12, r1	; 0x0c
    150c:	08 95       	ret
    return temp;
  }
  else
  {
    return  average_samples( component->V_samples );
    150e:	cf 01       	movw	r24, r30
    1510:	08 96       	adiw	r24, 0x08	; 8
    1512:	0c 94 5e 0a 	jmp	0x14bc	; 0x14bc <average_samples>

00001516 <perform_ADC>:
}

void perform_ADC( uint8_t mux_num )
{
  // set Vref to AVCC and set the ADC channel to the correct pin ( mux_num )
  ADMUX = (1 << ADLAR) | ( 1 << REFS0 );
    1516:	90 e6       	ldi	r25, 0x60	; 96
    1518:	97 b9       	out	0x07, r25	; 7
  ADMUX &= ~0x3;
    151a:	97 b1       	in	r25, 0x07	; 7
    151c:	9c 7f       	andi	r25, 0xFC	; 252
    151e:	97 b9       	out	0x07, r25	; 7
  ADMUX |= mux_num;
    1520:	97 b1       	in	r25, 0x07	; 7
    1522:	98 2b       	or	r25, r24
    1524:	97 b9       	out	0x07, r25	; 7

  // signal ADC to start a new conversion
  ADCSRA |= ( 1 << ADSC );
    1526:	36 9a       	sbi	0x06, 6	; 6
    1528:	08 95       	ret

0000152a <read_VIT>:

  // when the conversion finishes, the result is stored in ADCL and ADCH
}

void read_VIT( void )
{
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1530:	80 91 52 09 	lds	r24, 0x0952
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1534:	c0 91 35 03 	lds	r28, 0x0335
  uint8_t mux_sel;
  SVIT_t* component;
  uint8_t sample_index;
  //analyze completed ADC conversion 
  
  switch ( adc_sensor_type ){
    1538:	82 30       	cpi	r24, 0x02	; 2
    153a:	09 f4       	brne	.+2      	; 0x153e <read_VIT+0x14>
    153c:	6a c0       	rjmp	.+212    	; 0x1612 <read_VIT+0xe8>
    153e:	20 f4       	brcc	.+8      	; 0x1548 <read_VIT+0x1e>
    1540:	81 30       	cpi	r24, 0x01	; 1
    1542:	09 f0       	breq	.+2      	; 0x1546 <read_VIT+0x1c>
    1544:	01 c1       	rjmp	.+514    	; 0x1748 <read_VIT+0x21e>
    1546:	07 c0       	rjmp	.+14     	; 0x1556 <read_VIT+0x2c>
    1548:	83 30       	cpi	r24, 0x03	; 3
    154a:	09 f4       	brne	.+2      	; 0x154e <read_VIT+0x24>
    154c:	c1 c0       	rjmp	.+386    	; 0x16d0 <read_VIT+0x1a6>
    154e:	84 30       	cpi	r24, 0x04	; 4
    1550:	09 f0       	breq	.+2      	; 0x1554 <read_VIT+0x2a>
    1552:	fa c0       	rjmp	.+500    	; 0x1748 <read_VIT+0x21e>
    1554:	e5 c0       	rjmp	.+458    	; 0x1720 <read_VIT+0x1f6>
		case ADC_VOLTAGE:
			component = &svit[adc_component];
    1556:	8c e1       	ldi	r24, 0x1C	; 28
    1558:	c8 9f       	mul	r28, r24
    155a:	e0 01       	movw	r28, r0
    155c:	11 24       	eor	r1, r1
    155e:	ca 5c       	subi	r28, 0xCA	; 202
    1560:	dc 4f       	sbci	r29, 0xFC	; 252
			sample_index = component->V_sample_index;
			component->V_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    1562:	2b 85       	ldd	r18, Y+11	; 0x0b
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	c9 01       	movw	r24, r18
    1568:	01 96       	adiw	r24, 0x01	; 1
    156a:	63 e0       	ldi	r22, 0x03	; 3
    156c:	70 e0       	ldi	r23, 0x00	; 0
    156e:	0e 94 a9 14 	call	0x2952	; 0x2952 <__divmodhi4>
    1572:	8b 87       	std	Y+11, r24	; 0x0b

			// SoC: If component is a battery, store in different global variable
			if (component->name == BATTERY_1) {
    1574:	98 81       	ld	r25, Y
    1576:	94 31       	cpi	r25, 0x14	; 20
    1578:	89 f4       	brne	.+34     	; 0x159c <read_VIT+0x72>
				batt1_voltage = ADC_high;
    157a:	80 91 63 09 	lds	r24, 0x0963
    157e:	80 93 6d 09 	sts	0x096D, r24
				batt1_voltageLow = ADC_low;
    1582:	80 91 a0 0d 	lds	r24, 0x0DA0
    1586:	80 93 83 0d 	sts	0x0D83, r24
				high = ADC_high;
    158a:	80 91 63 09 	lds	r24, 0x0963
    158e:	80 93 5e 09 	sts	0x095E, r24
				low = ADC_low;
    1592:	80 91 a0 0d 	lds	r24, 0x0DA0
    1596:	80 93 6c 09 	sts	0x096C, r24
    159a:	06 c0       	rjmp	.+12     	; 0x15a8 <read_VIT+0x7e>
				//debug = adc_component;
			}
			else if (component->name == BATTERY_2) {
    159c:	95 31       	cpi	r25, 0x15	; 21
    159e:	21 f4       	brne	.+8      	; 0x15a8 <read_VIT+0x7e>
				batt2_voltage = ADC_high;
    15a0:	80 91 63 09 	lds	r24, 0x0963
    15a4:	80 93 80 0b 	sts	0x0B80, r24
			}
			component->V_samples[sample_index] = ADC_high;
    15a8:	80 91 63 09 	lds	r24, 0x0963
    15ac:	fe 01       	movw	r30, r28
    15ae:	e2 0f       	add	r30, r18
    15b0:	f3 1f       	adc	r31, r19
    15b2:	80 87       	std	Z+8, r24	; 0x08
            
			//OverVoltage
	  		if ( ( ADC_high > component->V_upper_limit ) && ( component->force_on != 1 ) ){
    15b4:	20 91 63 09 	lds	r18, 0x0963
    15b8:	8e 81       	ldd	r24, Y+6	; 0x06
    15ba:	82 17       	cp	r24, r18
    15bc:	20 f4       	brcc	.+8      	; 0x15c6 <read_VIT+0x9c>
    15be:	8b 81       	ldd	r24, Y+3	; 0x03
    15c0:	81 30       	cpi	r24, 0x01	; 1
    15c2:	09 f0       	breq	.+2      	; 0x15c6 <read_VIT+0x9c>
    15c4:	08 c0       	rjmp	.+16     	; 0x15d6 <read_VIT+0xac>
  				}
				component->switch_state = SW_OFF;
				component->V_critical_value = ADC_high;
			}
			//UnderVoltage
			else if((ADC_high < component->V_lower_limit) && component->switch_state){
    15c6:	20 91 63 09 	lds	r18, 0x0963
    15ca:	8f 81       	ldd	r24, Y+7	; 0x07
    15cc:	28 17       	cp	r18, r24
    15ce:	d8 f4       	brcc	.+54     	; 0x1606 <read_VIT+0xdc>
    15d0:	8a 81       	ldd	r24, Y+2	; 0x02
    15d2:	88 23       	and	r24, r24
    15d4:	c1 f0       	breq	.+48     	; 0x1606 <read_VIT+0xdc>
				if ( component->switch_num != SW_NULL ){
    15d6:	89 81       	ldd	r24, Y+1	; 0x01
    15d8:	8f 3f       	cpi	r24, 0xFF	; 255
    15da:	19 f0       	breq	.+6      	; 0x15e2 <read_VIT+0xb8>
					switch_off( component->switch_num );
    15dc:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
    15e0:	0e c0       	rjmp	.+28     	; 0x15fe <read_VIT+0xd4>
				}else {
					switch ( component->name ){
    15e2:	92 31       	cpi	r25, 0x12	; 18
    15e4:	39 f0       	breq	.+14     	; 0x15f4 <read_VIT+0xca>
    15e6:	93 31       	cpi	r25, 0x13	; 19
    15e8:	39 f0       	breq	.+14     	; 0x15f8 <read_VIT+0xce>
    15ea:	91 31       	cpi	r25, 0x11	; 17
    15ec:	41 f4       	brne	.+16     	; 0x15fe <read_VIT+0xd4>
    15ee:	0e 94 45 09 	call	0x128a	; 0x128a <torquer_off.part.0>
    15f2:	05 c0       	rjmp	.+10     	; 0x15fe <read_VIT+0xd4>
						case TORQUER_1:
							torquer_off( TORQUER_1 );
							break;
						case TORQUER_2:
							torquer_off( TORQUER_2 );
    15f4:	82 e1       	ldi	r24, 0x12	; 18
    15f6:	01 c0       	rjmp	.+2      	; 0x15fa <read_VIT+0xd0>
							break;
						case TORQUER_3:
							torquer_off( TORQUER_3 );
    15f8:	83 e1       	ldi	r24, 0x13	; 19
    15fa:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
							break;
						default:
							break;
					}
				}
				component->switch_state = SW_OFF;
    15fe:	1a 82       	std	Y+2, r1	; 0x02
				component->V_critical_value = ADC_high;
    1600:	80 91 63 09 	lds	r24, 0x0963
    1604:	8c 87       	std	Y+12, r24	; 0x0c
			}
			adc_sensor_type = ADC_CURRENT;
    1606:	82 e0       	ldi	r24, 0x02	; 2
    1608:	80 93 52 09 	sts	0x0952, r24

		    //perform next ADC conversion
		    mux_num = component->I_mux_num;
    160c:	1d 85       	ldd	r17, Y+13	; 0x0d
		    mux_sel = component->I_mux_sel;
		    set_mux_sel( mux_num, mux_sel );
    160e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1610:	92 c0       	rjmp	.+292    	; 0x1736 <read_VIT+0x20c>
    //-------------------------------------------------------------------
    // Measure current
    //-------------------------------------------------------------------
	  case ADC_CURRENT:
     
	    component = &svit[adc_component];
    1612:	9c e1       	ldi	r25, 0x1C	; 28
    1614:	c9 9f       	mul	r28, r25
    1616:	e0 01       	movw	r28, r0
    1618:	11 24       	eor	r1, r1
    161a:	ca 5c       	subi	r28, 0xCA	; 202
    161c:	dc 4f       	sbci	r29, 0xFC	; 252
	  	sample_index = component->I_sample_index;
	  	component->I_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    161e:	2c 89       	ldd	r18, Y+20	; 0x14
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	c9 01       	movw	r24, r18
    1624:	01 96       	adiw	r24, 0x01	; 1
    1626:	63 e0       	ldi	r22, 0x03	; 3
    1628:	70 e0       	ldi	r23, 0x00	; 0
    162a:	0e 94 a9 14 	call	0x2952	; 0x2952 <__divmodhi4>
    162e:	8c 8b       	std	Y+20, r24	; 0x14
		// SoC hardcode backward current
//		if (adc_component == BATTERY_1_b) {
			//debug = 5;
		//}
		
		if(component->name == SOLAR_1){
    1630:	98 81       	ld	r25, Y
    1632:	97 31       	cpi	r25, 0x17	; 23
    1634:	39 f4       	brne	.+14     	; 0x1644 <read_VIT+0x11a>
			solar1_current = ADC_high;
    1636:	80 91 63 09 	lds	r24, 0x0963
    163a:	80 93 6e 09 	sts	0x096E, r24
			hasCheckedCurr = 1;
    163e:	81 e0       	ldi	r24, 0x01	; 1
    1640:	80 93 57 09 	sts	0x0957, r24
		}

	  	component->I_samples[sample_index] = ADC_high;
    1644:	80 91 63 09 	lds	r24, 0x0963
    1648:	fe 01       	movw	r30, r28
    164a:	e2 0f       	add	r30, r18
    164c:	f3 1f       	adc	r31, r19
    164e:	81 8b       	std	Z+17, r24	; 0x11
    
	    if ( ( ADC_high > component->I_upper_limit ) && ( component->force_on != 1 ) )
    1650:	20 91 63 09 	lds	r18, 0x0963
    1654:	8f 85       	ldd	r24, Y+15	; 0x0f
    1656:	82 17       	cp	r24, r18
    1658:	d8 f4       	brcc	.+54     	; 0x1690 <read_VIT+0x166>
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	81 30       	cpi	r24, 0x01	; 1
    165e:	c1 f0       	breq	.+48     	; 0x1690 <read_VIT+0x166>
	  	{
	  		if ( component->switch_num != SW_NULL )
    1660:	89 81       	ldd	r24, Y+1	; 0x01
    1662:	8f 3f       	cpi	r24, 0xFF	; 255
    1664:	19 f0       	breq	.+6      	; 0x166c <read_VIT+0x142>
	  		{
	  		  switch_off( component->switch_num );
    1666:	0e 94 1b 0a 	call	0x1436	; 0x1436 <switch_off>
    166a:	0e c0       	rjmp	.+28     	; 0x1688 <read_VIT+0x15e>
	  		}
	  		else
	  		{
	  		  switch ( component->name )
    166c:	92 31       	cpi	r25, 0x12	; 18
    166e:	39 f0       	breq	.+14     	; 0x167e <read_VIT+0x154>
    1670:	93 31       	cpi	r25, 0x13	; 19
    1672:	39 f0       	breq	.+14     	; 0x1682 <read_VIT+0x158>
    1674:	91 31       	cpi	r25, 0x11	; 17
    1676:	41 f4       	brne	.+16     	; 0x1688 <read_VIT+0x15e>
    1678:	0e 94 45 09 	call	0x128a	; 0x128a <torquer_off.part.0>
    167c:	05 c0       	rjmp	.+10     	; 0x1688 <read_VIT+0x15e>
		  	  {
  		  		case TORQUER_1:
	  	  		  torquer_off( TORQUER_1 );
		    		  break;
			    	case TORQUER_2:
			  	    torquer_off( TORQUER_2 );
    167e:	82 e1       	ldi	r24, 0x12	; 18
    1680:	01 c0       	rjmp	.+2      	; 0x1684 <read_VIT+0x15a>
			  	    break;
  		  		case TORQUER_3:
	  	  		  torquer_off( TORQUER_3 );
    1682:	83 e1       	ldi	r24, 0x13	; 19
    1684:	0e 94 a1 09 	call	0x1342	; 0x1342 <torquer_off>
		    		  break;
			     	default:
				      break;
			    }
			  }
			  component->switch_state = 0;
    1688:	1a 82       	std	Y+2, r1	; 0x02
        component->I_critical_value = ADC_high;
    168a:	80 91 63 09 	lds	r24, 0x0963
    168e:	8d 8b       	std	Y+21, r24	; 0x15
		  }
      //perform next ADC conversion
      mux_num = component->T_mux_num;
    1690:	1e 89       	ldd	r17, Y+22	; 0x16
      if( mux_num != MUX_NULL )
    1692:	13 30       	cpi	r17, 0x03	; 3
    1694:	29 f0       	breq	.+10     	; 0x16a0 <read_VIT+0x176>
      {
		    adc_sensor_type = ADC_TEMPERATURE;
    1696:	83 e0       	ldi	r24, 0x03	; 3
    1698:	80 93 52 09 	sts	0x0952, r24
        mux_sel = component->T_mux_sel;        
    169c:	6f 89       	ldd	r22, Y+23	; 0x17
    169e:	4b c0       	rjmp	.+150    	; 0x1736 <read_VIT+0x20c>
		  }
      else
      {
        adc_sensor_type = ADC_VOLTAGE;
    16a0:	81 e0       	ldi	r24, 0x01	; 1
    16a2:	80 93 52 09 	sts	0x0952, r24
		    adc_component = ( adc_component + 1 ) % SVIT_SZ;
    16a6:	80 91 35 03 	lds	r24, 0x0335
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	01 96       	adiw	r24, 0x01	; 1
    16ae:	64 e2       	ldi	r22, 0x24	; 36
    16b0:	70 e0       	ldi	r23, 0x00	; 0
    16b2:	0e 94 a9 14 	call	0x2952	; 0x2952 <__divmodhi4>
    16b6:	80 93 35 03 	sts	0x0335, r24
        component = &svit[adc_component];
    16ba:	2c e1       	ldi	r18, 0x1C	; 28
    16bc:	28 9f       	mul	r18, r24
    16be:	f0 01       	movw	r30, r0
    16c0:	29 9f       	mul	r18, r25
    16c2:	f0 0d       	add	r31, r0
    16c4:	11 24       	eor	r1, r1
    16c6:	ea 5c       	subi	r30, 0xCA	; 202
    16c8:	fc 4f       	sbci	r31, 0xFC	; 252
        mux_num = component->V_mux_num;
    16ca:	14 81       	ldd	r17, Z+4	; 0x04
        mux_sel = component->V_mux_sel;
    16cc:	65 81       	ldd	r22, Z+5	; 0x05
    16ce:	33 c0       	rjmp	.+102    	; 0x1736 <read_VIT+0x20c>
      break;
    //-------------------------------------------------------------------
    // Measure temperature
    //-------------------------------------------------------------------
	  case ADC_TEMPERATURE:
		  component = &svit[adc_component];
    16d0:	d0 e0       	ldi	r29, 0x00	; 0
    16d2:	4c e1       	ldi	r20, 0x1C	; 28
    16d4:	4c 9f       	mul	r20, r28
    16d6:	f0 01       	movw	r30, r0
    16d8:	4d 9f       	mul	r20, r29
    16da:	f0 0d       	add	r31, r0
    16dc:	11 24       	eor	r1, r1
    16de:	ea 5c       	subi	r30, 0xCA	; 202
    16e0:	fc 4f       	sbci	r31, 0xFC	; 252
		  sample_index = component->T_sample_index;
		  component->T_sample_index = ( sample_index + 1 ) % NUM_SAMPLES;
    16e2:	23 8d       	ldd	r18, Z+27	; 0x1b
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	c9 01       	movw	r24, r18
    16e8:	01 96       	adiw	r24, 0x01	; 1
    16ea:	63 e0       	ldi	r22, 0x03	; 3
    16ec:	70 e0       	ldi	r23, 0x00	; 0
    16ee:	0e 94 a9 14 	call	0x2952	; 0x2952 <__divmodhi4>
    16f2:	83 8f       	std	Z+27, r24	; 0x1b
		  component->T_samples[sample_index] = ADC_high;
    16f4:	80 91 63 09 	lds	r24, 0x0963
    16f8:	e2 0f       	add	r30, r18
    16fa:	f3 1f       	adc	r31, r19
    16fc:	80 8f       	std	Z+24, r24	; 0x18
      //perform next ADC conversion
  	  adc_sensor_type = ADC_VOLTAGE;
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	80 93 52 09 	sts	0x0952, r24
		  adc_component = ( adc_component + 1 ) % SVIT_SZ;
    1704:	ce 01       	movw	r24, r28
    1706:	01 96       	adiw	r24, 0x01	; 1
    1708:	64 e2       	ldi	r22, 0x24	; 36
    170a:	70 e0       	ldi	r23, 0x00	; 0
    170c:	0e 94 a9 14 	call	0x2952	; 0x2952 <__divmodhi4>
    1710:	80 93 35 03 	sts	0x0335, r24
      component = &svit[adc_component];
    1714:	48 9f       	mul	r20, r24
    1716:	f0 01       	movw	r30, r0
    1718:	49 9f       	mul	r20, r25
    171a:	f0 0d       	add	r31, r0
    171c:	11 24       	eor	r1, r1
    171e:	1d c0       	rjmp	.+58     	; 0x175a <read_VIT+0x230>
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
		  break;
    case ADC_INIT:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	80 93 52 09 	sts	0x0952, r24
      component = &svit[adc_component];
    1726:	9c e1       	ldi	r25, 0x1C	; 28
    1728:	c9 9f       	mul	r28, r25
    172a:	e0 01       	movw	r28, r0
    172c:	11 24       	eor	r1, r1
    172e:	ca 5c       	subi	r28, 0xCA	; 202
    1730:	dc 4f       	sbci	r29, 0xFC	; 252
      mux_num = component->V_mux_num;
    1732:	1c 81       	ldd	r17, Y+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1734:	6d 81       	ldd	r22, Y+5	; 0x05
    1736:	81 2f       	mov	r24, r17
    1738:	0e 94 4c 09 	call	0x1298	; 0x1298 <set_mux_sel>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    173c:	83 e3       	ldi	r24, 0x33	; 51
    173e:	93 e7       	ldi	r25, 0x73	; 115
    1740:	01 97       	sbiw	r24, 0x01	; 1
    1742:	f1 f7       	brne	.-4      	; 0x1740 <read_VIT+0x216>
      //_delay_us(1);
	  //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
      perform_ADC( mux_num );
    1744:	81 2f       	mov	r24, r17
    1746:	15 c0       	rjmp	.+42     	; 0x1772 <read_VIT+0x248>
      break;
	  default:
      //perform next ADC conversion
		  adc_sensor_type = ADC_VOLTAGE;
    1748:	81 e0       	ldi	r24, 0x01	; 1
    174a:	80 93 52 09 	sts	0x0952, r24
      component = &svit[adc_component];
    174e:	e0 91 35 03 	lds	r30, 0x0335
    1752:	9c e1       	ldi	r25, 0x1C	; 28
    1754:	e9 9f       	mul	r30, r25
    1756:	f0 01       	movw	r30, r0
    1758:	11 24       	eor	r1, r1
    175a:	ea 5c       	subi	r30, 0xCA	; 202
    175c:	fc 4f       	sbci	r31, 0xFC	; 252
      mux_num = component->V_mux_num;
    175e:	c4 81       	ldd	r28, Z+4	; 0x04
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
    1760:	65 81       	ldd	r22, Z+5	; 0x05
    1762:	8c 2f       	mov	r24, r28
    1764:	0e 94 4c 09 	call	0x1298	; 0x1298 <set_mux_sel>
    1768:	83 e3       	ldi	r24, 0x33	; 51
    176a:	93 e7       	ldi	r25, 0x73	; 115
    176c:	01 97       	sbiw	r24, 0x01	; 1
    176e:	f1 f7       	brne	.-4      	; 0x176c <read_VIT+0x242>
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1770:	8c 2f       	mov	r24, r28
      break;
  } 
}
    1772:	df 91       	pop	r29
    1774:	cf 91       	pop	r28
    1776:	1f 91       	pop	r17
      mux_sel = component->V_mux_sel;
      set_mux_sel( mux_num, mux_sel );
      //_delay_us(1);
      //_delay_us(6000);
	  _delay_ms(ADC_DELAY_MS);
	  perform_ADC( mux_num );
    1778:	0c 94 8b 0a 	jmp	0x1516	; 0x1516 <perform_ADC>

0000177c <uart_init>:
{
  #if F_CPU < 2000000UL && defined(U2X)
  UCSR0A = UCSR1A = _BV(U2X); /* improve baud rate error by using 2x clk */
  UBRR0L = UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  #else
  UBRR0L = UBRR1L = 7;//(F_CPU / (16UL * UART_BAUD)) - 1;//7;
    177c:	87 e0       	ldi	r24, 0x07	; 7
    177e:	80 93 99 00 	sts	0x0099, r24
    1782:	89 b9       	out	0x09, r24	; 9
  #endif
  UCSR0B = _BV(TXEN0) | _BV(RXEN0); /* tx/rx enable */
    1784:	88 e1       	ldi	r24, 0x18	; 24
    1786:	8a b9       	out	0x0a, r24	; 10
  UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
    1788:	ea e9       	ldi	r30, 0x9A	; 154
    178a:	f0 e0       	ldi	r31, 0x00	; 0
    178c:	80 83       	st	Z, r24


  UCSR1B = UCSR1B | _BV(TXCIE1);
    178e:	80 81       	ld	r24, Z
    1790:	80 64       	ori	r24, 0x40	; 64
    1792:	80 83       	st	Z, r24
  UCSR1B = UCSR1B | _BV(RXCIE1);
    1794:	80 81       	ld	r24, Z
    1796:	80 68       	ori	r24, 0x80	; 128
    1798:	80 83       	st	Z, r24
  UCSR0B = UCSR0B | _BV(TXCIE0);
    179a:	56 9a       	sbi	0x0a, 6	; 10
  UCSR0B = UCSR0B | _BV(RXCIE0);
    179c:	57 9a       	sbi	0x0a, 7	; 10
    179e:	08 95       	ret

000017a0 <append_crc16>:
 * Adds a byte of data into the crc calculation using
 * the table above.
 */
void append_crc16(uint8 byte, uint16ptr crc)
{
	*crc = ((*crc) >> 8) ^ ccitt_crc16[((*crc) ^ (byte)) & 0xff];
    17a0:	fb 01       	movw	r30, r22
    17a2:	20 81       	ld	r18, Z
    17a4:	31 81       	ldd	r19, Z+1	; 0x01
    17a6:	f9 01       	movw	r30, r18
    17a8:	e8 27       	eor	r30, r24
    17aa:	ff 27       	eor	r31, r31
    17ac:	ee 0f       	add	r30, r30
    17ae:	ff 1f       	adc	r31, r31
    17b0:	ea 5f       	subi	r30, 0xFA	; 250
    17b2:	fe 4f       	sbci	r31, 0xFE	; 254
    17b4:	23 2f       	mov	r18, r19
    17b6:	33 27       	eor	r19, r19
    17b8:	80 81       	ld	r24, Z
    17ba:	91 81       	ldd	r25, Z+1	; 0x01
    17bc:	82 27       	eor	r24, r18
    17be:	93 27       	eor	r25, r19
    17c0:	fb 01       	movw	r30, r22
    17c2:	91 83       	std	Z+1, r25	; 0x01
    17c4:	80 83       	st	Z, r24
    17c6:	08 95       	ret

000017c8 <vcpptr_init>:
// Parameters: 
// vcp_ptrbuffer	*buff -					Pointer to the vcp buffer structure
// uint8			*message_buffer -		Pointer to the allocated data buffer
// uint16			message_buffer_size -	Size of the allocated data buffer
void vcpptr_init(vcp_ptrbuffer *buff, uint8 *message_buffer, uint16 message_buffer_size)
{
    17c8:	fc 01       	movw	r30, r24
	buff->address =	0;
    17ca:	10 82       	st	Z, r1
	buff->message =	message_buffer;
    17cc:	72 83       	std	Z+2, r23	; 0x02
    17ce:	61 83       	std	Z+1, r22	; 0x01
	buff->size =	message_buffer_size;
    17d0:	56 83       	std	Z+6, r21	; 0x06
    17d2:	45 83       	std	Z+5, r20	; 0x05
	buff->index	=	0;
    17d4:	10 86       	std	Z+8, r1	; 0x08
    17d6:	17 82       	std	Z+7, r1	; 0x07
	buff->crc =		CRC16_INIT_VALUE;
    17d8:	14 82       	std	Z+4, r1	; 0x04
    17da:	13 82       	std	Z+3, r1	; 0x03
	buff->status =	VCP_IDLE;
    17dc:	11 86       	std	Z+9, r1	; 0x09
    17de:	08 95       	ret

000017e0 <Create_VCP_frame>:
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
{
    17e0:	4f 92       	push	r4
    17e2:	5f 92       	push	r5
    17e4:	6f 92       	push	r6
    17e6:	7f 92       	push	r7
    17e8:	8f 92       	push	r8
    17ea:	9f 92       	push	r9
    17ec:	af 92       	push	r10
    17ee:	bf 92       	push	r11
    17f0:	cf 92       	push	r12
    17f2:	df 92       	push	r13
    17f4:	ef 92       	push	r14
    17f6:	ff 92       	push	r15
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	00 d0       	rcall	.+0      	; 0x1802 <Create_VCP_frame+0x22>
    1802:	1f 92       	push	r1
    1804:	cd b7       	in	r28, 0x3d	; 61
    1806:	de b7       	in	r29, 0x3e	; 62
    1808:	6c 01       	movw	r12, r24
    180a:	5b 01       	movw	r10, r22
    180c:	79 01       	movw	r14, r18
	uint16_t crc = CRC16_INIT_VALUE;
    180e:	1a 82       	std	Y+2, r1	; 0x02
    1810:	19 82       	std	Y+1, r1	; 0x01
	uint16_t src_index = 0;
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
    1812:	00 97       	sbiw	r24, 0x00	; 0
    1814:	09 f4       	brne	.+2      	; 0x1818 <Create_VCP_frame+0x38>
    1816:	58 c0       	rjmp	.+176    	; 0x18c8 <Create_VCP_frame+0xe8>
    1818:	21 15       	cp	r18, r1
    181a:	31 05       	cpc	r19, r1
    181c:	09 f4       	brne	.+2      	; 0x1820 <Create_VCP_frame+0x40>
    181e:	54 c0       	rjmp	.+168    	; 0x18c8 <Create_VCP_frame+0xe8>
		return VCP_NULL_ERR;

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
    1820:	4c 30       	cpi	r20, 0x0C	; 12
    1822:	18 f0       	brcs	.+6      	; 0x182a <Create_VCP_frame+0x4a>
    1824:	48 33       	cpi	r20, 0x38	; 56
    1826:	09 f0       	breq	.+2      	; 0x182a <Create_VCP_frame+0x4a>
    1828:	51 c0       	rjmp	.+162    	; 0x18cc <Create_VCP_frame+0xec>
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);
    182a:	44 24       	eor	r4, r4
    182c:	43 94       	inc	r4
    182e:	51 2c       	mov	r5, r1
    1830:	4c 0e       	add	r4, r28
    1832:	5d 1e       	adc	r5, r29
    1834:	b2 01       	movw	r22, r4
    1836:	84 2f       	mov	r24, r20
    1838:	4b 83       	std	Y+3, r20	; 0x03
    183a:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <append_crc16>
// uint8ptr		dst -		Pointer to the destination buffer
// uint16ptr	dst_size -	Pointer to the destination size. This will contain the frame size after the function exits.
// uint8		addr -		Source peripheral VCP address 
// uint8ptr		src -		Pointer to the source buffer
// uint16		src_size -	Source size
uint8_t Create_VCP_frame(uint8ptr dst, uint16_t* dst_size, uint8 addr, uint8ptr src, uint16 src_size)
    183e:	37 01       	movw	r6, r14
    1840:	60 0e       	add	r6, r16
    1842:	71 1e       	adc	r7, r17
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1844:	47 01       	movw	r8, r14
    1846:	07 c0       	rjmp	.+14     	; 0x1856 <Create_VCP_frame+0x76>
	  append_crc16(src[src_index], &crc);
    1848:	b2 01       	movw	r22, r4
    184a:	f4 01       	movw	r30, r8
    184c:	81 91       	ld	r24, Z+
    184e:	4f 01       	movw	r8, r30
    1850:	4b 83       	std	Y+3, r20	; 0x03
    1852:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <append_crc16>
    1856:	4b 81       	ldd	r20, Y+3	; 0x03
		return VCP_ADDR_ERR;
		
	// Calculate CRC:
	append_crc16(addr, &crc);

	for (src_index = 0; src_index < src_size; src_index++)
    1858:	86 14       	cp	r8, r6
    185a:	97 04       	cpc	r9, r7
    185c:	a9 f7       	brne	.-22     	; 0x1848 <Create_VCP_frame+0x68>
	  append_crc16(src[src_index], &crc);
	
	// Add CRC to the end of the source buffer
	src[src_index++] = ((crc >> 8) & 0xFF);
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	f7 01       	movw	r30, r14
    1864:	e0 0f       	add	r30, r16
    1866:	f1 1f       	adc	r31, r17
    1868:	90 83       	st	Z, r25
	src[src_index++] = (crc & 0xFF);
    186a:	81 83       	std	Z+1, r24	; 0x01
    186c:	0e 5f       	subi	r16, 0xFE	; 254
    186e:	1f 4f       	sbci	r17, 0xFF	; 255
	payload_size = src_index;
	
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
    1870:	80 ec       	ldi	r24, 0xC0	; 192
    1872:	f6 01       	movw	r30, r12
    1874:	80 83       	st	Z, r24
	// then insert VCP address
	dst[dst_index++] =					addr;
    1876:	41 83       	std	Z+1, r20	; 0x01
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1878:	d7 01       	movw	r26, r14
	// Build KISS Frame:
	
	// Start the frame with FEND
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
    187a:	42 e0       	ldi	r20, 0x02	; 2
    187c:	50 e0       	ldi	r21, 0x00	; 0
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    187e:	2d ed       	ldi	r18, 0xDD	; 221
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
	{
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
    1880:	3b ed       	ldi	r19, 0xDB	; 219
			dst[dst_index++] =			TFEND;
    1882:	6c ed       	ldi	r22, 0xDC	; 220
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    1884:	0f c0       	rjmp	.+30     	; 0x18a4 <Create_VCP_frame+0xc4>
	{
		if (src[src_index] == FEND)
    1886:	8d 91       	ld	r24, X+
    1888:	80 3c       	cpi	r24, 0xC0	; 192
    188a:	19 f4       	brne	.+6      	; 0x1892 <Create_VCP_frame+0xb2>
		{
			dst[dst_index++] =			FESC;
    188c:	30 83       	st	Z, r19
			dst[dst_index++] =			TFEND;
    188e:	61 83       	std	Z+1, r22	; 0x01
    1890:	04 c0       	rjmp	.+8      	; 0x189a <Create_VCP_frame+0xba>
		}
		else if (src[src_index] == FESC)
		{
			dst[dst_index++] =			FESC;
    1892:	80 83       	st	Z, r24
		if (src[src_index] == FEND)
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFEND;
		}
		else if (src[src_index] == FESC)
    1894:	8b 3d       	cpi	r24, 0xDB	; 219
    1896:	21 f4       	brne	.+8      	; 0x18a0 <Create_VCP_frame+0xc0>
		{
			dst[dst_index++] =			FESC;
			dst[dst_index++] =			TFESC;
    1898:	21 83       	std	Z+1, r18	; 0x01
    189a:	4e 5f       	subi	r20, 0xFE	; 254
    189c:	5f 4f       	sbci	r21, 0xFF	; 255
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <Create_VCP_frame+0xc4>
		}
		else
		{
			dst[dst_index++] =			src[src_index];
    18a0:	4f 5f       	subi	r20, 0xFF	; 255
    18a2:	5f 4f       	sbci	r21, 0xFF	; 255
	dst[dst_index++] =					FEND;
	// then insert VCP address
	dst[dst_index++] =					addr;
	
	// Copy src to dst and Escape when necessary
	for (src_index = 0; src_index < payload_size; src_index++ )
    18a4:	cd 01       	movw	r24, r26
    18a6:	8e 19       	sub	r24, r14
    18a8:	9f 09       	sbc	r25, r15
    18aa:	f6 01       	movw	r30, r12
    18ac:	e4 0f       	add	r30, r20
    18ae:	f5 1f       	adc	r31, r21
    18b0:	80 17       	cp	r24, r16
    18b2:	91 07       	cpc	r25, r17
    18b4:	40 f3       	brcs	.-48     	; 0x1886 <Create_VCP_frame+0xa6>
		//if (dst_index >= *dst_size - 1)
			//return VCP_OVR_ERR;
	}
	
	// End the frame with FEND
	dst[dst_index++] =					FEND;
    18b6:	80 ec       	ldi	r24, 0xC0	; 192
    18b8:	80 83       	st	Z, r24
    18ba:	4f 5f       	subi	r20, 0xFF	; 255
    18bc:	5f 4f       	sbci	r21, 0xFF	; 255
	
	// Save the frame size
	*dst_size = dst_index;
    18be:	f5 01       	movw	r30, r10
    18c0:	51 83       	std	Z+1, r21	; 0x01
    18c2:	40 83       	st	Z, r20
	
	// All good
	return VCP_TERM;
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	03 c0       	rjmp	.+6      	; 0x18ce <Create_VCP_frame+0xee>
	uint16_t dst_index = 0;
	uint16_t payload_size;
	
	// Check for invalid buffers
	if (dst == NULL || src == NULL)
		return VCP_NULL_ERR;
    18c8:	85 e0       	ldi	r24, 0x05	; 5
    18ca:	01 c0       	rjmp	.+2      	; 0x18ce <Create_VCP_frame+0xee>

	// Check for invalid VCP address	
	if (addr > VCP_FC && addr != VCP_SUN_SENSOR)
		return VCP_ADDR_ERR;
    18cc:	86 e0       	ldi	r24, 0x06	; 6
	// Save the frame size
	*dst_size = dst_index;
	
	// All good
	return VCP_TERM;
}
    18ce:	0f 90       	pop	r0
    18d0:	0f 90       	pop	r0
    18d2:	0f 90       	pop	r0
    18d4:	df 91       	pop	r29
    18d6:	cf 91       	pop	r28
    18d8:	1f 91       	pop	r17
    18da:	0f 91       	pop	r16
    18dc:	ff 90       	pop	r15
    18de:	ef 90       	pop	r14
    18e0:	df 90       	pop	r13
    18e2:	cf 90       	pop	r12
    18e4:	bf 90       	pop	r11
    18e6:	af 90       	pop	r10
    18e8:	9f 90       	pop	r9
    18ea:	8f 90       	pop	r8
    18ec:	7f 90       	pop	r7
    18ee:	6f 90       	pop	r6
    18f0:	5f 90       	pop	r5
    18f2:	4f 90       	pop	r4
    18f4:	08 95       	ret

000018f6 <Receive_VCP_byte>:
// and return VCP status.
// Parameters:
// vcp_ptrbuffer	*buff -	Pointer to the vcp buffer structure
// uint8			byte -	received byte
uint8_t Receive_VCP_byte(vcp_ptrbuffer *buff, uint8 byte)
{
    18f6:	cf 92       	push	r12
    18f8:	df 92       	push	r13
    18fa:	ef 92       	push	r14
    18fc:	ff 92       	push	r15
    18fe:	0f 93       	push	r16
    1900:	1f 93       	push	r17
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	ec 01       	movw	r28, r24
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
    1908:	29 81       	ldd	r18, Y+1	; 0x01
    190a:	3a 81       	ldd	r19, Y+2	; 0x02
    190c:	21 15       	cp	r18, r1
    190e:	31 05       	cpc	r19, r1
    1910:	09 f4       	brne	.+2      	; 0x1914 <Receive_VCP_byte+0x1e>
    1912:	84 c0       	rjmp	.+264    	; 0x1a1c <Receive_VCP_byte+0x126>
		return VCP_NULL_ERR;
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
    1914:	8f 81       	ldd	r24, Y+7	; 0x07
    1916:	98 85       	ldd	r25, Y+8	; 0x08
    1918:	4d 81       	ldd	r20, Y+5	; 0x05
    191a:	5e 81       	ldd	r21, Y+6	; 0x06
    191c:	41 50       	subi	r20, 0x01	; 1
    191e:	51 09       	sbc	r21, r1
    1920:	84 17       	cp	r24, r20
    1922:	95 07       	cpc	r25, r21
    1924:	08 f0       	brcs	.+2      	; 0x1928 <Receive_VCP_byte+0x32>
    1926:	7c c0       	rjmp	.+248    	; 0x1a20 <Receive_VCP_byte+0x12a>
		return VCP_OVR_ERR;
	
	// State Machine
	switch (buff->status)
    1928:	49 85       	ldd	r20, Y+9	; 0x09
    192a:	42 30       	cpi	r20, 0x02	; 2
    192c:	39 f1       	breq	.+78     	; 0x197c <Receive_VCP_byte+0x86>
    192e:	18 f4       	brcc	.+6      	; 0x1936 <Receive_VCP_byte+0x40>
    1930:	44 23       	and	r20, r20
    1932:	31 f0       	breq	.+12     	; 0x1940 <Receive_VCP_byte+0x4a>
    1934:	38 c0       	rjmp	.+112    	; 0x19a6 <Receive_VCP_byte+0xb0>
    1936:	40 31       	cpi	r20, 0x10	; 16
    1938:	31 f0       	breq	.+12     	; 0x1946 <Receive_VCP_byte+0x50>
    193a:	40 32       	cpi	r20, 0x20	; 32
    193c:	a1 f5       	brne	.+104    	; 0x19a6 <Receive_VCP_byte+0xb0>
    193e:	0a c0       	rjmp	.+20     	; 0x1954 <Receive_VCP_byte+0x5e>
	{
		case VCP_IDLE:										
			if (byte == FEND)
    1940:	60 3c       	cpi	r22, 0xC0	; 192
    1942:	91 f5       	brne	.+100    	; 0x19a8 <Receive_VCP_byte+0xb2>
    1944:	0d c0       	rjmp	.+26     	; 0x1960 <Receive_VCP_byte+0x6a>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
    1946:	6c 30       	cpi	r22, 0x0C	; 12
    1948:	18 f0       	brcs	.+6      	; 0x1950 <Receive_VCP_byte+0x5a>
    194a:	68 33       	cpi	r22, 0x38	; 56
    194c:	09 f0       	breq	.+2      	; 0x1950 <Receive_VCP_byte+0x5a>
    194e:	6a c0       	rjmp	.+212    	; 0x1a24 <Receive_VCP_byte+0x12e>
				return VCP_ADDR_ERR;
			else
			{
				buff->address = byte;
    1950:	68 83       	st	Y, r22
    1952:	26 c0       	rjmp	.+76     	; 0x19a0 <Receive_VCP_byte+0xaa>
				buff->status = VCP_RECEIVING;
			}	
			break;
		case VCP_RECEIVING:
			if (byte == FEND)
    1954:	60 3c       	cpi	r22, 0xC0	; 192
    1956:	31 f4       	brne	.+12     	; 0x1964 <Receive_VCP_byte+0x6e>
			{
				if (buff->index > 0)
    1958:	89 2b       	or	r24, r25
    195a:	11 f0       	breq	.+4      	; 0x1960 <Receive_VCP_byte+0x6a>
					// Done
					buff->status = VCP_TERM;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	21 c0       	rjmp	.+66     	; 0x19a2 <Receive_VCP_byte+0xac>
				else
					// No data between FENDs - assume lost sync and start over
					buff->status = VCP_ADDRESS;
    1960:	80 e1       	ldi	r24, 0x10	; 16
    1962:	1f c0       	rjmp	.+62     	; 0x19a2 <Receive_VCP_byte+0xac>
			}
			else if (byte == FESC)
    1964:	6b 3d       	cpi	r22, 0xDB	; 219
    1966:	11 f4       	brne	.+4      	; 0x196c <Receive_VCP_byte+0x76>
				buff->status = VCP_ESC;
    1968:	82 e0       	ldi	r24, 0x02	; 2
    196a:	1b c0       	rjmp	.+54     	; 0x19a2 <Receive_VCP_byte+0xac>
			else
			{
				buff->message[(buff->index)++] = byte;	
    196c:	f9 01       	movw	r30, r18
    196e:	e8 0f       	add	r30, r24
    1970:	f9 1f       	adc	r31, r25
    1972:	60 83       	st	Z, r22
    1974:	01 96       	adiw	r24, 0x01	; 1
    1976:	98 87       	std	Y+8, r25	; 0x08
    1978:	8f 83       	std	Y+7, r24	; 0x07
    197a:	16 c0       	rjmp	.+44     	; 0x19a8 <Receive_VCP_byte+0xb2>
			}						
			break;
		case VCP_ESC:
			if (byte == TFEND)
    197c:	6c 3d       	cpi	r22, 0xDC	; 220
    197e:	29 f4       	brne	.+10     	; 0x198a <Receive_VCP_byte+0x94>
			{
				buff->message[(buff->index)++] = FEND;
    1980:	f9 01       	movw	r30, r18
    1982:	e8 0f       	add	r30, r24
    1984:	f9 1f       	adc	r31, r25
    1986:	40 ec       	ldi	r20, 0xC0	; 192
    1988:	07 c0       	rjmp	.+14     	; 0x1998 <Receive_VCP_byte+0xa2>
				buff->status = VCP_RECEIVING;
			}
			else if (byte == TFESC)
    198a:	6d 3d       	cpi	r22, 0xDD	; 221
    198c:	09 f0       	breq	.+2      	; 0x1990 <Receive_VCP_byte+0x9a>
    198e:	4c c0       	rjmp	.+152    	; 0x1a28 <Receive_VCP_byte+0x132>
			{
				buff->message[(buff->index)++] = FESC;
    1990:	f9 01       	movw	r30, r18
    1992:	e8 0f       	add	r30, r24
    1994:	f9 1f       	adc	r31, r25
    1996:	4b ed       	ldi	r20, 0xDB	; 219
    1998:	40 83       	st	Z, r20
    199a:	01 96       	adiw	r24, 0x01	; 1
    199c:	98 87       	std	Y+8, r25	; 0x08
    199e:	8f 83       	std	Y+7, r24	; 0x07
				buff->status = VCP_RECEIVING;
    19a0:	80 e2       	ldi	r24, 0x20	; 32
    19a2:	89 87       	std	Y+9, r24	; 0x09
    19a4:	01 c0       	rjmp	.+2      	; 0x19a8 <Receive_VCP_byte+0xb2>
			}
			else
				return VCP_ESC_ERR;	
			break;
		default:
			buff->status = VCP_IDLE;
    19a6:	19 86       	std	Y+9, r1	; 0x09
			break; 
	}
	
	// End of frame
	if (buff->status == VCP_TERM)
    19a8:	89 85       	ldd	r24, Y+9	; 0x09
    19aa:	81 30       	cpi	r24, 0x01	; 1
    19ac:	11 f0       	breq	.+4      	; 0x19b2 <Receive_VCP_byte+0xbc>
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
    19ae:	89 85       	ldd	r24, Y+9	; 0x09
    19b0:	3c c0       	rjmp	.+120    	; 0x1a2a <Receive_VCP_byte+0x134>
	
	// End of frame
	if (buff->status == VCP_TERM)
	{
		// Message CRC is last 2 bytes 
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
    19b2:	89 81       	ldd	r24, Y+1	; 0x01
    19b4:	9a 81       	ldd	r25, Y+2	; 0x02
    19b6:	4f 81       	ldd	r20, Y+7	; 0x07
    19b8:	58 85       	ldd	r21, Y+8	; 0x08
    19ba:	84 0f       	add	r24, r20
    19bc:	95 1f       	adc	r25, r21
    19be:	fc 01       	movw	r30, r24
    19c0:	32 97       	sbiw	r30, 0x02	; 2
    19c2:	30 81       	ld	r19, Z
    19c4:	20 e0       	ldi	r18, 0x00	; 0
    19c6:	fc 01       	movw	r30, r24
    19c8:	31 97       	sbiw	r30, 0x01	; 1
    19ca:	80 81       	ld	r24, Z
    19cc:	69 01       	movw	r12, r18
    19ce:	c8 0e       	add	r12, r24
    19d0:	d1 1c       	adc	r13, r1
		// Remove CRC bytes from the message
		buff->index -= 2;
    19d2:	42 50       	subi	r20, 0x02	; 2
    19d4:	51 09       	sbc	r21, r1
    19d6:	58 87       	std	Y+8, r21	; 0x08
    19d8:	4f 83       	std	Y+7, r20	; 0x07
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
    19da:	7e 01       	movw	r14, r28
    19dc:	83 e0       	ldi	r24, 0x03	; 3
    19de:	e8 0e       	add	r14, r24
    19e0:	f1 1c       	adc	r15, r1
    19e2:	b7 01       	movw	r22, r14
    19e4:	88 81       	ld	r24, Y
    19e6:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <append_crc16>
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    19ea:	00 e0       	ldi	r16, 0x00	; 0
    19ec:	10 e0       	ldi	r17, 0x00	; 0
    19ee:	0a c0       	rjmp	.+20     	; 0x1a04 <Receive_VCP_byte+0x10e>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
    19f0:	e9 81       	ldd	r30, Y+1	; 0x01
    19f2:	fa 81       	ldd	r31, Y+2	; 0x02
    19f4:	e0 0f       	add	r30, r16
    19f6:	f1 1f       	adc	r31, r17
    19f8:	b7 01       	movw	r22, r14
    19fa:	80 81       	ld	r24, Z
    19fc:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <append_crc16>
		message_crc = (buff->message[buff->index-2] << 8 ) + buff->message[buff->index-1];
		// Remove CRC bytes from the message
		buff->index -= 2;
		// Calculate CRC on received message (including address)
		append_crc16(buff->address, &(buff->crc));
		for (payload_index = 0; payload_index < buff->index; payload_index++)
    1a00:	0f 5f       	subi	r16, 0xFF	; 255
    1a02:	1f 4f       	sbci	r17, 0xFF	; 255
    1a04:	8f 81       	ldd	r24, Y+7	; 0x07
    1a06:	98 85       	ldd	r25, Y+8	; 0x08
    1a08:	08 17       	cp	r16, r24
    1a0a:	19 07       	cpc	r17, r25
    1a0c:	88 f3       	brcs	.-30     	; 0x19f0 <Receive_VCP_byte+0xfa>
		{
			append_crc16(buff->message[payload_index], &buff->crc);
		}
		// Check Calculated CRC against Received CRC
		if (buff->crc != message_crc)
    1a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a10:	9c 81       	ldd	r25, Y+4	; 0x04
    1a12:	8c 15       	cp	r24, r12
    1a14:	9d 05       	cpc	r25, r13
    1a16:	59 f2       	breq	.-106    	; 0x19ae <Receive_VCP_byte+0xb8>
			return VCP_CRC_ERR;
    1a18:	84 e0       	ldi	r24, 0x04	; 4
    1a1a:	07 c0       	rjmp	.+14     	; 0x1a2a <Receive_VCP_byte+0x134>
	uint16_t payload_index;
	uint16_t message_crc;
	
	// Check for invalid buffer
	if (buff->message == NULL)
		return VCP_NULL_ERR;
    1a1c:	85 e0       	ldi	r24, 0x05	; 5
    1a1e:	05 c0       	rjmp	.+10     	; 0x1a2a <Receive_VCP_byte+0x134>
	
	// Check if the buffer will overflow
	if (buff->index >= buff->size-1)
		return VCP_OVR_ERR;
    1a20:	83 e0       	ldi	r24, 0x03	; 3
    1a22:	03 c0       	rjmp	.+6      	; 0x1a2a <Receive_VCP_byte+0x134>
				buff->status = VCP_ADDRESS;	
			break;
		case VCP_ADDRESS:
			// Check for invalid VCP address
			if (byte > VCP_FC && byte != VCP_SUN_SENSOR)
				return VCP_ADDR_ERR;
    1a24:	86 e0       	ldi	r24, 0x06	; 6
    1a26:	01 c0       	rjmp	.+2      	; 0x1a2a <Receive_VCP_byte+0x134>
			{
				buff->message[(buff->index)++] = FESC;
				buff->status = VCP_RECEIVING;
			}
			else
				return VCP_ESC_ERR;	
    1a28:	87 e0       	ldi	r24, 0x07	; 7
		if (buff->crc != message_crc)
			return VCP_CRC_ERR;
	}

	return buff->status;
}
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	ff 90       	pop	r15
    1a34:	ef 90       	pop	r14
    1a36:	df 90       	pop	r13
    1a38:	cf 90       	pop	r12
    1a3a:	08 95       	ret

00001a3c <tx_put_byte.part.0>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    return;
  if( tel_packet_index[uart] < tel_packet_size[uart] )
    1a3c:	28 2f       	mov	r18, r24
    1a3e:	30 e0       	ldi	r19, 0x00	; 0
    1a40:	f9 01       	movw	r30, r18
    1a42:	e1 5c       	subi	r30, 0xC1	; 193
    1a44:	f8 4f       	sbci	r31, 0xF8	; 248
    1a46:	60 81       	ld	r22, Z
    1a48:	d9 01       	movw	r26, r18
    1a4a:	aa 0f       	add	r26, r26
    1a4c:	bb 1f       	adc	r27, r27
    1a4e:	a9 5d       	subi	r26, 0xD9	; 217
    1a50:	bc 4f       	sbci	r27, 0xFC	; 252
    1a52:	4d 91       	ld	r20, X+
    1a54:	5c 91       	ld	r21, X
    1a56:	70 e0       	ldi	r23, 0x00	; 0
    1a58:	64 17       	cp	r22, r20
    1a5a:	75 07       	cpc	r23, r21
    1a5c:	10 f5       	brcc	.+68     	; 0x1aa2 <tx_put_byte.part.0+0x66>
  {
      if ( uart == 0 )
    1a5e:	81 11       	cpse	r24, r1
    1a60:	0e c0       	rjmp	.+28     	; 0x1a7e <tx_put_byte.part.0+0x42>
      UDR0 = tel_packet[uart][tel_packet_index[uart]++];
    1a62:	80 81       	ld	r24, Z
    1a64:	9f ef       	ldi	r25, 0xFF	; 255
    1a66:	92 9f       	mul	r25, r18
    1a68:	d0 01       	movw	r26, r0
    1a6a:	93 9f       	mul	r25, r19
    1a6c:	b0 0d       	add	r27, r0
    1a6e:	11 24       	eor	r1, r1
    1a70:	a8 0f       	add	r26, r24
    1a72:	b1 1d       	adc	r27, r1
    1a74:	aa 5b       	subi	r26, 0xBA	; 186
    1a76:	b8 4f       	sbci	r27, 0xF8	; 248
    1a78:	9c 91       	ld	r25, X
    1a7a:	9c b9       	out	0x0c, r25	; 12
    1a7c:	10 c0       	rjmp	.+32     	; 0x1a9e <tx_put_byte.part.0+0x62>
    else if ( uart == 1 )
    1a7e:	81 30       	cpi	r24, 0x01	; 1
    1a80:	81 f4       	brne	.+32     	; 0x1aa2 <tx_put_byte.part.0+0x66>
      UDR1 = tel_packet[uart][tel_packet_index[uart]++];
    1a82:	80 81       	ld	r24, Z
    1a84:	9f ef       	ldi	r25, 0xFF	; 255
    1a86:	92 9f       	mul	r25, r18
    1a88:	d0 01       	movw	r26, r0
    1a8a:	93 9f       	mul	r25, r19
    1a8c:	b0 0d       	add	r27, r0
    1a8e:	11 24       	eor	r1, r1
    1a90:	a8 0f       	add	r26, r24
    1a92:	b1 1d       	adc	r27, r1
    1a94:	aa 5b       	subi	r26, 0xBA	; 186
    1a96:	b8 4f       	sbci	r27, 0xF8	; 248
    1a98:	9c 91       	ld	r25, X
    1a9a:	90 93 9c 00 	sts	0x009C, r25
    1a9e:	8f 5f       	subi	r24, 0xFF	; 255
    1aa0:	80 83       	st	Z, r24
    1aa2:	08 95       	ret

00001aa4 <__vector_15>:
#include "vcp_library.h"
#include "crclib.h"
#include "uart.h"

ISR(TIMER0_COMP_vect)
{
    1aa4:	1f 92       	push	r1
    1aa6:	0f 92       	push	r0
    1aa8:	0f b6       	in	r0, 0x3f	; 63
    1aaa:	0f 92       	push	r0
    1aac:	11 24       	eor	r1, r1
    1aae:	8f 93       	push	r24
    1ab0:	9f 93       	push	r25
  if ( timer0_counter[0] > 0 )
    1ab2:	80 91 76 0b 	lds	r24, 0x0B76
    1ab6:	90 91 77 0b 	lds	r25, 0x0B77
    1aba:	89 2b       	or	r24, r25
    1abc:	49 f0       	breq	.+18     	; 0x1ad0 <__vector_15+0x2c>
    --timer0_counter[0];
    1abe:	80 91 76 0b 	lds	r24, 0x0B76
    1ac2:	90 91 77 0b 	lds	r25, 0x0B77
    1ac6:	01 97       	sbiw	r24, 0x01	; 1
    1ac8:	90 93 77 0b 	sts	0x0B77, r25
    1acc:	80 93 76 0b 	sts	0x0B76, r24
  if ( timer0_counter[1] > 0 )
    1ad0:	80 91 78 0b 	lds	r24, 0x0B78
    1ad4:	90 91 79 0b 	lds	r25, 0x0B79
    1ad8:	89 2b       	or	r24, r25
    1ada:	49 f0       	breq	.+18     	; 0x1aee <__vector_15+0x4a>
    --timer0_counter[1];
    1adc:	80 91 78 0b 	lds	r24, 0x0B78
    1ae0:	90 91 79 0b 	lds	r25, 0x0B79
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	90 93 79 0b 	sts	0x0B79, r25
    1aea:	80 93 78 0b 	sts	0x0B78, r24
	//if (cntr == 0)
	//	PORTC |= 0x01;
	//else
	//	PORTC &= 0xFE;
	//_delay_ms(500);
}
    1aee:	9f 91       	pop	r25
    1af0:	8f 91       	pop	r24
    1af2:	0f 90       	pop	r0
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	0f 90       	pop	r0
    1af8:	1f 90       	pop	r1
    1afa:	18 95       	reti

00001afc <__vector_14>:

/* Timer 1(A) routine */
ISR(TIMER1_OVF_vect/*TIMER1_COMPA_vect*/)		//Handle Radio & Torquer 30 min delays here; handle 10 min CDH-IB no heartbeat restart
{
    1afc:	1f 92       	push	r1
    1afe:	0f 92       	push	r0
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	0f 92       	push	r0
    1b04:	11 24       	eor	r1, r1
    1b06:	0b b6       	in	r0, 0x3b	; 59
    1b08:	0f 92       	push	r0
    1b0a:	2f 93       	push	r18
    1b0c:	3f 93       	push	r19
    1b0e:	4f 93       	push	r20
    1b10:	5f 93       	push	r21
    1b12:	6f 93       	push	r22
    1b14:	7f 93       	push	r23
    1b16:	8f 93       	push	r24
    1b18:	9f 93       	push	r25
    1b1a:	af 93       	push	r26
    1b1c:	bf 93       	push	r27
    1b1e:	cf 93       	push	r28
    1b20:	ef 93       	push	r30
    1b22:	ff 93       	push	r31
	SVIT_t *component;
	
	//Testing
	//PORTC ^= 0xFF;
		
	if (timer1_counter[0] <= 0	  &&     rad_torq_flag){	//provides 30 minute delay			
    1b24:	80 91 9c 0d 	lds	r24, 0x0D9C
    1b28:	90 91 9d 0d 	lds	r25, 0x0D9D
    1b2c:	89 2b       	or	r24, r25
    1b2e:	51 f5       	brne	.+84     	; 0x1b84 <__vector_14+0x88>
    1b30:	80 91 0b 03 	lds	r24, 0x030B
    1b34:	88 23       	and	r24, r24
    1b36:	31 f1       	breq	.+76     	; 0x1b84 <__vector_14+0x88>
	//if ( receive_flag == 1){		//If message is received, reset timer1_counter[0] to CYCLE_COUNTER
	    timer1_counter[0] = 480; //CYCLE_COUNTER;
    1b38:	80 ee       	ldi	r24, 0xE0	; 224
    1b3a:	91 e0       	ldi	r25, 0x01	; 1
    1b3c:	90 93 9d 0d 	sts	0x0D9D, r25
    1b40:	80 93 9c 0d 	sts	0x0D9C, r24
		
		beyondDelay = 1;
    1b44:	c1 e0       	ldi	r28, 0x01	; 1
    1b46:	c0 93 a1 0d 	sts	0x0DA1, r28
		component->switch_state = SW_ON;
		*/
		
		//Turn on torque coils			
		component = &svit[TORQUER_1];
		switch_on( component->switch_num );
    1b4a:	80 91 13 05 	lds	r24, 0x0513
    1b4e:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    1b52:	c0 93 14 05 	sts	0x0514, r28
		component = &svit[TORQUER_2];
		switch_on( component->switch_num );
    1b56:	80 91 2f 05 	lds	r24, 0x052F
    1b5a:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    1b5e:	c0 93 30 05 	sts	0x0530, r28
		component = &svit[TORQUER_3];
		switch_on( component->switch_num );
    1b62:	80 91 4b 05 	lds	r24, 0x054B
    1b66:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <switch_on>
		component->switch_state = SW_ON;
    1b6a:	c0 93 4c 05 	sts	0x054C, r28
		torquer_on(TORQUER_1);
    1b6e:	81 e1       	ldi	r24, 0x11	; 17
    1b70:	0e 94 bb 09 	call	0x1376	; 0x1376 <torquer_on>
		torquer_on(TORQUER_2);
    1b74:	82 e1       	ldi	r24, 0x12	; 18
    1b76:	0e 94 bb 09 	call	0x1376	; 0x1376 <torquer_on>
		torquer_on(TORQUER_3);
    1b7a:	83 e1       	ldi	r24, 0x13	; 19
    1b7c:	0e 94 bb 09 	call	0x1376	; 0x1376 <torquer_on>
		
		//PORTC ^= 0x02;	//LED for STK testing
		//PORTC ^= 0x01;
		rad_torq_flag = 0;
    1b80:	10 92 0b 03 	sts	0x030B, r1
		//--timer1_counter[2];
	}
	
	if (timer1_counter[1] <= 0   &&   !cdh_heartbeat_flag){		//If heartbeat timer 1 has expired AND we haven't already ordered a restart
    1b84:	80 91 9e 0d 	lds	r24, 0x0D9E
    1b88:	90 91 9f 0d 	lds	r25, 0x0D9F
    1b8c:	89 2b       	or	r24, r25
    1b8e:	39 f4       	brne	.+14     	; 0x1b9e <__vector_14+0xa2>
    1b90:	80 91 22 03 	lds	r24, 0x0322
    1b94:	81 11       	cpse	r24, r1
    1b96:	03 c0       	rjmp	.+6      	; 0x1b9e <__vector_14+0xa2>
		//Order full component restart
		cdh_heartbeat_flag = 1;
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	80 93 22 03 	sts	0x0322, r24
	}
	
	//else{
		//PORTC ^= 0x01;		//LED for STK testing at PORTC0
		//_delay_ms(500);
		--timer1_counter[0];
    1b9e:	80 91 9c 0d 	lds	r24, 0x0D9C
    1ba2:	90 91 9d 0d 	lds	r25, 0x0D9D
    1ba6:	01 97       	sbiw	r24, 0x01	; 1
    1ba8:	90 93 9d 0d 	sts	0x0D9D, r25
    1bac:	80 93 9c 0d 	sts	0x0D9C, r24
		--timer1_counter[1];
    1bb0:	80 91 9e 0d 	lds	r24, 0x0D9E
    1bb4:	90 91 9f 0d 	lds	r25, 0x0D9F
    1bb8:	01 97       	sbiw	r24, 0x01	; 1
    1bba:	90 93 9f 0d 	sts	0x0D9F, r25
    1bbe:	80 93 9e 0d 	sts	0x0D9E, r24
	//}
}
    1bc2:	ff 91       	pop	r31
    1bc4:	ef 91       	pop	r30
    1bc6:	cf 91       	pop	r28
    1bc8:	bf 91       	pop	r27
    1bca:	af 91       	pop	r26
    1bcc:	9f 91       	pop	r25
    1bce:	8f 91       	pop	r24
    1bd0:	7f 91       	pop	r23
    1bd2:	6f 91       	pop	r22
    1bd4:	5f 91       	pop	r21
    1bd6:	4f 91       	pop	r20
    1bd8:	3f 91       	pop	r19
    1bda:	2f 91       	pop	r18
    1bdc:	0f 90       	pop	r0
    1bde:	0b be       	out	0x3b, r0	; 59
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	0f 90       	pop	r0
    1be6:	1f 90       	pop	r1
    1be8:	18 95       	reti

00001bea <__vector_32>:

ISR(USART1_TX_vect)
{
    1bea:	1f 92       	push	r1
    1bec:	0f 92       	push	r0
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	0f 92       	push	r0
    1bf2:	11 24       	eor	r1, r1
    1bf4:	0b b6       	in	r0, 0x3b	; 59
    1bf6:	0f 92       	push	r0
    1bf8:	2f 93       	push	r18
    1bfa:	3f 93       	push	r19
    1bfc:	4f 93       	push	r20
    1bfe:	5f 93       	push	r21
    1c00:	6f 93       	push	r22
    1c02:	7f 93       	push	r23
    1c04:	8f 93       	push	r24
    1c06:	9f 93       	push	r25
    1c08:	af 93       	push	r26
    1c0a:	bf 93       	push	r27
    1c0c:	ef 93       	push	r30
    1c0e:	ff 93       	push	r31
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <tx_put_byte.part.0>
  tx_put_byte( 1 );
}
    1c16:	ff 91       	pop	r31
    1c18:	ef 91       	pop	r30
    1c1a:	bf 91       	pop	r27
    1c1c:	af 91       	pop	r26
    1c1e:	9f 91       	pop	r25
    1c20:	8f 91       	pop	r24
    1c22:	7f 91       	pop	r23
    1c24:	6f 91       	pop	r22
    1c26:	5f 91       	pop	r21
    1c28:	4f 91       	pop	r20
    1c2a:	3f 91       	pop	r19
    1c2c:	2f 91       	pop	r18
    1c2e:	0f 90       	pop	r0
    1c30:	0b be       	out	0x3b, r0	; 59
    1c32:	0f 90       	pop	r0
    1c34:	0f be       	out	0x3f, r0	; 63
    1c36:	0f 90       	pop	r0
    1c38:	1f 90       	pop	r1
    1c3a:	18 95       	reti

00001c3c <__vector_30>:

ISR(USART1_RX_vect)
{
    1c3c:	1f 92       	push	r1
    1c3e:	0f 92       	push	r0
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	0f 92       	push	r0
    1c44:	11 24       	eor	r1, r1
    1c46:	0b b6       	in	r0, 0x3b	; 59
    1c48:	0f 92       	push	r0
    1c4a:	2f 93       	push	r18
    1c4c:	3f 93       	push	r19
    1c4e:	4f 93       	push	r20
    1c50:	5f 93       	push	r21
    1c52:	6f 93       	push	r22
    1c54:	7f 93       	push	r23
    1c56:	8f 93       	push	r24
    1c58:	9f 93       	push	r25
    1c5a:	af 93       	push	r26
    1c5c:	bf 93       	push	r27
    1c5e:	ef 93       	push	r30
    1c60:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[1], UDR1 ) == VCP_TERM )
    1c62:	60 91 9c 00 	lds	r22, 0x009C
    1c66:	80 91 a9 0d 	lds	r24, 0x0DA9
    1c6a:	90 91 aa 0d 	lds	r25, 0x0DAA
    1c6e:	0e 94 7b 0c 	call	0x18f6	; 0x18f6 <Receive_VCP_byte>
    1c72:	81 30       	cpi	r24, 0x01	; 1
    1c74:	29 f4       	brne	.+10     	; 0x1c80 <__vector_30+0x44>
  {
    rx_flag[1]++;
    1c76:	80 91 ad 0d 	lds	r24, 0x0DAD
    1c7a:	8f 5f       	subi	r24, 0xFF	; 255
    1c7c:	80 93 ad 0d 	sts	0x0DAD, r24
  }
}
    1c80:	ff 91       	pop	r31
    1c82:	ef 91       	pop	r30
    1c84:	bf 91       	pop	r27
    1c86:	af 91       	pop	r26
    1c88:	9f 91       	pop	r25
    1c8a:	8f 91       	pop	r24
    1c8c:	7f 91       	pop	r23
    1c8e:	6f 91       	pop	r22
    1c90:	5f 91       	pop	r21
    1c92:	4f 91       	pop	r20
    1c94:	3f 91       	pop	r19
    1c96:	2f 91       	pop	r18
    1c98:	0f 90       	pop	r0
    1c9a:	0b be       	out	0x3b, r0	; 59
    1c9c:	0f 90       	pop	r0
    1c9e:	0f be       	out	0x3f, r0	; 63
    1ca0:	0f 90       	pop	r0
    1ca2:	1f 90       	pop	r1
    1ca4:	18 95       	reti

00001ca6 <__vector_21>:

ISR ( ADC_vect )
{
    1ca6:	1f 92       	push	r1
    1ca8:	0f 92       	push	r0
    1caa:	0f b6       	in	r0, 0x3f	; 63
    1cac:	0f 92       	push	r0
    1cae:	11 24       	eor	r1, r1
    1cb0:	8f 93       	push	r24
  ADC_low = ADCL;	// Left adjusted; read 2 LSB then 8 MSB
    1cb2:	84 b1       	in	r24, 0x04	; 4
    1cb4:	80 93 a0 0d 	sts	0x0DA0, r24
  ADC_high = ADCH;
    1cb8:	85 b1       	in	r24, 0x05	; 5
    1cba:	80 93 63 09 	sts	0x0963, r24
  adc_flag = 1;
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	80 93 45 09 	sts	0x0945, r24
}
    1cc4:	8f 91       	pop	r24
    1cc6:	0f 90       	pop	r0
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	0f 90       	pop	r0
    1ccc:	1f 90       	pop	r1
    1cce:	18 95       	reti

00001cd0 <__vector_20>:

ISR( USART0_TX_vect )
{
    1cd0:	1f 92       	push	r1
    1cd2:	0f 92       	push	r0
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	0f 92       	push	r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	0b b6       	in	r0, 0x3b	; 59
    1cdc:	0f 92       	push	r0
    1cde:	2f 93       	push	r18
    1ce0:	3f 93       	push	r19
    1ce2:	4f 93       	push	r20
    1ce4:	5f 93       	push	r21
    1ce6:	6f 93       	push	r22
    1ce8:	7f 93       	push	r23
    1cea:	8f 93       	push	r24
    1cec:	9f 93       	push	r25
    1cee:	af 93       	push	r26
    1cf0:	bf 93       	push	r27
    1cf2:	ef 93       	push	r30
    1cf4:	ff 93       	push	r31
    1cf6:	80 e0       	ldi	r24, 0x00	; 0
    1cf8:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <tx_put_byte.part.0>
  tx_put_byte( 0 );
}
    1cfc:	ff 91       	pop	r31
    1cfe:	ef 91       	pop	r30
    1d00:	bf 91       	pop	r27
    1d02:	af 91       	pop	r26
    1d04:	9f 91       	pop	r25
    1d06:	8f 91       	pop	r24
    1d08:	7f 91       	pop	r23
    1d0a:	6f 91       	pop	r22
    1d0c:	5f 91       	pop	r21
    1d0e:	4f 91       	pop	r20
    1d10:	3f 91       	pop	r19
    1d12:	2f 91       	pop	r18
    1d14:	0f 90       	pop	r0
    1d16:	0b be       	out	0x3b, r0	; 59
    1d18:	0f 90       	pop	r0
    1d1a:	0f be       	out	0x3f, r0	; 63
    1d1c:	0f 90       	pop	r0
    1d1e:	1f 90       	pop	r1
    1d20:	18 95       	reti

00001d22 <__vector_18>:

ISR( USART0_RX_vect )
{
    1d22:	1f 92       	push	r1
    1d24:	0f 92       	push	r0
    1d26:	0f b6       	in	r0, 0x3f	; 63
    1d28:	0f 92       	push	r0
    1d2a:	11 24       	eor	r1, r1
    1d2c:	0b b6       	in	r0, 0x3b	; 59
    1d2e:	0f 92       	push	r0
    1d30:	2f 93       	push	r18
    1d32:	3f 93       	push	r19
    1d34:	4f 93       	push	r20
    1d36:	5f 93       	push	r21
    1d38:	6f 93       	push	r22
    1d3a:	7f 93       	push	r23
    1d3c:	8f 93       	push	r24
    1d3e:	9f 93       	push	r25
    1d40:	af 93       	push	r26
    1d42:	bf 93       	push	r27
    1d44:	ef 93       	push	r30
    1d46:	ff 93       	push	r31
  if( Receive_VCP_byte( uart_vcp_buff[0], UDR0 ) == VCP_TERM )
    1d48:	6c b1       	in	r22, 0x0c	; 12
    1d4a:	80 91 a7 0d 	lds	r24, 0x0DA7
    1d4e:	90 91 a8 0d 	lds	r25, 0x0DA8
    1d52:	0e 94 7b 0c 	call	0x18f6	; 0x18f6 <Receive_VCP_byte>
    1d56:	81 30       	cpi	r24, 0x01	; 1
    1d58:	29 f4       	brne	.+10     	; 0x1d64 <__vector_18+0x42>
  {
    rx_flag[0]++;
    1d5a:	80 91 ac 0d 	lds	r24, 0x0DAC
    1d5e:	8f 5f       	subi	r24, 0xFF	; 255
    1d60:	80 93 ac 0d 	sts	0x0DAC, r24
  }
}
    1d64:	ff 91       	pop	r31
    1d66:	ef 91       	pop	r30
    1d68:	bf 91       	pop	r27
    1d6a:	af 91       	pop	r26
    1d6c:	9f 91       	pop	r25
    1d6e:	8f 91       	pop	r24
    1d70:	7f 91       	pop	r23
    1d72:	6f 91       	pop	r22
    1d74:	5f 91       	pop	r21
    1d76:	4f 91       	pop	r20
    1d78:	3f 91       	pop	r19
    1d7a:	2f 91       	pop	r18
    1d7c:	0f 90       	pop	r0
    1d7e:	0b be       	out	0x3b, r0	; 59
    1d80:	0f 90       	pop	r0
    1d82:	0f be       	out	0x3f, r0	; 63
    1d84:	0f 90       	pop	r0
    1d86:	1f 90       	pop	r1
    1d88:	18 95       	reti

00001d8a <tx_put_byte>:

void tx_put_byte( uint8_t uart )
{
  if ( uart != 0 && uart != 1 )
    1d8a:	82 30       	cpi	r24, 0x02	; 2
    1d8c:	10 f4       	brcc	.+4      	; 0x1d92 <tx_put_byte+0x8>
    1d8e:	0c 94 1e 0d 	jmp	0x1a3c	; 0x1a3c <tx_put_byte.part.0>
    1d92:	08 95       	ret

00001d94 <construct_telemetry_packet>:
  }
}


void construct_telemetry_packet( uint8_t* packet_payload )
{
    1d94:	2f 92       	push	r2
    1d96:	3f 92       	push	r3
    1d98:	4f 92       	push	r4
    1d9a:	5f 92       	push	r5
    1d9c:	6f 92       	push	r6
    1d9e:	7f 92       	push	r7
    1da0:	8f 92       	push	r8
    1da2:	9f 92       	push	r9
    1da4:	af 92       	push	r10
    1da6:	bf 92       	push	r11
    1da8:	cf 92       	push	r12
    1daa:	df 92       	push	r13
    1dac:	ef 92       	push	r14
    1dae:	ff 92       	push	r15
    1db0:	0f 93       	push	r16
    1db2:	1f 93       	push	r17
    1db4:	cf 93       	push	r28
    1db6:	df 93       	push	r29
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
    1dbc:	28 97       	sbiw	r28, 0x08	; 8
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	98 87       	std	Y+8, r25	; 0x08
    1dca:	8f 83       	std	Y+7, r24	; 0x07
  packet_payload[0] = VCP_POWER_TELEMETRY;
    1dcc:	dc 01       	movw	r26, r24
    1dce:	1c 92       	st	X, r1
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
    1dd0:	30 91 50 04 	lds	r19, 0x0450
    1dd4:	33 0f       	add	r19, r19
                  ( svit[RADIO_1].switch_state << 2 )    |
    1dd6:	80 91 6c 04 	lds	r24, 0x046C
    1dda:	b4 e0       	ldi	r27, 0x04	; 4
    1ddc:	8b 9f       	mul	r24, r27
    1dde:	c0 01       	movw	r24, r0
    1de0:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1de2:	38 2b       	or	r19, r24
    1de4:	80 91 34 04 	lds	r24, 0x0434
    1de8:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
    1dea:	80 91 88 04 	lds	r24, 0x0488
    1dee:	e8 e0       	ldi	r30, 0x08	; 8
    1df0:	8e 9f       	mul	r24, r30
    1df2:	c0 01       	movw	r24, r0
    1df4:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1df6:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
    1df8:	80 91 dc 04 	lds	r24, 0x04DC
    1dfc:	f0 e1       	ldi	r31, 0x10	; 16
    1dfe:	8f 9f       	mul	r24, r31
    1e00:	c0 01       	movw	r24, r0
    1e02:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1e04:	38 2b       	or	r19, r24
                  ( svit[SUN_SENSOR].switch_state << 1 ) |
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;
    1e06:	80 91 f8 04 	lds	r24, 0x04F8
    1e0a:	20 e2       	ldi	r18, 0x20	; 32
    1e0c:	82 9f       	mul	r24, r18
    1e0e:	c0 01       	movw	r24, r0
    1e10:	11 24       	eor	r1, r1
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;

  on_off_state1 = ( svit[CMG].switch_state << 0 )        |
    1e12:	38 2b       	or	r19, r24
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
    1e14:	40 91 30 05 	lds	r20, 0x0530
    1e18:	44 0f       	add	r20, r20
                  ( svit[TORQUER_3].switch_state << 2 ) |
    1e1a:	80 91 4c 05 	lds	r24, 0x054C
    1e1e:	54 e0       	ldi	r21, 0x04	; 4
    1e20:	85 9f       	mul	r24, r21
    1e22:	c0 01       	movw	r24, r0
    1e24:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1e26:	48 2b       	or	r20, r24
    1e28:	80 91 14 05 	lds	r24, 0x0514
    1e2c:	48 2b       	or	r20, r24
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );
    1e2e:	e4 ea       	ldi	r30, 0xA4	; 164
    1e30:	f4 e0       	ldi	r31, 0x04	; 4
    1e32:	80 81       	ld	r24, Z
    1e34:	a8 e0       	ldi	r26, 0x08	; 8
    1e36:	8a 9f       	mul	r24, r26
    1e38:	c0 01       	movw	r24, r0
    1e3a:	11 24       	eor	r1, r1
                  ( svit[RADIO_1].switch_state << 2 )    |
                  ( svit[RADIO_2].switch_state << 3 )    |
                  ( svit[FOG_15V].switch_state << 4 )    |
                  ( svit[FOG_5V].switch_state << 5  )    ;

  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
    1e3c:	48 2b       	or	r20, r24
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
    1e3e:	20 91 54 03 	lds	r18, 0x0354
    1e42:	22 0f       	add	r18, r18
                  ( svit[FC_5V].switch_state << 2 )        |
    1e44:	80 91 70 03 	lds	r24, 0x0370
    1e48:	b4 e0       	ldi	r27, 0x04	; 4
    1e4a:	8b 9f       	mul	r24, r27
    1e4c:	c0 01       	movw	r24, r0
    1e4e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e50:	28 2b       	or	r18, r24
    1e52:	80 91 38 03 	lds	r24, 0x0338
    1e56:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
    1e58:	80 91 a8 03 	lds	r24, 0x03A8
    1e5c:	58 e0       	ldi	r21, 0x08	; 8
    1e5e:	85 9f       	mul	r24, r21
    1e60:	c0 01       	movw	r24, r0
    1e62:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e64:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
    1e66:	80 91 c4 03 	lds	r24, 0x03C4
    1e6a:	a0 e1       	ldi	r26, 0x10	; 16
    1e6c:	8a 9f       	mul	r24, r26
    1e6e:	c0 01       	movw	r24, r0
    1e70:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e72:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
    1e74:	80 91 e0 03 	lds	r24, 0x03E0
    1e78:	b0 e2       	ldi	r27, 0x20	; 32
    1e7a:	8b 9f       	mul	r24, r27
    1e7c:	c0 01       	movw	r24, r0
    1e7e:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e80:	28 2b       	or	r18, r24
                  ( svit[STAR_TRACKER].switch_state << 1 ) |
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
    1e82:	80 91 fc 03 	lds	r24, 0x03FC
    1e86:	50 e4       	ldi	r21, 0x40	; 64
    1e88:	85 9f       	mul	r24, r21
    1e8a:	c0 01       	movw	r24, r0
    1e8c:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e8e:	28 2b       	or	r18, r24
                  ( svit[FC_5V].switch_state << 2 )        |
                  ( svit[GPS_1].switch_state << 3 )        |
                  ( svit[GPS_2].switch_state << 4 )        |
                  ( svit[CDH_IB].switch_state << 5 )       |
                  ( svit[HEATER_1].switch_state << 6 )     |
                  ( svit[HEATER_2].switch_state << 7 )     ;
    1e90:	80 91 18 04 	lds	r24, 0x0418
    1e94:	a0 e8       	ldi	r26, 0x80	; 128
    1e96:	8a 9f       	mul	r24, r26
    1e98:	c0 01       	movw	r24, r0
    1e9a:	11 24       	eor	r1, r1
  uint8_t on_off_state1;
  uint8_t on_off_state2;
  uint8_t on_off_state3;
  uint8_t on_off_state4;

  on_off_state0 = ( svit[SPECTROMETER].switch_state << 0 ) |
    1e9c:	28 2b       	or	r18, r24
  on_off_state2 = ( svit[TORQUER_1].switch_state << 0 )  |
                  ( svit[TORQUER_2].switch_state << 1 ) |
                  ( svit[TORQUER_3].switch_state << 2 ) |
                  ( svit[MAESTRO].switch_state << 3 );

  packet_payload[1] = on_off_state0;
    1e9e:	af 81       	ldd	r26, Y+7	; 0x07
    1ea0:	b8 85       	ldd	r27, Y+8	; 0x08
    1ea2:	11 96       	adiw	r26, 0x01	; 1
    1ea4:	2c 93       	st	X, r18
    1ea6:	11 97       	sbiw	r26, 0x01	; 1
  packet_payload[2] = on_off_state1;
    1ea8:	12 96       	adiw	r26, 0x02	; 2
    1eaa:	3c 93       	st	X, r19
    1eac:	12 97       	sbiw	r26, 0x02	; 2
  packet_payload[3] = on_off_state2;
    1eae:	13 96       	adiw	r26, 0x03	; 3
    1eb0:	4c 93       	st	X, r20
    1eb2:	13 97       	sbiw	r26, 0x03	; 3
  packet_payload[4] = 0x99;
    1eb4:	89 e9       	ldi	r24, 0x99	; 153
    1eb6:	14 96       	adiw	r26, 0x04	; 4
    1eb8:	8c 93       	st	X, r24
    1eba:	14 97       	sbiw	r26, 0x04	; 4
  packet_payload[5] = svit[MAESTRO].switch_state;
    1ebc:	80 81       	ld	r24, Z
    1ebe:	15 96       	adiw	r26, 0x05	; 5
    1ec0:	8c 93       	st	X, r24

  // voltage values (raw ADC output)
  packet_payload[6]  = SVIT_check_V_critical( svit[SPECTROMETER].name );
    1ec2:	26 e3       	ldi	r18, 0x36	; 54
    1ec4:	62 2e       	mov	r6, r18
    1ec6:	23 e0       	ldi	r18, 0x03	; 3
    1ec8:	72 2e       	mov	r7, r18
    1eca:	f3 01       	movw	r30, r6
    1ecc:	80 81       	ld	r24, Z
    1ece:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1ed2:	af 81       	ldd	r26, Y+7	; 0x07
    1ed4:	b8 85       	ldd	r27, Y+8	; 0x08
    1ed6:	16 96       	adiw	r26, 0x06	; 6
    1ed8:	8c 93       	st	X, r24
  packet_payload[7]  = SVIT_check_V_critical( svit[STAR_TRACKER].name );
    1eda:	32 e5       	ldi	r19, 0x52	; 82
    1edc:	83 2e       	mov	r8, r19
    1ede:	33 e0       	ldi	r19, 0x03	; 3
    1ee0:	93 2e       	mov	r9, r19
    1ee2:	f4 01       	movw	r30, r8
    1ee4:	80 81       	ld	r24, Z
    1ee6:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1eea:	af 81       	ldd	r26, Y+7	; 0x07
    1eec:	b8 85       	ldd	r27, Y+8	; 0x08
    1eee:	17 96       	adiw	r26, 0x07	; 7
    1ef0:	8c 93       	st	X, r24
  packet_payload[8]  = SVIT_check_V_critical( svit[FC_5V].name );
    1ef2:	4e e6       	ldi	r20, 0x6E	; 110
    1ef4:	a4 2e       	mov	r10, r20
    1ef6:	43 e0       	ldi	r20, 0x03	; 3
    1ef8:	b4 2e       	mov	r11, r20
    1efa:	f5 01       	movw	r30, r10
    1efc:	80 81       	ld	r24, Z
    1efe:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f02:	af 81       	ldd	r26, Y+7	; 0x07
    1f04:	b8 85       	ldd	r27, Y+8	; 0x08
    1f06:	18 96       	adiw	r26, 0x08	; 8
    1f08:	8c 93       	st	X, r24
  packet_payload[9]  = SVIT_check_V_critical( svit[FC_3_3V].name );
    1f0a:	5a e8       	ldi	r21, 0x8A	; 138
    1f0c:	c5 2e       	mov	r12, r21
    1f0e:	53 e0       	ldi	r21, 0x03	; 3
    1f10:	d5 2e       	mov	r13, r21
    1f12:	f6 01       	movw	r30, r12
    1f14:	80 81       	ld	r24, Z
    1f16:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f1a:	af 81       	ldd	r26, Y+7	; 0x07
    1f1c:	b8 85       	ldd	r27, Y+8	; 0x08
    1f1e:	19 96       	adiw	r26, 0x09	; 9
    1f20:	8c 93       	st	X, r24
  packet_payload[10] = SVIT_check_V_critical( svit[GPS_1].name );
    1f22:	66 ea       	ldi	r22, 0xA6	; 166
    1f24:	e6 2e       	mov	r14, r22
    1f26:	63 e0       	ldi	r22, 0x03	; 3
    1f28:	f6 2e       	mov	r15, r22
    1f2a:	f7 01       	movw	r30, r14
    1f2c:	80 81       	ld	r24, Z
    1f2e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f32:	af 81       	ldd	r26, Y+7	; 0x07
    1f34:	b8 85       	ldd	r27, Y+8	; 0x08
    1f36:	1a 96       	adiw	r26, 0x0a	; 10
    1f38:	8c 93       	st	X, r24
  packet_payload[11] = SVIT_check_V_critical( svit[CDH_IB].name );
    1f3a:	0e ed       	ldi	r16, 0xDE	; 222
    1f3c:	13 e0       	ldi	r17, 0x03	; 3
    1f3e:	f8 01       	movw	r30, r16
    1f40:	80 81       	ld	r24, Z
    1f42:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f46:	af 81       	ldd	r26, Y+7	; 0x07
    1f48:	b8 85       	ldd	r27, Y+8	; 0x08
    1f4a:	1b 96       	adiw	r26, 0x0b	; 11
    1f4c:	8c 93       	st	X, r24
  packet_payload[12] = SVIT_check_V_critical( svit[HEATER_1].name );
    1f4e:	ea ef       	ldi	r30, 0xFA	; 250
    1f50:	f3 e0       	ldi	r31, 0x03	; 3
    1f52:	80 81       	ld	r24, Z
    1f54:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f58:	af 81       	ldd	r26, Y+7	; 0x07
    1f5a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f5c:	1c 96       	adiw	r26, 0x0c	; 12
    1f5e:	8c 93       	st	X, r24
  packet_payload[13] = SVIT_check_V_critical( svit[HEATER_2].name );
    1f60:	76 e1       	ldi	r23, 0x16	; 22
    1f62:	47 2e       	mov	r4, r23
    1f64:	74 e0       	ldi	r23, 0x04	; 4
    1f66:	57 2e       	mov	r5, r23
    1f68:	f2 01       	movw	r30, r4
    1f6a:	80 81       	ld	r24, Z
    1f6c:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f70:	af 81       	ldd	r26, Y+7	; 0x07
    1f72:	b8 85       	ldd	r27, Y+8	; 0x08
    1f74:	1d 96       	adiw	r26, 0x0d	; 13
    1f76:	8c 93       	st	X, r24
  packet_payload[14] = SVIT_check_V_critical( svit[CMG].name );
    1f78:	e2 e3       	ldi	r30, 0x32	; 50
    1f7a:	2e 2e       	mov	r2, r30
    1f7c:	e4 e0       	ldi	r30, 0x04	; 4
    1f7e:	3e 2e       	mov	r3, r30
    1f80:	f1 01       	movw	r30, r2
    1f82:	80 81       	ld	r24, Z
    1f84:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1f88:	af 81       	ldd	r26, Y+7	; 0x07
    1f8a:	b8 85       	ldd	r27, Y+8	; 0x08
    1f8c:	1e 96       	adiw	r26, 0x0e	; 14
    1f8e:	8c 93       	st	X, r24
  packet_payload[15] = SVIT_check_V_critical( svit[SUN_SENSOR].name );
    1f90:	2e e4       	ldi	r18, 0x4E	; 78
    1f92:	34 e0       	ldi	r19, 0x04	; 4
    1f94:	f9 01       	movw	r30, r18
    1f96:	80 81       	ld	r24, Z
    1f98:	29 83       	std	Y+1, r18	; 0x01
    1f9a:	3a 83       	std	Y+2, r19	; 0x02
    1f9c:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1fa0:	af 81       	ldd	r26, Y+7	; 0x07
    1fa2:	b8 85       	ldd	r27, Y+8	; 0x08
    1fa4:	1f 96       	adiw	r26, 0x0f	; 15
    1fa6:	8c 93       	st	X, r24
  packet_payload[16] = SVIT_check_V_critical( svit[RADIO_1].name );
    1fa8:	4a e6       	ldi	r20, 0x6A	; 106
    1faa:	54 e0       	ldi	r21, 0x04	; 4
    1fac:	fa 01       	movw	r30, r20
    1fae:	80 81       	ld	r24, Z
    1fb0:	4b 83       	std	Y+3, r20	; 0x03
    1fb2:	5c 83       	std	Y+4, r21	; 0x04
    1fb4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1fb8:	af 81       	ldd	r26, Y+7	; 0x07
    1fba:	b8 85       	ldd	r27, Y+8	; 0x08
    1fbc:	50 96       	adiw	r26, 0x10	; 16
    1fbe:	8c 93       	st	X, r24
  packet_payload[17] = SVIT_check_V_critical( svit[RADIO_2].name );
    1fc0:	66 e8       	ldi	r22, 0x86	; 134
    1fc2:	74 e0       	ldi	r23, 0x04	; 4
    1fc4:	fb 01       	movw	r30, r22
    1fc6:	80 81       	ld	r24, Z
    1fc8:	6d 83       	std	Y+5, r22	; 0x05
    1fca:	7e 83       	std	Y+6, r23	; 0x06
    1fcc:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1fd0:	af 81       	ldd	r26, Y+7	; 0x07
    1fd2:	b8 85       	ldd	r27, Y+8	; 0x08
    1fd4:	51 96       	adiw	r26, 0x11	; 17
    1fd6:	8c 93       	st	X, r24
  packet_payload[18] = SVIT_check_V_critical( svit[FOG_15V].name );
    1fd8:	ea ed       	ldi	r30, 0xDA	; 218
    1fda:	f4 e0       	ldi	r31, 0x04	; 4
    1fdc:	80 81       	ld	r24, Z
    1fde:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1fe2:	af 81       	ldd	r26, Y+7	; 0x07
    1fe4:	b8 85       	ldd	r27, Y+8	; 0x08
    1fe6:	52 96       	adiw	r26, 0x12	; 18
    1fe8:	8c 93       	st	X, r24
  packet_payload[19] = SVIT_check_V_critical( svit[FOG_5V].name );
    1fea:	e6 ef       	ldi	r30, 0xF6	; 246
    1fec:	f4 e0       	ldi	r31, 0x04	; 4
    1fee:	80 81       	ld	r24, Z
    1ff0:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    1ff4:	af 81       	ldd	r26, Y+7	; 0x07
    1ff6:	b8 85       	ldd	r27, Y+8	; 0x08
    1ff8:	53 96       	adiw	r26, 0x13	; 19
    1ffa:	8c 93       	st	X, r24
  packet_payload[20] = SVIT_check_V_critical( svit[TORQUER_1].name );
    1ffc:	e2 e1       	ldi	r30, 0x12	; 18
    1ffe:	f5 e0       	ldi	r31, 0x05	; 5
    2000:	80 81       	ld	r24, Z
    2002:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2006:	af 81       	ldd	r26, Y+7	; 0x07
    2008:	b8 85       	ldd	r27, Y+8	; 0x08
    200a:	54 96       	adiw	r26, 0x14	; 20
    200c:	8c 93       	st	X, r24
  packet_payload[21] = SVIT_check_V_critical( svit[TORQUER_2].name );
    200e:	ee e2       	ldi	r30, 0x2E	; 46
    2010:	f5 e0       	ldi	r31, 0x05	; 5
    2012:	80 81       	ld	r24, Z
    2014:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2018:	af 81       	ldd	r26, Y+7	; 0x07
    201a:	b8 85       	ldd	r27, Y+8	; 0x08
    201c:	55 96       	adiw	r26, 0x15	; 21
    201e:	8c 93       	st	X, r24
  packet_payload[22] = SVIT_check_V_critical( svit[TORQUER_3].name );
    2020:	ea e4       	ldi	r30, 0x4A	; 74
    2022:	f5 e0       	ldi	r31, 0x05	; 5
    2024:	80 81       	ld	r24, Z
    2026:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    202a:	af 81       	ldd	r26, Y+7	; 0x07
    202c:	b8 85       	ldd	r27, Y+8	; 0x08
    202e:	56 96       	adiw	r26, 0x16	; 22
    2030:	8c 93       	st	X, r24
  packet_payload[23] = SVIT_check_V_critical( svit[BATTERY_1].name );
    2032:	e6 e6       	ldi	r30, 0x66	; 102
    2034:	f5 e0       	ldi	r31, 0x05	; 5
    2036:	80 81       	ld	r24, Z
    2038:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    203c:	af 81       	ldd	r26, Y+7	; 0x07
    203e:	b8 85       	ldd	r27, Y+8	; 0x08
    2040:	57 96       	adiw	r26, 0x17	; 23
    2042:	8c 93       	st	X, r24
  packet_payload[24] = SVIT_check_V_critical( svit[BATTERY_2].name );
    2044:	e2 e8       	ldi	r30, 0x82	; 130
    2046:	f5 e0       	ldi	r31, 0x05	; 5
    2048:	80 81       	ld	r24, Z
    204a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    204e:	af 81       	ldd	r26, Y+7	; 0x07
    2050:	b8 85       	ldd	r27, Y+8	; 0x08
    2052:	58 96       	adiw	r26, 0x18	; 24
    2054:	8c 93       	st	X, r24
  packet_payload[25] = SVIT_check_V_critical( svit[SOLAR_FULL].name );
    2056:	ee e9       	ldi	r30, 0x9E	; 158
    2058:	f5 e0       	ldi	r31, 0x05	; 5
    205a:	80 81       	ld	r24, Z
    205c:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2060:	af 81       	ldd	r26, Y+7	; 0x07
    2062:	b8 85       	ldd	r27, Y+8	; 0x08
    2064:	59 96       	adiw	r26, 0x19	; 25
    2066:	8c 93       	st	X, r24
  packet_payload[26] = SVIT_check_V_critical( svit[SOLAR_1].name );
    2068:	ea eb       	ldi	r30, 0xBA	; 186
    206a:	f5 e0       	ldi	r31, 0x05	; 5
    206c:	80 81       	ld	r24, Z
    206e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2072:	af 81       	ldd	r26, Y+7	; 0x07
    2074:	b8 85       	ldd	r27, Y+8	; 0x08
    2076:	5a 96       	adiw	r26, 0x1a	; 26
    2078:	8c 93       	st	X, r24
  packet_payload[27] = SVIT_check_V_critical( svit[SOLAR_2].name );
    207a:	e6 ed       	ldi	r30, 0xD6	; 214
    207c:	f5 e0       	ldi	r31, 0x05	; 5
    207e:	80 81       	ld	r24, Z
    2080:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2084:	af 81       	ldd	r26, Y+7	; 0x07
    2086:	b8 85       	ldd	r27, Y+8	; 0x08
    2088:	5b 96       	adiw	r26, 0x1b	; 27
    208a:	8c 93       	st	X, r24
  packet_payload[28] = SVIT_check_V_critical( svit[SOLAR_3].name );
    208c:	e2 ef       	ldi	r30, 0xF2	; 242
    208e:	f5 e0       	ldi	r31, 0x05	; 5
    2090:	80 81       	ld	r24, Z
    2092:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2096:	af 81       	ldd	r26, Y+7	; 0x07
    2098:	b8 85       	ldd	r27, Y+8	; 0x08
    209a:	5c 96       	adiw	r26, 0x1c	; 28
    209c:	8c 93       	st	X, r24
  packet_payload[29] = SVIT_check_V_critical( svit[SOLAR_4].name );
    209e:	ee e0       	ldi	r30, 0x0E	; 14
    20a0:	f6 e0       	ldi	r31, 0x06	; 6
    20a2:	80 81       	ld	r24, Z
    20a4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    20a8:	af 81       	ldd	r26, Y+7	; 0x07
    20aa:	b8 85       	ldd	r27, Y+8	; 0x08
    20ac:	5d 96       	adiw	r26, 0x1d	; 29
    20ae:	8c 93       	st	X, r24
  packet_payload[30] = SVIT_check_V_critical( svit[SOLAR_5].name );
    20b0:	ea e2       	ldi	r30, 0x2A	; 42
    20b2:	f6 e0       	ldi	r31, 0x06	; 6
    20b4:	80 81       	ld	r24, Z
    20b6:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    20ba:	af 81       	ldd	r26, Y+7	; 0x07
    20bc:	b8 85       	ldd	r27, Y+8	; 0x08
    20be:	5e 96       	adiw	r26, 0x1e	; 30
    20c0:	8c 93       	st	X, r24
  packet_payload[31] = SVIT_check_V_critical( svit[SOLAR_6].name );
    20c2:	e6 e4       	ldi	r30, 0x46	; 70
    20c4:	f6 e0       	ldi	r31, 0x06	; 6
    20c6:	80 81       	ld	r24, Z
    20c8:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    20cc:	af 81       	ldd	r26, Y+7	; 0x07
    20ce:	b8 85       	ldd	r27, Y+8	; 0x08
    20d0:	5f 96       	adiw	r26, 0x1f	; 31
    20d2:	8c 93       	st	X, r24
  packet_payload[32] = SVIT_check_V_critical( svit[SOLAR_7].name );
    20d4:	e2 e6       	ldi	r30, 0x62	; 98
    20d6:	f6 e0       	ldi	r31, 0x06	; 6
    20d8:	80 81       	ld	r24, Z
    20da:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    20de:	af 81       	ldd	r26, Y+7	; 0x07
    20e0:	b8 85       	ldd	r27, Y+8	; 0x08
    20e2:	90 96       	adiw	r26, 0x20	; 32
    20e4:	8c 93       	st	X, r24
  packet_payload[33] = SVIT_check_V_critical( svit[SOLAR_8].name );
    20e6:	ee e7       	ldi	r30, 0x7E	; 126
    20e8:	f6 e0       	ldi	r31, 0x06	; 6
    20ea:	80 81       	ld	r24, Z
    20ec:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    20f0:	af 81       	ldd	r26, Y+7	; 0x07
    20f2:	b8 85       	ldd	r27, Y+8	; 0x08
    20f4:	91 96       	adiw	r26, 0x21	; 33
    20f6:	8c 93       	st	X, r24
  packet_payload[34] = SVIT_check_V_critical( svit[SOLAR_9].name );
    20f8:	ea e9       	ldi	r30, 0x9A	; 154
    20fa:	f6 e0       	ldi	r31, 0x06	; 6
    20fc:	80 81       	ld	r24, Z
    20fe:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2102:	af 81       	ldd	r26, Y+7	; 0x07
    2104:	b8 85       	ldd	r27, Y+8	; 0x08
    2106:	92 96       	adiw	r26, 0x22	; 34
    2108:	8c 93       	st	X, r24
  packet_payload[35] = SVIT_check_V_critical( svit[SOLAR_10].name );
    210a:	e6 eb       	ldi	r30, 0xB6	; 182
    210c:	f6 e0       	ldi	r31, 0x06	; 6
    210e:	80 81       	ld	r24, Z
    2110:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2114:	af 81       	ldd	r26, Y+7	; 0x07
    2116:	b8 85       	ldd	r27, Y+8	; 0x08
    2118:	93 96       	adiw	r26, 0x23	; 35
    211a:	8c 93       	st	X, r24
  packet_payload[36] = SVIT_check_V_critical( svit[SOLAR_11].name );
    211c:	e2 ed       	ldi	r30, 0xD2	; 210
    211e:	f6 e0       	ldi	r31, 0x06	; 6
    2120:	80 81       	ld	r24, Z
    2122:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2126:	af 81       	ldd	r26, Y+7	; 0x07
    2128:	b8 85       	ldd	r27, Y+8	; 0x08
    212a:	94 96       	adiw	r26, 0x24	; 36
    212c:	8c 93       	st	X, r24
  packet_payload[37] = SVIT_check_V_critical( svit[SOLAR_12].name );
    212e:	ee ee       	ldi	r30, 0xEE	; 238
    2130:	f6 e0       	ldi	r31, 0x06	; 6
    2132:	80 81       	ld	r24, Z
    2134:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2138:	af 81       	ldd	r26, Y+7	; 0x07
    213a:	b8 85       	ldd	r27, Y+8	; 0x08
    213c:	95 96       	adiw	r26, 0x25	; 37
    213e:	8c 93       	st	X, r24
  packet_payload[38] = SVIT_check_V_critical( svit[POWER_BOARD].name );
    2140:	80 91 0a 07 	lds	r24, 0x070A
    2144:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <SVIT_check_V_critical>
    2148:	ef 81       	ldd	r30, Y+7	; 0x07
    214a:	f8 85       	ldd	r31, Y+8	; 0x08
    214c:	86 a3       	std	Z+38, r24	; 0x26
  //uint8_t voltage_error1;
  //uint8_t voltage_error2;
  //uint8_t voltage_error3;
  //uint8_t voltage_error4;
 
  packet_payload[39] = 0;
    214e:	17 a2       	std	Z+39, r1	; 0x27
  packet_payload[40] = 0;
    2150:	10 a6       	std	Z+40, r1	; 0x28
  packet_payload[41] = 0;
    2152:	11 a6       	std	Z+41, r1	; 0x29
  packet_payload[42] = 0;
    2154:	12 a6       	std	Z+42, r1	; 0x2a
  packet_payload[43] = 0;
    2156:	13 a6       	std	Z+43, r1	; 0x2b

  // current values (raw ADC output)
  packet_payload[44] = SVIT_check_I_critical( svit[SPECTROMETER].name );
    2158:	d3 01       	movw	r26, r6
    215a:	8c 91       	ld	r24, X
    215c:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2160:	ef 81       	ldd	r30, Y+7	; 0x07
    2162:	f8 85       	ldd	r31, Y+8	; 0x08
    2164:	84 a7       	std	Z+44, r24	; 0x2c
  packet_payload[45] = SVIT_check_I_critical( svit[STAR_TRACKER].name );
    2166:	d4 01       	movw	r26, r8
    2168:	8c 91       	ld	r24, X
    216a:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    216e:	ef 81       	ldd	r30, Y+7	; 0x07
    2170:	f8 85       	ldd	r31, Y+8	; 0x08
    2172:	85 a7       	std	Z+45, r24	; 0x2d
  packet_payload[46] = SVIT_check_I_critical( svit[FC_5V].name );
    2174:	d5 01       	movw	r26, r10
    2176:	8c 91       	ld	r24, X
    2178:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    217c:	ef 81       	ldd	r30, Y+7	; 0x07
    217e:	f8 85       	ldd	r31, Y+8	; 0x08
    2180:	86 a7       	std	Z+46, r24	; 0x2e
  packet_payload[47] = SVIT_check_I_critical( svit[FC_3_3V].name );
    2182:	d6 01       	movw	r26, r12
    2184:	8c 91       	ld	r24, X
    2186:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    218a:	ef 81       	ldd	r30, Y+7	; 0x07
    218c:	f8 85       	ldd	r31, Y+8	; 0x08
    218e:	87 a7       	std	Z+47, r24	; 0x2f
  packet_payload[48] = SVIT_check_I_critical( svit[GPS_1].name );
    2190:	d7 01       	movw	r26, r14
    2192:	8c 91       	ld	r24, X
    2194:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2198:	ef 81       	ldd	r30, Y+7	; 0x07
    219a:	f8 85       	ldd	r31, Y+8	; 0x08
    219c:	80 ab       	std	Z+48, r24	; 0x30
  packet_payload[49] = SVIT_check_I_critical( svit[CDH_IB].name );
    219e:	d8 01       	movw	r26, r16
    21a0:	8c 91       	ld	r24, X
    21a2:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21a6:	ef 81       	ldd	r30, Y+7	; 0x07
    21a8:	f8 85       	ldd	r31, Y+8	; 0x08
    21aa:	81 ab       	std	Z+49, r24	; 0x31
  packet_payload[50] = SVIT_check_I_critical( svit[HEATER_1].name );
    21ac:	aa ef       	ldi	r26, 0xFA	; 250
    21ae:	b3 e0       	ldi	r27, 0x03	; 3
    21b0:	8c 91       	ld	r24, X
    21b2:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21b6:	ef 81       	ldd	r30, Y+7	; 0x07
    21b8:	f8 85       	ldd	r31, Y+8	; 0x08
    21ba:	82 ab       	std	Z+50, r24	; 0x32
  packet_payload[51] = SVIT_check_I_critical( svit[HEATER_2].name );
    21bc:	d2 01       	movw	r26, r4
    21be:	8c 91       	ld	r24, X
    21c0:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21c4:	ef 81       	ldd	r30, Y+7	; 0x07
    21c6:	f8 85       	ldd	r31, Y+8	; 0x08
    21c8:	83 ab       	std	Z+51, r24	; 0x33
  packet_payload[52] = SVIT_check_I_critical( svit[CMG].name );
    21ca:	d1 01       	movw	r26, r2
    21cc:	8c 91       	ld	r24, X
    21ce:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21d2:	ef 81       	ldd	r30, Y+7	; 0x07
    21d4:	f8 85       	ldd	r31, Y+8	; 0x08
    21d6:	84 ab       	std	Z+52, r24	; 0x34
  packet_payload[53] = SVIT_check_I_critical( svit[SUN_SENSOR].name );
    21d8:	29 81       	ldd	r18, Y+1	; 0x01
    21da:	3a 81       	ldd	r19, Y+2	; 0x02
    21dc:	d9 01       	movw	r26, r18
    21de:	8c 91       	ld	r24, X
    21e0:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21e4:	ef 81       	ldd	r30, Y+7	; 0x07
    21e6:	f8 85       	ldd	r31, Y+8	; 0x08
    21e8:	85 ab       	std	Z+53, r24	; 0x35
  packet_payload[54] = SVIT_check_I_critical( svit[RADIO_1].name );
    21ea:	4b 81       	ldd	r20, Y+3	; 0x03
    21ec:	5c 81       	ldd	r21, Y+4	; 0x04
    21ee:	da 01       	movw	r26, r20
    21f0:	8c 91       	ld	r24, X
    21f2:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    21f6:	ef 81       	ldd	r30, Y+7	; 0x07
    21f8:	f8 85       	ldd	r31, Y+8	; 0x08
    21fa:	86 ab       	std	Z+54, r24	; 0x36
  packet_payload[55] = SVIT_check_I_critical( svit[RADIO_2].name );
    21fc:	6d 81       	ldd	r22, Y+5	; 0x05
    21fe:	7e 81       	ldd	r23, Y+6	; 0x06
    2200:	db 01       	movw	r26, r22
    2202:	8c 91       	ld	r24, X
    2204:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2208:	ef 81       	ldd	r30, Y+7	; 0x07
    220a:	f8 85       	ldd	r31, Y+8	; 0x08
    220c:	87 ab       	std	Z+55, r24	; 0x37
  packet_payload[56] = SVIT_check_I_critical( svit[FOG_15V].name );
    220e:	aa ed       	ldi	r26, 0xDA	; 218
    2210:	b4 e0       	ldi	r27, 0x04	; 4
    2212:	8c 91       	ld	r24, X
    2214:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2218:	ef 81       	ldd	r30, Y+7	; 0x07
    221a:	f8 85       	ldd	r31, Y+8	; 0x08
    221c:	80 af       	std	Z+56, r24	; 0x38
  packet_payload[57] = SVIT_check_I_critical( svit[FOG_5V].name );
    221e:	a6 ef       	ldi	r26, 0xF6	; 246
    2220:	b4 e0       	ldi	r27, 0x04	; 4
    2222:	8c 91       	ld	r24, X
    2224:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2228:	ef 81       	ldd	r30, Y+7	; 0x07
    222a:	f8 85       	ldd	r31, Y+8	; 0x08
    222c:	81 af       	std	Z+57, r24	; 0x39
  packet_payload[58] = SVIT_check_I_critical( svit[TORQUER_1].name );
    222e:	a2 e1       	ldi	r26, 0x12	; 18
    2230:	b5 e0       	ldi	r27, 0x05	; 5
    2232:	8c 91       	ld	r24, X
    2234:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2238:	ef 81       	ldd	r30, Y+7	; 0x07
    223a:	f8 85       	ldd	r31, Y+8	; 0x08
    223c:	82 af       	std	Z+58, r24	; 0x3a
  packet_payload[59] = SVIT_check_I_critical( svit[TORQUER_2].name );
    223e:	ae e2       	ldi	r26, 0x2E	; 46
    2240:	b5 e0       	ldi	r27, 0x05	; 5
    2242:	8c 91       	ld	r24, X
    2244:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2248:	ef 81       	ldd	r30, Y+7	; 0x07
    224a:	f8 85       	ldd	r31, Y+8	; 0x08
    224c:	83 af       	std	Z+59, r24	; 0x3b
  packet_payload[60] = SVIT_check_I_critical( svit[TORQUER_3].name );
    224e:	aa e4       	ldi	r26, 0x4A	; 74
    2250:	b5 e0       	ldi	r27, 0x05	; 5
    2252:	8c 91       	ld	r24, X
    2254:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2258:	ef 81       	ldd	r30, Y+7	; 0x07
    225a:	f8 85       	ldd	r31, Y+8	; 0x08
    225c:	84 af       	std	Z+60, r24	; 0x3c
  packet_payload[61] = SVIT_check_I_critical( svit[BATTERY_1].name );
    225e:	a6 e6       	ldi	r26, 0x66	; 102
    2260:	b5 e0       	ldi	r27, 0x05	; 5
    2262:	8c 91       	ld	r24, X
    2264:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2268:	ef 81       	ldd	r30, Y+7	; 0x07
    226a:	f8 85       	ldd	r31, Y+8	; 0x08
    226c:	85 af       	std	Z+61, r24	; 0x3d
  packet_payload[62] = SVIT_check_I_critical( svit[BATTERY_2].name );
    226e:	a2 e8       	ldi	r26, 0x82	; 130
    2270:	b5 e0       	ldi	r27, 0x05	; 5
    2272:	8c 91       	ld	r24, X
    2274:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2278:	ef 81       	ldd	r30, Y+7	; 0x07
    227a:	f8 85       	ldd	r31, Y+8	; 0x08
    227c:	86 af       	std	Z+62, r24	; 0x3e
  packet_payload[63] = SVIT_check_I_critical( svit[SOLAR_FULL].name );
    227e:	ae e9       	ldi	r26, 0x9E	; 158
    2280:	b5 e0       	ldi	r27, 0x05	; 5
    2282:	8c 91       	ld	r24, X
    2284:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2288:	ef 81       	ldd	r30, Y+7	; 0x07
    228a:	f8 85       	ldd	r31, Y+8	; 0x08
    228c:	87 af       	std	Z+63, r24	; 0x3f
  packet_payload[64] = SVIT_check_I_critical( svit[SOLAR_1].name );
    228e:	aa eb       	ldi	r26, 0xBA	; 186
    2290:	b5 e0       	ldi	r27, 0x05	; 5
    2292:	8c 91       	ld	r24, X
    2294:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2298:	ef 81       	ldd	r30, Y+7	; 0x07
    229a:	f8 85       	ldd	r31, Y+8	; 0x08
    229c:	e0 5c       	subi	r30, 0xC0	; 192
    229e:	ff 4f       	sbci	r31, 0xFF	; 255
    22a0:	80 83       	st	Z, r24
  packet_payload[65] = SVIT_check_I_critical( svit[SOLAR_2].name );
    22a2:	e6 ed       	ldi	r30, 0xD6	; 214
    22a4:	f5 e0       	ldi	r31, 0x05	; 5
    22a6:	80 81       	ld	r24, Z
    22a8:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    22ac:	ef 81       	ldd	r30, Y+7	; 0x07
    22ae:	f8 85       	ldd	r31, Y+8	; 0x08
    22b0:	ef 5b       	subi	r30, 0xBF	; 191
    22b2:	ff 4f       	sbci	r31, 0xFF	; 255
    22b4:	80 83       	st	Z, r24
  packet_payload[66] = SVIT_check_I_critical( svit[SOLAR_3].name );
    22b6:	a2 ef       	ldi	r26, 0xF2	; 242
    22b8:	b5 e0       	ldi	r27, 0x05	; 5
    22ba:	8c 91       	ld	r24, X
    22bc:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    22c0:	ef 81       	ldd	r30, Y+7	; 0x07
    22c2:	f8 85       	ldd	r31, Y+8	; 0x08
    22c4:	ee 5b       	subi	r30, 0xBE	; 190
    22c6:	ff 4f       	sbci	r31, 0xFF	; 255
    22c8:	80 83       	st	Z, r24
  packet_payload[67] = SVIT_check_I_critical( svit[SOLAR_4].name );
    22ca:	ee e0       	ldi	r30, 0x0E	; 14
    22cc:	f6 e0       	ldi	r31, 0x06	; 6
    22ce:	80 81       	ld	r24, Z
    22d0:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    22d4:	ef 81       	ldd	r30, Y+7	; 0x07
    22d6:	f8 85       	ldd	r31, Y+8	; 0x08
    22d8:	ed 5b       	subi	r30, 0xBD	; 189
    22da:	ff 4f       	sbci	r31, 0xFF	; 255
    22dc:	80 83       	st	Z, r24
  packet_payload[68] = SVIT_check_I_critical( svit[SOLAR_5].name );
    22de:	aa e2       	ldi	r26, 0x2A	; 42
    22e0:	b6 e0       	ldi	r27, 0x06	; 6
    22e2:	8c 91       	ld	r24, X
    22e4:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    22e8:	ef 81       	ldd	r30, Y+7	; 0x07
    22ea:	f8 85       	ldd	r31, Y+8	; 0x08
    22ec:	ec 5b       	subi	r30, 0xBC	; 188
    22ee:	ff 4f       	sbci	r31, 0xFF	; 255
    22f0:	80 83       	st	Z, r24
  packet_payload[69] = SVIT_check_I_critical( svit[SOLAR_6].name );
    22f2:	e6 e4       	ldi	r30, 0x46	; 70
    22f4:	f6 e0       	ldi	r31, 0x06	; 6
    22f6:	80 81       	ld	r24, Z
    22f8:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    22fc:	ef 81       	ldd	r30, Y+7	; 0x07
    22fe:	f8 85       	ldd	r31, Y+8	; 0x08
    2300:	eb 5b       	subi	r30, 0xBB	; 187
    2302:	ff 4f       	sbci	r31, 0xFF	; 255
    2304:	80 83       	st	Z, r24
  packet_payload[70] = SVIT_check_I_critical( svit[SOLAR_7].name );
    2306:	a2 e6       	ldi	r26, 0x62	; 98
    2308:	b6 e0       	ldi	r27, 0x06	; 6
    230a:	8c 91       	ld	r24, X
    230c:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2310:	ef 81       	ldd	r30, Y+7	; 0x07
    2312:	f8 85       	ldd	r31, Y+8	; 0x08
    2314:	ea 5b       	subi	r30, 0xBA	; 186
    2316:	ff 4f       	sbci	r31, 0xFF	; 255
    2318:	80 83       	st	Z, r24
  packet_payload[71] = SVIT_check_I_critical( svit[SOLAR_8].name );
    231a:	ee e7       	ldi	r30, 0x7E	; 126
    231c:	f6 e0       	ldi	r31, 0x06	; 6
    231e:	80 81       	ld	r24, Z
    2320:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2324:	ef 81       	ldd	r30, Y+7	; 0x07
    2326:	f8 85       	ldd	r31, Y+8	; 0x08
    2328:	e9 5b       	subi	r30, 0xB9	; 185
    232a:	ff 4f       	sbci	r31, 0xFF	; 255
    232c:	80 83       	st	Z, r24
  packet_payload[72] = SVIT_check_I_critical( svit[SOLAR_9].name );
    232e:	aa e9       	ldi	r26, 0x9A	; 154
    2330:	b6 e0       	ldi	r27, 0x06	; 6
    2332:	8c 91       	ld	r24, X
    2334:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2338:	ef 81       	ldd	r30, Y+7	; 0x07
    233a:	f8 85       	ldd	r31, Y+8	; 0x08
    233c:	e8 5b       	subi	r30, 0xB8	; 184
    233e:	ff 4f       	sbci	r31, 0xFF	; 255
    2340:	80 83       	st	Z, r24
  packet_payload[73] = SVIT_check_I_critical( svit[SOLAR_10].name );
    2342:	e6 eb       	ldi	r30, 0xB6	; 182
    2344:	f6 e0       	ldi	r31, 0x06	; 6
    2346:	80 81       	ld	r24, Z
    2348:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    234c:	ef 81       	ldd	r30, Y+7	; 0x07
    234e:	f8 85       	ldd	r31, Y+8	; 0x08
    2350:	e7 5b       	subi	r30, 0xB7	; 183
    2352:	ff 4f       	sbci	r31, 0xFF	; 255
    2354:	80 83       	st	Z, r24
  packet_payload[74] = SVIT_check_I_critical( svit[SOLAR_11].name );
    2356:	a2 ed       	ldi	r26, 0xD2	; 210
    2358:	b6 e0       	ldi	r27, 0x06	; 6
    235a:	8c 91       	ld	r24, X
    235c:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2360:	ef 81       	ldd	r30, Y+7	; 0x07
    2362:	f8 85       	ldd	r31, Y+8	; 0x08
    2364:	e6 5b       	subi	r30, 0xB6	; 182
    2366:	ff 4f       	sbci	r31, 0xFF	; 255
    2368:	80 83       	st	Z, r24
  packet_payload[75] = SVIT_check_I_critical( svit[SOLAR_12].name );
    236a:	ee ee       	ldi	r30, 0xEE	; 238
    236c:	f6 e0       	ldi	r31, 0x06	; 6
    236e:	80 81       	ld	r24, Z
    2370:	0e 94 6d 0a 	call	0x14da	; 0x14da <SVIT_check_I_critical>
    2374:	ef 81       	ldd	r30, Y+7	; 0x07
    2376:	f8 85       	ldd	r31, Y+8	; 0x08
    2378:	e5 5b       	subi	r30, 0xB5	; 181
    237a:	ff 4f       	sbci	r31, 0xFF	; 255
    237c:	80 83       	st	Z, r24
  packet_payload[76] = 0xFF;//SVIT_check_I_critical( svit[POWER_BOARD].name );
    237e:	ef 81       	ldd	r30, Y+7	; 0x07
    2380:	f8 85       	ldd	r31, Y+8	; 0x08
    2382:	e4 5b       	subi	r30, 0xB4	; 180
    2384:	ff 4f       	sbci	r31, 0xFF	; 255
    2386:	8f ef       	ldi	r24, 0xFF	; 255
    2388:	80 83       	st	Z, r24
  //uint8_t current_error1;
  //uint8_t current_error2;
  //uint8_t current_error3;
  //uint8_t current_error4;

  packet_payload[77] = batt1_voltage;//V_ack_change();
    238a:	ef 81       	ldd	r30, Y+7	; 0x07
    238c:	f8 85       	ldd	r31, Y+8	; 0x08
    238e:	e3 5b       	subi	r30, 0xB3	; 179
    2390:	ff 4f       	sbci	r31, 0xFF	; 255
    2392:	90 91 6d 09 	lds	r25, 0x096D
    2396:	90 83       	st	Z, r25
  packet_payload[78] = soc;//soc;// I_ack_change();
    2398:	ef 81       	ldd	r30, Y+7	; 0x07
    239a:	f8 85       	ldd	r31, Y+8	; 0x08
    239c:	e2 5b       	subi	r30, 0xB2	; 178
    239e:	ff 4f       	sbci	r31, 0xFF	; 255
    23a0:	90 91 b0 0f 	lds	r25, 0x0FB0
    23a4:	90 83       	st	Z, r25
  packet_payload[79] = 0x00;//low >> 6;//safe_mode;
    23a6:	ef 81       	ldd	r30, Y+7	; 0x07
    23a8:	f8 85       	ldd	r31, Y+8	; 0x08
    23aa:	e1 5b       	subi	r30, 0xB1	; 177
    23ac:	ff 4f       	sbci	r31, 0xFF	; 255
    23ae:	10 82       	st	Z, r1
  packet_payload[80] = 0x00;//charging;
    23b0:	ef 81       	ldd	r30, Y+7	; 0x07
    23b2:	f8 85       	ldd	r31, Y+8	; 0x08
    23b4:	e0 5b       	subi	r30, 0xB0	; 176
    23b6:	ff 4f       	sbci	r31, 0xFF	; 255
    23b8:	10 82       	st	Z, r1
  packet_payload[81] = 0x00;//chargeforward;
    23ba:	ef 81       	ldd	r30, Y+7	; 0x07
    23bc:	f8 85       	ldd	r31, Y+8	; 0x08
    23be:	ef 5a       	subi	r30, 0xAF	; 175
    23c0:	ff 4f       	sbci	r31, 0xFF	; 255
    23c2:	10 82       	st	Z, r1

  // temperature values (raw ADC output)
  packet_payload[82] = debug;//average_samples( svit[STAR_TRACKER].T_samples );
    23c4:	ef 81       	ldd	r30, Y+7	; 0x07
    23c6:	f8 85       	ldd	r31, Y+8	; 0x08
    23c8:	ee 5a       	subi	r30, 0xAE	; 174
    23ca:	ff 4f       	sbci	r31, 0xFF	; 255
    23cc:	90 91 35 07 	lds	r25, 0x0735
    23d0:	90 83       	st	Z, r25
  packet_payload[83] = 0xFF;//average_samples( svit[BATTERY_1].T_samples );
    23d2:	ef 81       	ldd	r30, Y+7	; 0x07
    23d4:	f8 85       	ldd	r31, Y+8	; 0x08
    23d6:	ed 5a       	subi	r30, 0xAD	; 173
    23d8:	ff 4f       	sbci	r31, 0xFF	; 255
    23da:	80 83       	st	Z, r24
  packet_payload[84] = average_samples( svit[BATTERY_2].T_samples );
    23dc:	8a e9       	ldi	r24, 0x9A	; 154
    23de:	95 e0       	ldi	r25, 0x05	; 5
    23e0:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    23e4:	ef 81       	ldd	r30, Y+7	; 0x07
    23e6:	f8 85       	ldd	r31, Y+8	; 0x08
    23e8:	ec 5a       	subi	r30, 0xAC	; 172
    23ea:	ff 4f       	sbci	r31, 0xFF	; 255
    23ec:	80 83       	st	Z, r24
  packet_payload[85] = average_samples( svit[SOLAR_1].T_samples );
    23ee:	82 ed       	ldi	r24, 0xD2	; 210
    23f0:	95 e0       	ldi	r25, 0x05	; 5
    23f2:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    23f6:	ef 81       	ldd	r30, Y+7	; 0x07
    23f8:	f8 85       	ldd	r31, Y+8	; 0x08
    23fa:	eb 5a       	subi	r30, 0xAB	; 171
    23fc:	ff 4f       	sbci	r31, 0xFF	; 255
    23fe:	80 83       	st	Z, r24
  packet_payload[86] = average_samples( svit[SOLAR_2].T_samples );
    2400:	8e ee       	ldi	r24, 0xEE	; 238
    2402:	95 e0       	ldi	r25, 0x05	; 5
    2404:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    2408:	ef 81       	ldd	r30, Y+7	; 0x07
    240a:	f8 85       	ldd	r31, Y+8	; 0x08
    240c:	ea 5a       	subi	r30, 0xAA	; 170
    240e:	ff 4f       	sbci	r31, 0xFF	; 255
    2410:	80 83       	st	Z, r24
  packet_payload[87] = average_samples( svit[SOLAR_3].T_samples );
    2412:	8a e0       	ldi	r24, 0x0A	; 10
    2414:	96 e0       	ldi	r25, 0x06	; 6
    2416:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    241a:	ef 81       	ldd	r30, Y+7	; 0x07
    241c:	f8 85       	ldd	r31, Y+8	; 0x08
    241e:	e9 5a       	subi	r30, 0xA9	; 169
    2420:	ff 4f       	sbci	r31, 0xFF	; 255
    2422:	80 83       	st	Z, r24
  packet_payload[88] = average_samples( svit[SOLAR_4].T_samples );
    2424:	86 e2       	ldi	r24, 0x26	; 38
    2426:	96 e0       	ldi	r25, 0x06	; 6
    2428:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    242c:	ef 81       	ldd	r30, Y+7	; 0x07
    242e:	f8 85       	ldd	r31, Y+8	; 0x08
    2430:	e8 5a       	subi	r30, 0xA8	; 168
    2432:	ff 4f       	sbci	r31, 0xFF	; 255
    2434:	80 83       	st	Z, r24
  packet_payload[89] = average_samples( svit[SOLAR_5].T_samples );
    2436:	82 e4       	ldi	r24, 0x42	; 66
    2438:	96 e0       	ldi	r25, 0x06	; 6
    243a:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    243e:	ef 81       	ldd	r30, Y+7	; 0x07
    2440:	f8 85       	ldd	r31, Y+8	; 0x08
    2442:	e7 5a       	subi	r30, 0xA7	; 167
    2444:	ff 4f       	sbci	r31, 0xFF	; 255
    2446:	80 83       	st	Z, r24
  packet_payload[90] = average_samples( svit[SOLAR_9].T_samples );
    2448:	82 eb       	ldi	r24, 0xB2	; 178
    244a:	96 e0       	ldi	r25, 0x06	; 6
    244c:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    2450:	ef 81       	ldd	r30, Y+7	; 0x07
    2452:	f8 85       	ldd	r31, Y+8	; 0x08
    2454:	e6 5a       	subi	r30, 0xA6	; 166
    2456:	ff 4f       	sbci	r31, 0xFF	; 255
    2458:	80 83       	st	Z, r24
  packet_payload[91] = average_samples( svit[POWER_BOARD].T_samples );
    245a:	82 e2       	ldi	r24, 0x22	; 34
    245c:	97 e0       	ldi	r25, 0x07	; 7
    245e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <average_samples>
    2462:	ef 81       	ldd	r30, Y+7	; 0x07
    2464:	f8 85       	ldd	r31, Y+8	; 0x08
    2466:	e5 5a       	subi	r30, 0xA5	; 165
    2468:	ff 4f       	sbci	r31, 0xFF	; 255
    246a:	80 83       	st	Z, r24

uint8_t V_ack_change( void )
{
  uint8_t temp;

  temp = V_upper_val_change;
    246c:	80 91 7f 0b 	lds	r24, 0x0B7F
  V_upper_val_change = 0;
    2470:	10 92 7f 0b 	sts	0x0B7F, r1
  //uint8_t temperature_error1;
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
    2474:	ef 81       	ldd	r30, Y+7	; 0x07
    2476:	f8 85       	ldd	r31, Y+8	; 0x08
    2478:	e4 5a       	subi	r30, 0xA4	; 164
    247a:	ff 4f       	sbci	r31, 0xFF	; 255
    247c:	80 83       	st	Z, r24

uint8_t I_ack_change( void )
{
  uint8_t temp;

  temp = I_upper_val_change;
    247e:	80 91 7a 0b 	lds	r24, 0x0B7A
  I_upper_val_change = 0;
    2482:	10 92 7a 0b 	sts	0x0B7A, r1
  //uint8_t temperature_error2;
  //uint8_t temperature_error3;
  //uint8_t temperature_error4;
  
  packet_payload[92] = V_ack_change();
  packet_payload[93] = I_ack_change();
    2486:	ef 81       	ldd	r30, Y+7	; 0x07
    2488:	f8 85       	ldd	r31, Y+8	; 0x08
    248a:	e3 5a       	subi	r30, 0xA3	; 163
    248c:	ff 4f       	sbci	r31, 0xFF	; 255
    248e:	80 83       	st	Z, r24
}
    2490:	28 96       	adiw	r28, 0x08	; 8
    2492:	0f b6       	in	r0, 0x3f	; 63
    2494:	f8 94       	cli
    2496:	de bf       	out	0x3e, r29	; 62
    2498:	0f be       	out	0x3f, r0	; 63
    249a:	cd bf       	out	0x3d, r28	; 61
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	ff 90       	pop	r15
    24a6:	ef 90       	pop	r14
    24a8:	df 90       	pop	r13
    24aa:	cf 90       	pop	r12
    24ac:	bf 90       	pop	r11
    24ae:	af 90       	pop	r10
    24b0:	9f 90       	pop	r9
    24b2:	8f 90       	pop	r8
    24b4:	7f 90       	pop	r7
    24b6:	6f 90       	pop	r6
    24b8:	5f 90       	pop	r5
    24ba:	4f 90       	pop	r4
    24bc:	3f 90       	pop	r3
    24be:	2f 90       	pop	r2
    24c0:	08 95       	ret

000024c2 <transmit_packet>:

void transmit_packet( uint8_t uart, uint8_t packet_type, uint8_t ack_command )
{
    24c2:	6f 92       	push	r6
    24c4:	7f 92       	push	r7
    24c6:	8f 92       	push	r8
    24c8:	9f 92       	push	r9
    24ca:	bf 92       	push	r11
    24cc:	cf 92       	push	r12
    24ce:	df 92       	push	r13
    24d0:	ef 92       	push	r14
    24d2:	ff 92       	push	r15
    24d4:	0f 93       	push	r16
    24d6:	1f 93       	push	r17
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
    24dc:	b8 2e       	mov	r11, r24
  uint8_t VCP_tx_status;

  switch( packet_type )
    24de:	61 30       	cpi	r22, 0x01	; 1
    24e0:	b9 f0       	breq	.+46     	; 0x2510 <transmit_packet+0x4e>
    24e2:	20 f0       	brcs	.+8      	; 0x24ec <transmit_packet+0x2a>
    24e4:	62 30       	cpi	r22, 0x02	; 2
    24e6:	09 f0       	breq	.+2      	; 0x24ea <transmit_packet+0x28>
    24e8:	8b c0       	rjmp	.+278    	; 0x2600 <transmit_packet+0x13e>
    24ea:	22 c0       	rjmp	.+68     	; 0x2530 <transmit_packet+0x6e>
  {
    case VCP_POWER_TELEMETRY:
      construct_telemetry_packet( tel_packet_payload[uart] );
    24ec:	c8 2f       	mov	r28, r24
    24ee:	d0 e0       	ldi	r29, 0x00	; 0
    24f0:	2f ef       	ldi	r18, 0xFF	; 255
    24f2:	82 9f       	mul	r24, r18
    24f4:	c0 01       	movw	r24, r0
    24f6:	11 24       	eor	r1, r1
    24f8:	8e 54       	subi	r24, 0x4E	; 78
    24fa:	92 4f       	sbci	r25, 0xF2	; 242
    24fc:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <construct_telemetry_packet>
      tel_packet_payload_size[uart] = 96;
    2500:	fe 01       	movw	r30, r28
    2502:	ee 0f       	add	r30, r30
    2504:	ff 1f       	adc	r31, r31
    2506:	e9 5c       	subi	r30, 0xC9	; 201
    2508:	f8 4f       	sbci	r31, 0xF8	; 248
    250a:	80 e6       	ldi	r24, 0x60	; 96
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	21 c0       	rjmp	.+66     	; 0x2552 <transmit_packet+0x90>
      break;
    case VCP_INVALID_COMMAND:
      tel_packet_payload[uart][0] = VCP_INVALID_COMMAND;
    2510:	e8 2f       	mov	r30, r24
    2512:	f0 e0       	ldi	r31, 0x00	; 0
    2514:	8f ef       	ldi	r24, 0xFF	; 255
    2516:	b8 9e       	mul	r11, r24
    2518:	d0 01       	movw	r26, r0
    251a:	11 24       	eor	r1, r1
    251c:	ae 54       	subi	r26, 0x4E	; 78
    251e:	b2 4f       	sbci	r27, 0xF2	; 242
    2520:	6c 93       	st	X, r22
      tel_packet_payload_size[uart] = 1;
    2522:	ee 0f       	add	r30, r30
    2524:	ff 1f       	adc	r31, r31
    2526:	e9 5c       	subi	r30, 0xC9	; 201
    2528:	f8 4f       	sbci	r31, 0xF8	; 248
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	90 e0       	ldi	r25, 0x00	; 0
    252e:	11 c0       	rjmp	.+34     	; 0x2552 <transmit_packet+0x90>
      break;
    case VCP_ACK:
      tel_packet_payload[uart][0] = VCP_ACK;
    2530:	e8 2f       	mov	r30, r24
    2532:	f0 e0       	ldi	r31, 0x00	; 0
    2534:	2f ef       	ldi	r18, 0xFF	; 255
    2536:	82 9f       	mul	r24, r18
    2538:	d0 01       	movw	r26, r0
    253a:	11 24       	eor	r1, r1
    253c:	ae 54       	subi	r26, 0x4E	; 78
    253e:	b2 4f       	sbci	r27, 0xF2	; 242
    2540:	6c 93       	st	X, r22
      tel_packet_payload[uart][1] = ack_command;
    2542:	11 96       	adiw	r26, 0x01	; 1
    2544:	4c 93       	st	X, r20
      tel_packet_payload_size[uart] = 2;
    2546:	ee 0f       	add	r30, r30
    2548:	ff 1f       	adc	r31, r31
    254a:	e9 5c       	subi	r30, 0xC9	; 201
    254c:	f8 4f       	sbci	r31, 0xF8	; 248
    254e:	82 e0       	ldi	r24, 0x02	; 2
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	91 83       	std	Z+1, r25	; 0x01
    2554:	80 83       	st	Z, r24
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2556:	8b 2c       	mov	r8, r11
    2558:	91 2c       	mov	r9, r1
    255a:	8f ef       	ldi	r24, 0xFF	; 255
    255c:	b8 9e       	mul	r11, r24
    255e:	70 01       	movw	r14, r0
    2560:	11 24       	eor	r1, r1
    2562:	e7 01       	movw	r28, r14
    2564:	c8 58       	subi	r28, 0x88	; 136
    2566:	d6 4f       	sbci	r29, 0xF6	; 246
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
    2568:	64 01       	movw	r12, r8
    256a:	cc 0c       	add	r12, r12
    256c:	dd 1c       	adc	r13, r13
    256e:	f6 01       	movw	r30, r12
    2570:	e9 5c       	subi	r30, 0xC9	; 201
    2572:	f8 4f       	sbci	r31, 0xF8	; 248
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    2574:	00 81       	ld	r16, Z
    2576:	11 81       	ldd	r17, Z+1	; 0x01
                                    &dest_size[uart],
                                    VCP_PWR_BOARD_ADDR,
                                    tel_packet_payload[uart],
    2578:	97 01       	movw	r18, r14
    257a:	2e 54       	subi	r18, 0x4E	; 78
    257c:	32 4f       	sbci	r19, 0xF2	; 242
    default:
      return;
  }

  // create VCP frame in the peripheral transmit buffer
  VCP_tx_status = Create_VCP_frame( dest_data[uart],
    257e:	a4 e8       	ldi	r26, 0x84	; 132
    2580:	6a 2e       	mov	r6, r26
    2582:	ad e0       	ldi	r26, 0x0D	; 13
    2584:	7a 2e       	mov	r7, r26
    2586:	6c 0c       	add	r6, r12
    2588:	7d 1c       	adc	r7, r13
    258a:	41 e0       	ldi	r20, 0x01	; 1
    258c:	b3 01       	movw	r22, r6
    258e:	ce 01       	movw	r24, r28
    2590:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <Create_VCP_frame>
                                    tel_packet_payload[uart],
                                    tel_packet_payload_size[uart]
                  );

  // VCP frame creation was successful
  if ( VCP_tx_status == VCP_TERM )
    2594:	81 30       	cpi	r24, 0x01	; 1
    2596:	a1 f5       	brne	.+104    	; 0x2600 <transmit_packet+0x13e>
  {
    tel_packet_size[uart] = dest_size[uart];
    2598:	f3 01       	movw	r30, r6
    259a:	80 81       	ld	r24, Z
    259c:	91 81       	ldd	r25, Z+1	; 0x01
    259e:	f6 01       	movw	r30, r12
    25a0:	e9 5d       	subi	r30, 0xD9	; 217
    25a2:	fc 4f       	sbci	r31, 0xFC	; 252
    25a4:	91 83       	std	Z+1, r25	; 0x01
    25a6:	80 83       	st	Z, r24
    memcpy( tel_packet[uart], dest_data[uart], tel_packet_size[uart] );
    25a8:	80 81       	ld	r24, Z
    25aa:	91 81       	ldd	r25, Z+1	; 0x01
    25ac:	97 01       	movw	r18, r14
    25ae:	2a 5b       	subi	r18, 0xBA	; 186
    25b0:	38 4f       	sbci	r19, 0xF8	; 248
    25b2:	ac 01       	movw	r20, r24
    25b4:	be 01       	movw	r22, r28
    25b6:	c9 01       	movw	r24, r18
    25b8:	0e 94 f7 15 	call	0x2bee	; 0x2bee <memcpy>
    tel_packet_index[uart] = 0;
    25bc:	f4 01       	movw	r30, r8
    25be:	e1 5c       	subi	r30, 0xC1	; 193
    25c0:	f8 4f       	sbci	r31, 0xF8	; 248
    25c2:	10 82       	st	Z, r1
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
    25c4:	f1 e0       	ldi	r31, 0x01	; 1
    25c6:	bf 12       	cpse	r11, r31
    25c8:	06 c0       	rjmp	.+12     	; 0x25d6 <transmit_packet+0x114>
    25ca:	80 91 9b 00 	lds	r24, 0x009B
    25ce:	88 23       	and	r24, r24
    25d0:	b9 f0       	breq	.+46     	; 0x2600 <transmit_packet+0x13e>
      tx_put_byte( uart );
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	06 c0       	rjmp	.+12     	; 0x25e2 <transmit_packet+0x120>
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
    25d6:	b1 10       	cpse	r11, r1
    25d8:	13 c0       	rjmp	.+38     	; 0x2600 <transmit_packet+0x13e>
    25da:	8b b1       	in	r24, 0x0b	; 11
    25dc:	88 23       	and	r24, r24
    25de:	81 f0       	breq	.+32     	; 0x2600 <transmit_packet+0x13e>
      tx_put_byte( uart );
    25e0:	80 e0       	ldi	r24, 0x00	; 0
  }
}
    25e2:	df 91       	pop	r29
    25e4:	cf 91       	pop	r28
    25e6:	1f 91       	pop	r17
    25e8:	0f 91       	pop	r16
    25ea:	ff 90       	pop	r15
    25ec:	ef 90       	pop	r14
    25ee:	df 90       	pop	r13
    25f0:	cf 90       	pop	r12
    25f2:	bf 90       	pop	r11
    25f4:	9f 90       	pop	r9
    25f6:	8f 90       	pop	r8
    25f8:	7f 90       	pop	r7
    25fa:	6f 90       	pop	r6
    tel_packet_index[uart] = 0;
    // transmit first byte
    if ( uart == 1  && UCSR1A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    else if ( uart == 0  && UCSR0A && ( 1 << UDRE ) )
      tx_put_byte( uart );
    25fc:	0c 94 c5 0e 	jmp	0x1d8a	; 0x1d8a <tx_put_byte>
  }
}
    2600:	df 91       	pop	r29
    2602:	cf 91       	pop	r28
    2604:	1f 91       	pop	r17
    2606:	0f 91       	pop	r16
    2608:	ff 90       	pop	r15
    260a:	ef 90       	pop	r14
    260c:	df 90       	pop	r13
    260e:	cf 90       	pop	r12
    2610:	bf 90       	pop	r11
    2612:	9f 90       	pop	r9
    2614:	8f 90       	pop	r8
    2616:	7f 90       	pop	r7
    2618:	6f 90       	pop	r6
    261a:	08 95       	ret

0000261c <__subsf3>:
    261c:	50 58       	subi	r21, 0x80	; 128

0000261e <__addsf3>:
    261e:	bb 27       	eor	r27, r27
    2620:	aa 27       	eor	r26, r26
    2622:	0e d0       	rcall	.+28     	; 0x2640 <__addsf3x>
    2624:	44 c1       	rjmp	.+648    	; 0x28ae <__fp_round>
    2626:	35 d1       	rcall	.+618    	; 0x2892 <__fp_pscA>
    2628:	30 f0       	brcs	.+12     	; 0x2636 <__addsf3+0x18>
    262a:	3a d1       	rcall	.+628    	; 0x28a0 <__fp_pscB>
    262c:	20 f0       	brcs	.+8      	; 0x2636 <__addsf3+0x18>
    262e:	31 f4       	brne	.+12     	; 0x263c <__addsf3+0x1e>
    2630:	9f 3f       	cpi	r25, 0xFF	; 255
    2632:	11 f4       	brne	.+4      	; 0x2638 <__addsf3+0x1a>
    2634:	1e f4       	brtc	.+6      	; 0x263c <__addsf3+0x1e>
    2636:	2a c1       	rjmp	.+596    	; 0x288c <__fp_nan>
    2638:	0e f4       	brtc	.+2      	; 0x263c <__addsf3+0x1e>
    263a:	e0 95       	com	r30
    263c:	e7 fb       	bst	r30, 7
    263e:	20 c1       	rjmp	.+576    	; 0x2880 <__fp_inf>

00002640 <__addsf3x>:
    2640:	e9 2f       	mov	r30, r25
    2642:	46 d1       	rcall	.+652    	; 0x28d0 <__fp_split3>
    2644:	80 f3       	brcs	.-32     	; 0x2626 <__addsf3+0x8>
    2646:	ba 17       	cp	r27, r26
    2648:	62 07       	cpc	r22, r18
    264a:	73 07       	cpc	r23, r19
    264c:	84 07       	cpc	r24, r20
    264e:	95 07       	cpc	r25, r21
    2650:	18 f0       	brcs	.+6      	; 0x2658 <__addsf3x+0x18>
    2652:	71 f4       	brne	.+28     	; 0x2670 <__addsf3x+0x30>
    2654:	9e f5       	brtc	.+102    	; 0x26bc <__addsf3x+0x7c>
    2656:	5e c1       	rjmp	.+700    	; 0x2914 <__fp_zero>
    2658:	0e f4       	brtc	.+2      	; 0x265c <__addsf3x+0x1c>
    265a:	e0 95       	com	r30
    265c:	0b 2e       	mov	r0, r27
    265e:	ba 2f       	mov	r27, r26
    2660:	a0 2d       	mov	r26, r0
    2662:	0b 01       	movw	r0, r22
    2664:	b9 01       	movw	r22, r18
    2666:	90 01       	movw	r18, r0
    2668:	0c 01       	movw	r0, r24
    266a:	ca 01       	movw	r24, r20
    266c:	a0 01       	movw	r20, r0
    266e:	11 24       	eor	r1, r1
    2670:	ff 27       	eor	r31, r31
    2672:	59 1b       	sub	r21, r25
    2674:	99 f0       	breq	.+38     	; 0x269c <__addsf3x+0x5c>
    2676:	59 3f       	cpi	r21, 0xF9	; 249
    2678:	50 f4       	brcc	.+20     	; 0x268e <__addsf3x+0x4e>
    267a:	50 3e       	cpi	r21, 0xE0	; 224
    267c:	68 f1       	brcs	.+90     	; 0x26d8 <__addsf3x+0x98>
    267e:	1a 16       	cp	r1, r26
    2680:	f0 40       	sbci	r31, 0x00	; 0
    2682:	a2 2f       	mov	r26, r18
    2684:	23 2f       	mov	r18, r19
    2686:	34 2f       	mov	r19, r20
    2688:	44 27       	eor	r20, r20
    268a:	58 5f       	subi	r21, 0xF8	; 248
    268c:	f3 cf       	rjmp	.-26     	; 0x2674 <__addsf3x+0x34>
    268e:	46 95       	lsr	r20
    2690:	37 95       	ror	r19
    2692:	27 95       	ror	r18
    2694:	a7 95       	ror	r26
    2696:	f0 40       	sbci	r31, 0x00	; 0
    2698:	53 95       	inc	r21
    269a:	c9 f7       	brne	.-14     	; 0x268e <__addsf3x+0x4e>
    269c:	7e f4       	brtc	.+30     	; 0x26bc <__addsf3x+0x7c>
    269e:	1f 16       	cp	r1, r31
    26a0:	ba 0b       	sbc	r27, r26
    26a2:	62 0b       	sbc	r22, r18
    26a4:	73 0b       	sbc	r23, r19
    26a6:	84 0b       	sbc	r24, r20
    26a8:	ba f0       	brmi	.+46     	; 0x26d8 <__addsf3x+0x98>
    26aa:	91 50       	subi	r25, 0x01	; 1
    26ac:	a1 f0       	breq	.+40     	; 0x26d6 <__addsf3x+0x96>
    26ae:	ff 0f       	add	r31, r31
    26b0:	bb 1f       	adc	r27, r27
    26b2:	66 1f       	adc	r22, r22
    26b4:	77 1f       	adc	r23, r23
    26b6:	88 1f       	adc	r24, r24
    26b8:	c2 f7       	brpl	.-16     	; 0x26aa <__addsf3x+0x6a>
    26ba:	0e c0       	rjmp	.+28     	; 0x26d8 <__addsf3x+0x98>
    26bc:	ba 0f       	add	r27, r26
    26be:	62 1f       	adc	r22, r18
    26c0:	73 1f       	adc	r23, r19
    26c2:	84 1f       	adc	r24, r20
    26c4:	48 f4       	brcc	.+18     	; 0x26d8 <__addsf3x+0x98>
    26c6:	87 95       	ror	r24
    26c8:	77 95       	ror	r23
    26ca:	67 95       	ror	r22
    26cc:	b7 95       	ror	r27
    26ce:	f7 95       	ror	r31
    26d0:	9e 3f       	cpi	r25, 0xFE	; 254
    26d2:	08 f0       	brcs	.+2      	; 0x26d6 <__addsf3x+0x96>
    26d4:	b3 cf       	rjmp	.-154    	; 0x263c <__addsf3+0x1e>
    26d6:	93 95       	inc	r25
    26d8:	88 0f       	add	r24, r24
    26da:	08 f0       	brcs	.+2      	; 0x26de <__addsf3x+0x9e>
    26dc:	99 27       	eor	r25, r25
    26de:	ee 0f       	add	r30, r30
    26e0:	97 95       	ror	r25
    26e2:	87 95       	ror	r24
    26e4:	08 95       	ret

000026e6 <__cmpsf2>:
    26e6:	a8 d0       	rcall	.+336    	; 0x2838 <__fp_cmp>
    26e8:	08 f4       	brcc	.+2      	; 0x26ec <__cmpsf2+0x6>
    26ea:	81 e0       	ldi	r24, 0x01	; 1
    26ec:	08 95       	ret

000026ee <__divsf3>:
    26ee:	0c d0       	rcall	.+24     	; 0x2708 <__divsf3x>
    26f0:	de c0       	rjmp	.+444    	; 0x28ae <__fp_round>
    26f2:	d6 d0       	rcall	.+428    	; 0x28a0 <__fp_pscB>
    26f4:	40 f0       	brcs	.+16     	; 0x2706 <__divsf3+0x18>
    26f6:	cd d0       	rcall	.+410    	; 0x2892 <__fp_pscA>
    26f8:	30 f0       	brcs	.+12     	; 0x2706 <__divsf3+0x18>
    26fa:	21 f4       	brne	.+8      	; 0x2704 <__divsf3+0x16>
    26fc:	5f 3f       	cpi	r21, 0xFF	; 255
    26fe:	19 f0       	breq	.+6      	; 0x2706 <__divsf3+0x18>
    2700:	bf c0       	rjmp	.+382    	; 0x2880 <__fp_inf>
    2702:	51 11       	cpse	r21, r1
    2704:	08 c1       	rjmp	.+528    	; 0x2916 <__fp_szero>
    2706:	c2 c0       	rjmp	.+388    	; 0x288c <__fp_nan>

00002708 <__divsf3x>:
    2708:	e3 d0       	rcall	.+454    	; 0x28d0 <__fp_split3>
    270a:	98 f3       	brcs	.-26     	; 0x26f2 <__divsf3+0x4>

0000270c <__divsf3_pse>:
    270c:	99 23       	and	r25, r25
    270e:	c9 f3       	breq	.-14     	; 0x2702 <__divsf3+0x14>
    2710:	55 23       	and	r21, r21
    2712:	b1 f3       	breq	.-20     	; 0x2700 <__divsf3+0x12>
    2714:	95 1b       	sub	r25, r21
    2716:	55 0b       	sbc	r21, r21
    2718:	bb 27       	eor	r27, r27
    271a:	aa 27       	eor	r26, r26
    271c:	62 17       	cp	r22, r18
    271e:	73 07       	cpc	r23, r19
    2720:	84 07       	cpc	r24, r20
    2722:	38 f0       	brcs	.+14     	; 0x2732 <__divsf3_pse+0x26>
    2724:	9f 5f       	subi	r25, 0xFF	; 255
    2726:	5f 4f       	sbci	r21, 0xFF	; 255
    2728:	22 0f       	add	r18, r18
    272a:	33 1f       	adc	r19, r19
    272c:	44 1f       	adc	r20, r20
    272e:	aa 1f       	adc	r26, r26
    2730:	a9 f3       	breq	.-22     	; 0x271c <__divsf3_pse+0x10>
    2732:	33 d0       	rcall	.+102    	; 0x279a <__divsf3_pse+0x8e>
    2734:	0e 2e       	mov	r0, r30
    2736:	3a f0       	brmi	.+14     	; 0x2746 <__divsf3_pse+0x3a>
    2738:	e0 e8       	ldi	r30, 0x80	; 128
    273a:	30 d0       	rcall	.+96     	; 0x279c <__divsf3_pse+0x90>
    273c:	91 50       	subi	r25, 0x01	; 1
    273e:	50 40       	sbci	r21, 0x00	; 0
    2740:	e6 95       	lsr	r30
    2742:	00 1c       	adc	r0, r0
    2744:	ca f7       	brpl	.-14     	; 0x2738 <__divsf3_pse+0x2c>
    2746:	29 d0       	rcall	.+82     	; 0x279a <__divsf3_pse+0x8e>
    2748:	fe 2f       	mov	r31, r30
    274a:	27 d0       	rcall	.+78     	; 0x279a <__divsf3_pse+0x8e>
    274c:	66 0f       	add	r22, r22
    274e:	77 1f       	adc	r23, r23
    2750:	88 1f       	adc	r24, r24
    2752:	bb 1f       	adc	r27, r27
    2754:	26 17       	cp	r18, r22
    2756:	37 07       	cpc	r19, r23
    2758:	48 07       	cpc	r20, r24
    275a:	ab 07       	cpc	r26, r27
    275c:	b0 e8       	ldi	r27, 0x80	; 128
    275e:	09 f0       	breq	.+2      	; 0x2762 <__divsf3_pse+0x56>
    2760:	bb 0b       	sbc	r27, r27
    2762:	80 2d       	mov	r24, r0
    2764:	bf 01       	movw	r22, r30
    2766:	ff 27       	eor	r31, r31
    2768:	93 58       	subi	r25, 0x83	; 131
    276a:	5f 4f       	sbci	r21, 0xFF	; 255
    276c:	2a f0       	brmi	.+10     	; 0x2778 <__divsf3_pse+0x6c>
    276e:	9e 3f       	cpi	r25, 0xFE	; 254
    2770:	51 05       	cpc	r21, r1
    2772:	68 f0       	brcs	.+26     	; 0x278e <__divsf3_pse+0x82>
    2774:	85 c0       	rjmp	.+266    	; 0x2880 <__fp_inf>
    2776:	cf c0       	rjmp	.+414    	; 0x2916 <__fp_szero>
    2778:	5f 3f       	cpi	r21, 0xFF	; 255
    277a:	ec f3       	brlt	.-6      	; 0x2776 <__divsf3_pse+0x6a>
    277c:	98 3e       	cpi	r25, 0xE8	; 232
    277e:	dc f3       	brlt	.-10     	; 0x2776 <__divsf3_pse+0x6a>
    2780:	86 95       	lsr	r24
    2782:	77 95       	ror	r23
    2784:	67 95       	ror	r22
    2786:	b7 95       	ror	r27
    2788:	f7 95       	ror	r31
    278a:	9f 5f       	subi	r25, 0xFF	; 255
    278c:	c9 f7       	brne	.-14     	; 0x2780 <__divsf3_pse+0x74>
    278e:	88 0f       	add	r24, r24
    2790:	91 1d       	adc	r25, r1
    2792:	96 95       	lsr	r25
    2794:	87 95       	ror	r24
    2796:	97 f9       	bld	r25, 7
    2798:	08 95       	ret
    279a:	e1 e0       	ldi	r30, 0x01	; 1
    279c:	66 0f       	add	r22, r22
    279e:	77 1f       	adc	r23, r23
    27a0:	88 1f       	adc	r24, r24
    27a2:	bb 1f       	adc	r27, r27
    27a4:	62 17       	cp	r22, r18
    27a6:	73 07       	cpc	r23, r19
    27a8:	84 07       	cpc	r24, r20
    27aa:	ba 07       	cpc	r27, r26
    27ac:	20 f0       	brcs	.+8      	; 0x27b6 <__divsf3_pse+0xaa>
    27ae:	62 1b       	sub	r22, r18
    27b0:	73 0b       	sbc	r23, r19
    27b2:	84 0b       	sbc	r24, r20
    27b4:	ba 0b       	sbc	r27, r26
    27b6:	ee 1f       	adc	r30, r30
    27b8:	88 f7       	brcc	.-30     	; 0x279c <__divsf3_pse+0x90>
    27ba:	e0 95       	com	r30
    27bc:	08 95       	ret

000027be <__floatunsisf>:
    27be:	e8 94       	clt
    27c0:	09 c0       	rjmp	.+18     	; 0x27d4 <__floatsisf+0x12>

000027c2 <__floatsisf>:
    27c2:	97 fb       	bst	r25, 7
    27c4:	3e f4       	brtc	.+14     	; 0x27d4 <__floatsisf+0x12>
    27c6:	90 95       	com	r25
    27c8:	80 95       	com	r24
    27ca:	70 95       	com	r23
    27cc:	61 95       	neg	r22
    27ce:	7f 4f       	sbci	r23, 0xFF	; 255
    27d0:	8f 4f       	sbci	r24, 0xFF	; 255
    27d2:	9f 4f       	sbci	r25, 0xFF	; 255
    27d4:	99 23       	and	r25, r25
    27d6:	a9 f0       	breq	.+42     	; 0x2802 <__floatsisf+0x40>
    27d8:	f9 2f       	mov	r31, r25
    27da:	96 e9       	ldi	r25, 0x96	; 150
    27dc:	bb 27       	eor	r27, r27
    27de:	93 95       	inc	r25
    27e0:	f6 95       	lsr	r31
    27e2:	87 95       	ror	r24
    27e4:	77 95       	ror	r23
    27e6:	67 95       	ror	r22
    27e8:	b7 95       	ror	r27
    27ea:	f1 11       	cpse	r31, r1
    27ec:	f8 cf       	rjmp	.-16     	; 0x27de <__floatsisf+0x1c>
    27ee:	fa f4       	brpl	.+62     	; 0x282e <__floatsisf+0x6c>
    27f0:	bb 0f       	add	r27, r27
    27f2:	11 f4       	brne	.+4      	; 0x27f8 <__floatsisf+0x36>
    27f4:	60 ff       	sbrs	r22, 0
    27f6:	1b c0       	rjmp	.+54     	; 0x282e <__floatsisf+0x6c>
    27f8:	6f 5f       	subi	r22, 0xFF	; 255
    27fa:	7f 4f       	sbci	r23, 0xFF	; 255
    27fc:	8f 4f       	sbci	r24, 0xFF	; 255
    27fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2800:	16 c0       	rjmp	.+44     	; 0x282e <__floatsisf+0x6c>
    2802:	88 23       	and	r24, r24
    2804:	11 f0       	breq	.+4      	; 0x280a <__floatsisf+0x48>
    2806:	96 e9       	ldi	r25, 0x96	; 150
    2808:	11 c0       	rjmp	.+34     	; 0x282c <__floatsisf+0x6a>
    280a:	77 23       	and	r23, r23
    280c:	21 f0       	breq	.+8      	; 0x2816 <__floatsisf+0x54>
    280e:	9e e8       	ldi	r25, 0x8E	; 142
    2810:	87 2f       	mov	r24, r23
    2812:	76 2f       	mov	r23, r22
    2814:	05 c0       	rjmp	.+10     	; 0x2820 <__floatsisf+0x5e>
    2816:	66 23       	and	r22, r22
    2818:	71 f0       	breq	.+28     	; 0x2836 <__floatsisf+0x74>
    281a:	96 e8       	ldi	r25, 0x86	; 134
    281c:	86 2f       	mov	r24, r22
    281e:	70 e0       	ldi	r23, 0x00	; 0
    2820:	60 e0       	ldi	r22, 0x00	; 0
    2822:	2a f0       	brmi	.+10     	; 0x282e <__floatsisf+0x6c>
    2824:	9a 95       	dec	r25
    2826:	66 0f       	add	r22, r22
    2828:	77 1f       	adc	r23, r23
    282a:	88 1f       	adc	r24, r24
    282c:	da f7       	brpl	.-10     	; 0x2824 <__floatsisf+0x62>
    282e:	88 0f       	add	r24, r24
    2830:	96 95       	lsr	r25
    2832:	87 95       	ror	r24
    2834:	97 f9       	bld	r25, 7
    2836:	08 95       	ret

00002838 <__fp_cmp>:
    2838:	99 0f       	add	r25, r25
    283a:	00 08       	sbc	r0, r0
    283c:	55 0f       	add	r21, r21
    283e:	aa 0b       	sbc	r26, r26
    2840:	e0 e8       	ldi	r30, 0x80	; 128
    2842:	fe ef       	ldi	r31, 0xFE	; 254
    2844:	16 16       	cp	r1, r22
    2846:	17 06       	cpc	r1, r23
    2848:	e8 07       	cpc	r30, r24
    284a:	f9 07       	cpc	r31, r25
    284c:	c0 f0       	brcs	.+48     	; 0x287e <__fp_cmp+0x46>
    284e:	12 16       	cp	r1, r18
    2850:	13 06       	cpc	r1, r19
    2852:	e4 07       	cpc	r30, r20
    2854:	f5 07       	cpc	r31, r21
    2856:	98 f0       	brcs	.+38     	; 0x287e <__fp_cmp+0x46>
    2858:	62 1b       	sub	r22, r18
    285a:	73 0b       	sbc	r23, r19
    285c:	84 0b       	sbc	r24, r20
    285e:	95 0b       	sbc	r25, r21
    2860:	39 f4       	brne	.+14     	; 0x2870 <__fp_cmp+0x38>
    2862:	0a 26       	eor	r0, r26
    2864:	61 f0       	breq	.+24     	; 0x287e <__fp_cmp+0x46>
    2866:	23 2b       	or	r18, r19
    2868:	24 2b       	or	r18, r20
    286a:	25 2b       	or	r18, r21
    286c:	21 f4       	brne	.+8      	; 0x2876 <__fp_cmp+0x3e>
    286e:	08 95       	ret
    2870:	0a 26       	eor	r0, r26
    2872:	09 f4       	brne	.+2      	; 0x2876 <__fp_cmp+0x3e>
    2874:	a1 40       	sbci	r26, 0x01	; 1
    2876:	a6 95       	lsr	r26
    2878:	8f ef       	ldi	r24, 0xFF	; 255
    287a:	81 1d       	adc	r24, r1
    287c:	81 1d       	adc	r24, r1
    287e:	08 95       	ret

00002880 <__fp_inf>:
    2880:	97 f9       	bld	r25, 7
    2882:	9f 67       	ori	r25, 0x7F	; 127
    2884:	80 e8       	ldi	r24, 0x80	; 128
    2886:	70 e0       	ldi	r23, 0x00	; 0
    2888:	60 e0       	ldi	r22, 0x00	; 0
    288a:	08 95       	ret

0000288c <__fp_nan>:
    288c:	9f ef       	ldi	r25, 0xFF	; 255
    288e:	80 ec       	ldi	r24, 0xC0	; 192
    2890:	08 95       	ret

00002892 <__fp_pscA>:
    2892:	00 24       	eor	r0, r0
    2894:	0a 94       	dec	r0
    2896:	16 16       	cp	r1, r22
    2898:	17 06       	cpc	r1, r23
    289a:	18 06       	cpc	r1, r24
    289c:	09 06       	cpc	r0, r25
    289e:	08 95       	ret

000028a0 <__fp_pscB>:
    28a0:	00 24       	eor	r0, r0
    28a2:	0a 94       	dec	r0
    28a4:	12 16       	cp	r1, r18
    28a6:	13 06       	cpc	r1, r19
    28a8:	14 06       	cpc	r1, r20
    28aa:	05 06       	cpc	r0, r21
    28ac:	08 95       	ret

000028ae <__fp_round>:
    28ae:	09 2e       	mov	r0, r25
    28b0:	03 94       	inc	r0
    28b2:	00 0c       	add	r0, r0
    28b4:	11 f4       	brne	.+4      	; 0x28ba <__fp_round+0xc>
    28b6:	88 23       	and	r24, r24
    28b8:	52 f0       	brmi	.+20     	; 0x28ce <__fp_round+0x20>
    28ba:	bb 0f       	add	r27, r27
    28bc:	40 f4       	brcc	.+16     	; 0x28ce <__fp_round+0x20>
    28be:	bf 2b       	or	r27, r31
    28c0:	11 f4       	brne	.+4      	; 0x28c6 <__fp_round+0x18>
    28c2:	60 ff       	sbrs	r22, 0
    28c4:	04 c0       	rjmp	.+8      	; 0x28ce <__fp_round+0x20>
    28c6:	6f 5f       	subi	r22, 0xFF	; 255
    28c8:	7f 4f       	sbci	r23, 0xFF	; 255
    28ca:	8f 4f       	sbci	r24, 0xFF	; 255
    28cc:	9f 4f       	sbci	r25, 0xFF	; 255
    28ce:	08 95       	ret

000028d0 <__fp_split3>:
    28d0:	57 fd       	sbrc	r21, 7
    28d2:	90 58       	subi	r25, 0x80	; 128
    28d4:	44 0f       	add	r20, r20
    28d6:	55 1f       	adc	r21, r21
    28d8:	59 f0       	breq	.+22     	; 0x28f0 <__fp_splitA+0x10>
    28da:	5f 3f       	cpi	r21, 0xFF	; 255
    28dc:	71 f0       	breq	.+28     	; 0x28fa <__fp_splitA+0x1a>
    28de:	47 95       	ror	r20

000028e0 <__fp_splitA>:
    28e0:	88 0f       	add	r24, r24
    28e2:	97 fb       	bst	r25, 7
    28e4:	99 1f       	adc	r25, r25
    28e6:	61 f0       	breq	.+24     	; 0x2900 <__fp_splitA+0x20>
    28e8:	9f 3f       	cpi	r25, 0xFF	; 255
    28ea:	79 f0       	breq	.+30     	; 0x290a <__fp_splitA+0x2a>
    28ec:	87 95       	ror	r24
    28ee:	08 95       	ret
    28f0:	12 16       	cp	r1, r18
    28f2:	13 06       	cpc	r1, r19
    28f4:	14 06       	cpc	r1, r20
    28f6:	55 1f       	adc	r21, r21
    28f8:	f2 cf       	rjmp	.-28     	; 0x28de <__fp_split3+0xe>
    28fa:	46 95       	lsr	r20
    28fc:	f1 df       	rcall	.-30     	; 0x28e0 <__fp_splitA>
    28fe:	08 c0       	rjmp	.+16     	; 0x2910 <__fp_splitA+0x30>
    2900:	16 16       	cp	r1, r22
    2902:	17 06       	cpc	r1, r23
    2904:	18 06       	cpc	r1, r24
    2906:	99 1f       	adc	r25, r25
    2908:	f1 cf       	rjmp	.-30     	; 0x28ec <__fp_splitA+0xc>
    290a:	86 95       	lsr	r24
    290c:	71 05       	cpc	r23, r1
    290e:	61 05       	cpc	r22, r1
    2910:	08 94       	sec
    2912:	08 95       	ret

00002914 <__fp_zero>:
    2914:	e8 94       	clt

00002916 <__fp_szero>:
    2916:	bb 27       	eor	r27, r27
    2918:	66 27       	eor	r22, r22
    291a:	77 27       	eor	r23, r23
    291c:	cb 01       	movw	r24, r22
    291e:	97 f9       	bld	r25, 7
    2920:	08 95       	ret

00002922 <__gesf2>:
    2922:	8a df       	rcall	.-236    	; 0x2838 <__fp_cmp>
    2924:	08 f4       	brcc	.+2      	; 0x2928 <__gesf2+0x6>
    2926:	8f ef       	ldi	r24, 0xFF	; 255
    2928:	08 95       	ret

0000292a <__udivmodhi4>:
    292a:	aa 1b       	sub	r26, r26
    292c:	bb 1b       	sub	r27, r27
    292e:	51 e1       	ldi	r21, 0x11	; 17
    2930:	07 c0       	rjmp	.+14     	; 0x2940 <__udivmodhi4_ep>

00002932 <__udivmodhi4_loop>:
    2932:	aa 1f       	adc	r26, r26
    2934:	bb 1f       	adc	r27, r27
    2936:	a6 17       	cp	r26, r22
    2938:	b7 07       	cpc	r27, r23
    293a:	10 f0       	brcs	.+4      	; 0x2940 <__udivmodhi4_ep>
    293c:	a6 1b       	sub	r26, r22
    293e:	b7 0b       	sbc	r27, r23

00002940 <__udivmodhi4_ep>:
    2940:	88 1f       	adc	r24, r24
    2942:	99 1f       	adc	r25, r25
    2944:	5a 95       	dec	r21
    2946:	a9 f7       	brne	.-22     	; 0x2932 <__udivmodhi4_loop>
    2948:	80 95       	com	r24
    294a:	90 95       	com	r25
    294c:	bc 01       	movw	r22, r24
    294e:	cd 01       	movw	r24, r26
    2950:	08 95       	ret

00002952 <__divmodhi4>:
    2952:	97 fb       	bst	r25, 7
    2954:	07 2e       	mov	r0, r23
    2956:	16 f4       	brtc	.+4      	; 0x295c <__divmodhi4+0xa>
    2958:	00 94       	com	r0
    295a:	07 d0       	rcall	.+14     	; 0x296a <__divmodhi4_neg1>
    295c:	77 fd       	sbrc	r23, 7
    295e:	09 d0       	rcall	.+18     	; 0x2972 <__divmodhi4_neg2>
    2960:	0e 94 95 14 	call	0x292a	; 0x292a <__udivmodhi4>
    2964:	07 fc       	sbrc	r0, 7
    2966:	05 d0       	rcall	.+10     	; 0x2972 <__divmodhi4_neg2>
    2968:	3e f4       	brtc	.+14     	; 0x2978 <__divmodhi4_exit>

0000296a <__divmodhi4_neg1>:
    296a:	90 95       	com	r25
    296c:	81 95       	neg	r24
    296e:	9f 4f       	sbci	r25, 0xFF	; 255
    2970:	08 95       	ret

00002972 <__divmodhi4_neg2>:
    2972:	70 95       	com	r23
    2974:	61 95       	neg	r22
    2976:	7f 4f       	sbci	r23, 0xFF	; 255

00002978 <__divmodhi4_exit>:
    2978:	08 95       	ret

0000297a <malloc>:
    297a:	0f 93       	push	r16
    297c:	1f 93       	push	r17
    297e:	cf 93       	push	r28
    2980:	df 93       	push	r29
    2982:	82 30       	cpi	r24, 0x02	; 2
    2984:	91 05       	cpc	r25, r1
    2986:	10 f4       	brcc	.+4      	; 0x298c <malloc+0x12>
    2988:	82 e0       	ldi	r24, 0x02	; 2
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	e0 91 b3 0f 	lds	r30, 0x0FB3
    2990:	f0 91 b4 0f 	lds	r31, 0x0FB4
    2994:	20 e0       	ldi	r18, 0x00	; 0
    2996:	30 e0       	ldi	r19, 0x00	; 0
    2998:	c0 e0       	ldi	r28, 0x00	; 0
    299a:	d0 e0       	ldi	r29, 0x00	; 0
    299c:	23 c0       	rjmp	.+70     	; 0x29e4 <malloc+0x6a>
    299e:	40 81       	ld	r20, Z
    29a0:	51 81       	ldd	r21, Z+1	; 0x01
    29a2:	48 17       	cp	r20, r24
    29a4:	59 07       	cpc	r21, r25
    29a6:	a8 f0       	brcs	.+42     	; 0x29d2 <malloc+0x58>
    29a8:	48 17       	cp	r20, r24
    29aa:	59 07       	cpc	r21, r25
    29ac:	61 f4       	brne	.+24     	; 0x29c6 <malloc+0x4c>
    29ae:	82 81       	ldd	r24, Z+2	; 0x02
    29b0:	93 81       	ldd	r25, Z+3	; 0x03
    29b2:	20 97       	sbiw	r28, 0x00	; 0
    29b4:	19 f0       	breq	.+6      	; 0x29bc <malloc+0x42>
    29b6:	9b 83       	std	Y+3, r25	; 0x03
    29b8:	8a 83       	std	Y+2, r24	; 0x02
    29ba:	2e c0       	rjmp	.+92     	; 0x2a18 <malloc+0x9e>
    29bc:	90 93 b4 0f 	sts	0x0FB4, r25
    29c0:	80 93 b3 0f 	sts	0x0FB3, r24
    29c4:	29 c0       	rjmp	.+82     	; 0x2a18 <malloc+0x9e>
    29c6:	21 15       	cp	r18, r1
    29c8:	31 05       	cpc	r19, r1
    29ca:	29 f0       	breq	.+10     	; 0x29d6 <malloc+0x5c>
    29cc:	42 17       	cp	r20, r18
    29ce:	53 07       	cpc	r21, r19
    29d0:	10 f0       	brcs	.+4      	; 0x29d6 <malloc+0x5c>
    29d2:	a9 01       	movw	r20, r18
    29d4:	02 c0       	rjmp	.+4      	; 0x29da <malloc+0x60>
    29d6:	be 01       	movw	r22, r28
    29d8:	df 01       	movw	r26, r30
    29da:	02 81       	ldd	r16, Z+2	; 0x02
    29dc:	13 81       	ldd	r17, Z+3	; 0x03
    29de:	ef 01       	movw	r28, r30
    29e0:	9a 01       	movw	r18, r20
    29e2:	f8 01       	movw	r30, r16
    29e4:	30 97       	sbiw	r30, 0x00	; 0
    29e6:	d9 f6       	brne	.-74     	; 0x299e <malloc+0x24>
    29e8:	21 15       	cp	r18, r1
    29ea:	31 05       	cpc	r19, r1
    29ec:	09 f1       	breq	.+66     	; 0x2a30 <malloc+0xb6>
    29ee:	28 1b       	sub	r18, r24
    29f0:	39 0b       	sbc	r19, r25
    29f2:	24 30       	cpi	r18, 0x04	; 4
    29f4:	31 05       	cpc	r19, r1
    29f6:	90 f4       	brcc	.+36     	; 0x2a1c <malloc+0xa2>
    29f8:	12 96       	adiw	r26, 0x02	; 2
    29fa:	8d 91       	ld	r24, X+
    29fc:	9c 91       	ld	r25, X
    29fe:	13 97       	sbiw	r26, 0x03	; 3
    2a00:	61 15       	cp	r22, r1
    2a02:	71 05       	cpc	r23, r1
    2a04:	21 f0       	breq	.+8      	; 0x2a0e <malloc+0x94>
    2a06:	fb 01       	movw	r30, r22
    2a08:	93 83       	std	Z+3, r25	; 0x03
    2a0a:	82 83       	std	Z+2, r24	; 0x02
    2a0c:	04 c0       	rjmp	.+8      	; 0x2a16 <malloc+0x9c>
    2a0e:	90 93 b4 0f 	sts	0x0FB4, r25
    2a12:	80 93 b3 0f 	sts	0x0FB3, r24
    2a16:	fd 01       	movw	r30, r26
    2a18:	32 96       	adiw	r30, 0x02	; 2
    2a1a:	44 c0       	rjmp	.+136    	; 0x2aa4 <malloc+0x12a>
    2a1c:	fd 01       	movw	r30, r26
    2a1e:	e2 0f       	add	r30, r18
    2a20:	f3 1f       	adc	r31, r19
    2a22:	81 93       	st	Z+, r24
    2a24:	91 93       	st	Z+, r25
    2a26:	22 50       	subi	r18, 0x02	; 2
    2a28:	31 09       	sbc	r19, r1
    2a2a:	2d 93       	st	X+, r18
    2a2c:	3c 93       	st	X, r19
    2a2e:	3a c0       	rjmp	.+116    	; 0x2aa4 <malloc+0x12a>
    2a30:	20 91 b1 0f 	lds	r18, 0x0FB1
    2a34:	30 91 b2 0f 	lds	r19, 0x0FB2
    2a38:	23 2b       	or	r18, r19
    2a3a:	41 f4       	brne	.+16     	; 0x2a4c <malloc+0xd2>
    2a3c:	20 91 02 01 	lds	r18, 0x0102
    2a40:	30 91 03 01 	lds	r19, 0x0103
    2a44:	30 93 b2 0f 	sts	0x0FB2, r19
    2a48:	20 93 b1 0f 	sts	0x0FB1, r18
    2a4c:	20 91 00 01 	lds	r18, 0x0100
    2a50:	30 91 01 01 	lds	r19, 0x0101
    2a54:	21 15       	cp	r18, r1
    2a56:	31 05       	cpc	r19, r1
    2a58:	41 f4       	brne	.+16     	; 0x2a6a <malloc+0xf0>
    2a5a:	2d b7       	in	r18, 0x3d	; 61
    2a5c:	3e b7       	in	r19, 0x3e	; 62
    2a5e:	40 91 04 01 	lds	r20, 0x0104
    2a62:	50 91 05 01 	lds	r21, 0x0105
    2a66:	24 1b       	sub	r18, r20
    2a68:	35 0b       	sbc	r19, r21
    2a6a:	e0 91 b1 0f 	lds	r30, 0x0FB1
    2a6e:	f0 91 b2 0f 	lds	r31, 0x0FB2
    2a72:	e2 17       	cp	r30, r18
    2a74:	f3 07       	cpc	r31, r19
    2a76:	a0 f4       	brcc	.+40     	; 0x2aa0 <malloc+0x126>
    2a78:	2e 1b       	sub	r18, r30
    2a7a:	3f 0b       	sbc	r19, r31
    2a7c:	28 17       	cp	r18, r24
    2a7e:	39 07       	cpc	r19, r25
    2a80:	78 f0       	brcs	.+30     	; 0x2aa0 <malloc+0x126>
    2a82:	ac 01       	movw	r20, r24
    2a84:	4e 5f       	subi	r20, 0xFE	; 254
    2a86:	5f 4f       	sbci	r21, 0xFF	; 255
    2a88:	24 17       	cp	r18, r20
    2a8a:	35 07       	cpc	r19, r21
    2a8c:	48 f0       	brcs	.+18     	; 0x2aa0 <malloc+0x126>
    2a8e:	4e 0f       	add	r20, r30
    2a90:	5f 1f       	adc	r21, r31
    2a92:	50 93 b2 0f 	sts	0x0FB2, r21
    2a96:	40 93 b1 0f 	sts	0x0FB1, r20
    2a9a:	81 93       	st	Z+, r24
    2a9c:	91 93       	st	Z+, r25
    2a9e:	02 c0       	rjmp	.+4      	; 0x2aa4 <malloc+0x12a>
    2aa0:	e0 e0       	ldi	r30, 0x00	; 0
    2aa2:	f0 e0       	ldi	r31, 0x00	; 0
    2aa4:	cf 01       	movw	r24, r30
    2aa6:	df 91       	pop	r29
    2aa8:	cf 91       	pop	r28
    2aaa:	1f 91       	pop	r17
    2aac:	0f 91       	pop	r16
    2aae:	08 95       	ret

00002ab0 <free>:
    2ab0:	ef 92       	push	r14
    2ab2:	ff 92       	push	r15
    2ab4:	0f 93       	push	r16
    2ab6:	1f 93       	push	r17
    2ab8:	cf 93       	push	r28
    2aba:	df 93       	push	r29
    2abc:	00 97       	sbiw	r24, 0x00	; 0
    2abe:	09 f4       	brne	.+2      	; 0x2ac2 <free+0x12>
    2ac0:	8f c0       	rjmp	.+286    	; 0x2be0 <free+0x130>
    2ac2:	dc 01       	movw	r26, r24
    2ac4:	12 97       	sbiw	r26, 0x02	; 2
    2ac6:	13 96       	adiw	r26, 0x03	; 3
    2ac8:	1c 92       	st	X, r1
    2aca:	1e 92       	st	-X, r1
    2acc:	12 97       	sbiw	r26, 0x02	; 2
    2ace:	e0 90 b3 0f 	lds	r14, 0x0FB3
    2ad2:	f0 90 b4 0f 	lds	r15, 0x0FB4
    2ad6:	e1 14       	cp	r14, r1
    2ad8:	f1 04       	cpc	r15, r1
    2ada:	89 f4       	brne	.+34     	; 0x2afe <free+0x4e>
    2adc:	2d 91       	ld	r18, X+
    2ade:	3c 91       	ld	r19, X
    2ae0:	11 97       	sbiw	r26, 0x01	; 1
    2ae2:	28 0f       	add	r18, r24
    2ae4:	39 1f       	adc	r19, r25
    2ae6:	80 91 b1 0f 	lds	r24, 0x0FB1
    2aea:	90 91 b2 0f 	lds	r25, 0x0FB2
    2aee:	82 17       	cp	r24, r18
    2af0:	93 07       	cpc	r25, r19
    2af2:	89 f5       	brne	.+98     	; 0x2b56 <free+0xa6>
    2af4:	b0 93 b2 0f 	sts	0x0FB2, r27
    2af8:	a0 93 b1 0f 	sts	0x0FB1, r26
    2afc:	71 c0       	rjmp	.+226    	; 0x2be0 <free+0x130>
    2afe:	e7 01       	movw	r28, r14
    2b00:	20 e0       	ldi	r18, 0x00	; 0
    2b02:	30 e0       	ldi	r19, 0x00	; 0
    2b04:	01 c0       	rjmp	.+2      	; 0x2b08 <free+0x58>
    2b06:	ea 01       	movw	r28, r20
    2b08:	ca 17       	cp	r28, r26
    2b0a:	db 07       	cpc	r29, r27
    2b0c:	38 f4       	brcc	.+14     	; 0x2b1c <free+0x6c>
    2b0e:	4a 81       	ldd	r20, Y+2	; 0x02
    2b10:	5b 81       	ldd	r21, Y+3	; 0x03
    2b12:	9e 01       	movw	r18, r28
    2b14:	41 15       	cp	r20, r1
    2b16:	51 05       	cpc	r21, r1
    2b18:	b1 f7       	brne	.-20     	; 0x2b06 <free+0x56>
    2b1a:	22 c0       	rjmp	.+68     	; 0x2b60 <free+0xb0>
    2b1c:	bc 01       	movw	r22, r24
    2b1e:	62 50       	subi	r22, 0x02	; 2
    2b20:	71 09       	sbc	r23, r1
    2b22:	fb 01       	movw	r30, r22
    2b24:	d3 83       	std	Z+3, r29	; 0x03
    2b26:	c2 83       	std	Z+2, r28	; 0x02
    2b28:	00 81       	ld	r16, Z
    2b2a:	11 81       	ldd	r17, Z+1	; 0x01
    2b2c:	ac 01       	movw	r20, r24
    2b2e:	40 0f       	add	r20, r16
    2b30:	51 1f       	adc	r21, r17
    2b32:	4c 17       	cp	r20, r28
    2b34:	5d 07       	cpc	r21, r29
    2b36:	61 f4       	brne	.+24     	; 0x2b50 <free+0xa0>
    2b38:	48 81       	ld	r20, Y
    2b3a:	59 81       	ldd	r21, Y+1	; 0x01
    2b3c:	40 0f       	add	r20, r16
    2b3e:	51 1f       	adc	r21, r17
    2b40:	4e 5f       	subi	r20, 0xFE	; 254
    2b42:	5f 4f       	sbci	r21, 0xFF	; 255
    2b44:	51 83       	std	Z+1, r21	; 0x01
    2b46:	40 83       	st	Z, r20
    2b48:	4a 81       	ldd	r20, Y+2	; 0x02
    2b4a:	5b 81       	ldd	r21, Y+3	; 0x03
    2b4c:	53 83       	std	Z+3, r21	; 0x03
    2b4e:	42 83       	std	Z+2, r20	; 0x02
    2b50:	21 15       	cp	r18, r1
    2b52:	31 05       	cpc	r19, r1
    2b54:	29 f4       	brne	.+10     	; 0x2b60 <free+0xb0>
    2b56:	b0 93 b4 0f 	sts	0x0FB4, r27
    2b5a:	a0 93 b3 0f 	sts	0x0FB3, r26
    2b5e:	40 c0       	rjmp	.+128    	; 0x2be0 <free+0x130>
    2b60:	f9 01       	movw	r30, r18
    2b62:	b3 83       	std	Z+3, r27	; 0x03
    2b64:	a2 83       	std	Z+2, r26	; 0x02
    2b66:	e9 01       	movw	r28, r18
    2b68:	69 91       	ld	r22, Y+
    2b6a:	79 91       	ld	r23, Y+
    2b6c:	c6 0f       	add	r28, r22
    2b6e:	d7 1f       	adc	r29, r23
    2b70:	ac 17       	cp	r26, r28
    2b72:	bd 07       	cpc	r27, r29
    2b74:	79 f4       	brne	.+30     	; 0x2b94 <free+0xe4>
    2b76:	dc 01       	movw	r26, r24
    2b78:	5e 91       	ld	r21, -X
    2b7a:	4e 91       	ld	r20, -X
    2b7c:	46 0f       	add	r20, r22
    2b7e:	57 1f       	adc	r21, r23
    2b80:	4e 5f       	subi	r20, 0xFE	; 254
    2b82:	5f 4f       	sbci	r21, 0xFF	; 255
    2b84:	51 83       	std	Z+1, r21	; 0x01
    2b86:	40 83       	st	Z, r20
    2b88:	12 96       	adiw	r26, 0x02	; 2
    2b8a:	8d 91       	ld	r24, X+
    2b8c:	9c 91       	ld	r25, X
    2b8e:	13 97       	sbiw	r26, 0x03	; 3
    2b90:	93 83       	std	Z+3, r25	; 0x03
    2b92:	82 83       	std	Z+2, r24	; 0x02
    2b94:	a0 e0       	ldi	r26, 0x00	; 0
    2b96:	b0 e0       	ldi	r27, 0x00	; 0
    2b98:	02 c0       	rjmp	.+4      	; 0x2b9e <free+0xee>
    2b9a:	d7 01       	movw	r26, r14
    2b9c:	7c 01       	movw	r14, r24
    2b9e:	f7 01       	movw	r30, r14
    2ba0:	82 81       	ldd	r24, Z+2	; 0x02
    2ba2:	93 81       	ldd	r25, Z+3	; 0x03
    2ba4:	00 97       	sbiw	r24, 0x00	; 0
    2ba6:	c9 f7       	brne	.-14     	; 0x2b9a <free+0xea>
    2ba8:	c7 01       	movw	r24, r14
    2baa:	02 96       	adiw	r24, 0x02	; 2
    2bac:	20 81       	ld	r18, Z
    2bae:	31 81       	ldd	r19, Z+1	; 0x01
    2bb0:	82 0f       	add	r24, r18
    2bb2:	93 1f       	adc	r25, r19
    2bb4:	20 91 b1 0f 	lds	r18, 0x0FB1
    2bb8:	30 91 b2 0f 	lds	r19, 0x0FB2
    2bbc:	28 17       	cp	r18, r24
    2bbe:	39 07       	cpc	r19, r25
    2bc0:	79 f4       	brne	.+30     	; 0x2be0 <free+0x130>
    2bc2:	10 97       	sbiw	r26, 0x00	; 0
    2bc4:	29 f4       	brne	.+10     	; 0x2bd0 <free+0x120>
    2bc6:	10 92 b4 0f 	sts	0x0FB4, r1
    2bca:	10 92 b3 0f 	sts	0x0FB3, r1
    2bce:	04 c0       	rjmp	.+8      	; 0x2bd8 <free+0x128>
    2bd0:	13 96       	adiw	r26, 0x03	; 3
    2bd2:	1c 92       	st	X, r1
    2bd4:	1e 92       	st	-X, r1
    2bd6:	12 97       	sbiw	r26, 0x02	; 2
    2bd8:	f0 92 b2 0f 	sts	0x0FB2, r15
    2bdc:	e0 92 b1 0f 	sts	0x0FB1, r14
    2be0:	df 91       	pop	r29
    2be2:	cf 91       	pop	r28
    2be4:	1f 91       	pop	r17
    2be6:	0f 91       	pop	r16
    2be8:	ff 90       	pop	r15
    2bea:	ef 90       	pop	r14
    2bec:	08 95       	ret

00002bee <memcpy>:
    2bee:	fb 01       	movw	r30, r22
    2bf0:	dc 01       	movw	r26, r24
    2bf2:	02 c0       	rjmp	.+4      	; 0x2bf8 <memcpy+0xa>
    2bf4:	01 90       	ld	r0, Z+
    2bf6:	0d 92       	st	X+, r0
    2bf8:	41 50       	subi	r20, 0x01	; 1
    2bfa:	50 40       	sbci	r21, 0x00	; 0
    2bfc:	d8 f7       	brcc	.-10     	; 0x2bf4 <memcpy+0x6>
    2bfe:	08 95       	ret

00002c00 <_exit>:
    2c00:	f8 94       	cli

00002c02 <__stop_program>:
    2c02:	ff cf       	rjmp	.-2      	; 0x2c02 <__stop_program>
